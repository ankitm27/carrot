{"body": {"column":24,"line":13,"wordToComplete":"0.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() {\n    int N,i;\n    scanf(\"%d\",&N);\n    for(i=0;i<=5;i++)\n    {printf(\"%0.1f \",-0.pow(3,i));}\n    return 0;\n}\n\n","offset":233,"fileType":"c","requestStartTime":1517888629451}}
{"body": {"column":15,"line":15,"wordToComplete":"0.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() {\n    int N,i;\n    scanf(\"%d\",&N);\n    for(i=0;i<=5;i++)\n    {\n        c=pow(3,i);\n        c+=(-0.)\n               }\n    return 0;\n}\n\n","offset":250,"fileType":"c","requestStartTime":1517888722612}}
{"body": {"column":8,"line":11,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \nint a,i,j;\nscanf(\"%d\",&a);\nwhile(a>)\n    return 0;\n}\n\n\n","offset":210,"fileType":"c","requestStartTime":1517908975104}}
{"body": {"column":17,"line":11,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \nint a,sum=0,s;\nscanf(\"%d\",&a);\nwhile(a>0)||(sum>)\n{\n s=a%10;\n sum=sum+s;\n a=a/10;\nif(sum<10)\nprintf(\"%d\",sum);}\n\n    return 0;\n}\n\n\n","offset":223,"fileType":"c","requestStartTime":1517909508088}}
{"body": {"column":14,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* solve(int a0, int a1, int a2, int b0, int b1, int b2, int *result_size){\n    // Complete this function\n    int A={a0.}\n}\n\nint main() {\n    int a0; \n    int a1; \n    int a2; \n    scanf(\"%d %d %d\", &a0, &a1, &a2);\n    int b0; \n    int b1; \n    int b2; \n    scanf(\"%d %d %d\", &b0, &b1, &b2);\n    int result_size;\n    int* result = solve(a0, a1, a2, b0, b1, b2, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n    \n\n    return 0;\n}\n\n\n","offset":263,"fileType":"c","requestStartTime":1517910142368}}
{"body": {"column":11,"line":12,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \nint a,sum=0,s;\nscanf(\"%d\",&a);\nwhile(a>0)\n{while(sum>)\n if(a==0)\n {\n a=sum;\n sum=0;\n }\nwhile(a!=0)\n{ s=a%10;\n sum=sum+s;\n a=a/10;\n}printf(\"%d\",sum);\n\n    return 0;\n}\n\n\n","offset":228,"fileType":"c","requestStartTime":1517911409306}}
{"body": {"column":16,"line":10,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    for(int i=0;)\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":233,"fileType":"c","requestStartTime":1517912005706}}
{"body": {"column":29,"line":10,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    for(int i=0;i<doors_size;)\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":246,"fileType":"c","requestStartTime":1517912015154}}
{"body": {"column":24,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    for(int i=0;i<doors_size;i++){\n        int max=0,min=0;\n        if(doors+1)\n            if(doors[0]&&doors[0]\n    }\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":276,"fileType":"c","requestStartTime":1517912086513}}
{"body": {"column":22,"line":14,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    for(int i=0;i<doors_size;i++){\n        int max=0,min=0;\n        if(doors+1)\n            if(doors[0]&&doors[0])\n                min++;\n    }\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":354,"fileType":"c","requestStartTime":1517912098905}}
{"body": {"column":23,"line":14,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    for(int i=0;i<doors_size;i++){\n        int max=0,min=0;\n        if(doors+1)\n            if(doors[0]&&doors[1])\n                {min++;max+=2\n                };\n            if((doors[0]&&!doors[1])|\n    }\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":355,"fileType":"c","requestStartTime":1517912184503}}
{"body": {"column":24,"line":16,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    for(int i=0;i<doors_size;i++){\n        int max=0,min=0;\n        if(doors+1)\n            if(doors[0]&&doors[1])\n                {\n                 min++;\n                 max+=2;\n                };\n            if((doors[0]&&!doors[1])|\n    }\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":398,"fileType":"c","requestStartTime":1517912189289}}
{"body": {"column":25,"line":17,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    for(int i=0;i<doors_size;i++){\n        int max=0,min=0;\n        if(doors+1)\n            if(doors[0]&&doors[1])\n                {\n                 min++;\n                 max+=2;\n                doors+=2;\n                };\n            if((doors[0]&&!doors[1])|\n    }\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":424,"fileType":"c","requestStartTime":1517912195289}}
{"body": {"column":24,"line":26,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    for(int i=0;i<doors_size;i++){\n        int max=0,min=0;\n        if(doors+1)\n            if(doors[0]&&doors[1])\n                {\n                 min++;\n                 max+=2;\n                 doors+=2;\n                }\n            if(doors[0]&&!doors[1])\n                {\n                 min++;\n                 max++;\n                 doors+=2;\n                }\n            if(!doors[0])\n                doors++;\n    }\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":641,"fileType":"c","requestStartTime":1517912260301}}
{"body": {"column":44,"line":10,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    int*results=(int*)malloc(2*sizeof(int));\n    for(int i=0;i<doors_size;i++){\n        int max=0,min=0;\n        if(doors+1)\n            if(doors[0]&&doors[1])\n                {\n                 min++;\n                 max+=2;\n                 doors+=2;\n                }\n            if(doors[0]&&!doors[1])\n                {\n                 min++;\n                 max++;\n                 doors+=2;\n                }\n            \n        else\n        {\n            if(doors[0])\n                {\n                 min++;\n                 max++;\n                }\n            r\n        }\n            \n        if(!doors[0])\n                doors++;\n            \n    }\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":261,"fileType":"c","requestStartTime":1517912479142}}
{"body": {"column":20,"line":34,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    int*results=(int*)malloc(2*sizeof(int));\n    for(int i=0;i<doors_size;i++){\n        int max=0,min=0;\n        if(doors+1)\n            if(doors[0]&&doors[1])\n                {\n                 min++;\n                 max+=2;\n                 doors+=2;\n                }\n            if(doors[0]&&!doors[1])\n                {\n                 min++;\n                 max++;\n                 doors+=2;\n                }\n            \n        else\n        {\n            if(doors[0])\n                {\n                 min++;\n                 max++;\n                }\n            doors++;\n        }\n            \n        if(!doors[0])\n                doors++;\n            \n    }\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":801,"fileType":"c","requestStartTime":1517912506726}}
{"body": {"column":18,"line":14,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\nint main() {\n    int n; \n    char a[10000],b[5]='hydro',c[2]='ic'\n    scanf(\"%i\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%s\", a);\n        for(int j.)\n    }\n    return 0;\n}\n\n\n","offset":301,"fileType":"c","requestStartTime":1517912551827}}
{"body": {"column":18,"line":39,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    int*results=(int*)malloc(2*sizeof(int));\n    for(int i=0;i<doors_size&&doors;i++){\n        int max=0,min=0;\n        if(!doors[0])\n                doors++;\n        else if(doors+1)\n        {\n            if(doors[0]&&doors[1])\n                {\n                 min++;\n                 max+=2;\n                 }\n            if(doors[0]&&!doors[1])\n                {\n                 min++;\n                 max++;\n                }\n            doors+=2;\n        }\n        else\n        {\n            if(doors[0])\n                {\n                 min++;\n                 max++;\n                }\n            doors++;\n        }\n    }\n    result[0]=min;\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":871,"fileType":"c","requestStartTime":1517912632994}}
{"body": {"column":19,"line":40,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    int*results=(int*)malloc(2*sizeof(int));\n    for(int i=0;i<doors_size&&doors;i++){\n        int max=0,min=0;\n        if(!doors[0])\n                doors++;\n        else if(doors+1)\n        {\n            if(doors[0]&&doors[1])\n                {\n                 min++;\n                 max+=2;\n                 }\n            if(doors[0]&&!doors[1])\n                {\n                 min++;\n                 max++;\n                }\n            doors+=2;\n        }\n        else\n        {\n            if(doors[0])\n                {\n                 min++;\n                 max++;\n                }\n            doors++;\n        }\n    }\n    results[0]=min;results[1]=max;\n    return results;\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":907,"fileType":"c","requestStartTime":1517912655138}}
{"body": {"column":23,"line":15,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar* acidNaming(char* acid_name) {\n    char *i,*j;\n    int k,l;\n    char t[6]=\"hydro\";\n    char s[3]=\"ic\";\n    i=strstr(acid_name,t);\n    j=strstr(acid_name.)\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    for(int a0 = 0; a0 < n; a0++){\n        char* acid_name = (char *)malloc(512000 * sizeof(char));\n        scanf(\"%s\", acid_name);\n        int result_size;\n        char* result = acidNaming(acid_name);\n        printf(\"%s\\n\", result);\n    }\n    return 0;\n}\n\n\n","offset":299,"fileType":"c","requestStartTime":1517912713231}}
{"body": {"column":12,"line":28,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\nint digisum(int a);\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \nint a,u;\nscanf(\"%d\",&a);\nu=digisum(a);\nprintf(\"%d\",u);\n}\nint digisum(int a)\n{\nint sum=0,s;\nwhile(a>0)\n{\n if(a==0)\n {\n a=sum;\n sum=0;\n }\n s=a%10;\n sum=sum+s;\n a=a/10;\n}\n    while(a.)\nreturn sum;\n    \n}\n\n\n","offset":374,"fileType":"c","requestStartTime":1517912774736}}
{"body": {"column":12,"line":28,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\nint digisum(int a);\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \nint a,u;\nscanf(\"%d\",&a);\nu=digisum(a);\nprintf(\"%d\",u);\n}\nint digisum(int a)\n{\nint sum=0,s;\nwhile(a>0)\n{\n if(a==0)\n {\n a=sum;\n sum=0;\n }\n s=a%10;\n sum=sum+s;\n a=a/10;\n}\n    while(a>)\nreturn sum;\n    \n}\n\n\n","offset":374,"fileType":"c","requestStartTime":1517912778215}}
{"body": {"column":15,"line":18,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n   int number,min=0,temp;\n    scanf(\"%d\",&number);\n    \n    while(number!=0)\n    {\n        temp = number % 10;\n        if(temp>min)\n            min=temp;\n        number = number/10;\n    }\n   printf(\"%d\".)\n    return 0;\n    \n    \n    \n    \n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":297,"fileType":"c","requestStartTime":1517912898053}}
{"body": {"column":16,"line":28,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* revisedRussianRoulette(int doors_size, int* doors, int *result_size) {\n    int*results=(int*)malloc((*result_size=2)*sizeof(int));\n    int max=0,min=0;\n    for(int i=0;i<doors_size;i++){\n        if(!doors[0])\n                doors++;\n        else if(doors+1)\n        {\n            if(doors[0]&&doors[1])\n                {\n                 min++;\n                 max+=2;\n                 }\n            else if(doors[0]&&!doors[1])\n                {\n                 min++;\n                 max++;\n                }\n            doors+=2;\n            i++;\n        }\n        else\n        {\n            if(doors[0])\n                {\n                 min++;\n                 max++;\n                }\n            doors++;\n        }\n    }\n    results[0]=min;results[1]=max;\n    return results;\n    // Complete this function\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *doors = malloc(sizeof(int) * n);\n    for (int doors_i = 0; doors_i < n; doors_i++) {\n       scanf(\"%i\",&doors[doors_i]);\n    }\n    int result_size;\n    int* result = revisedRussianRoulette(n, doors, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":699,"fileType":"c","requestStartTime":1517912962905}}
{"body": {"column":13,"line":12,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n  long  long int n,r,flag=0;\n    scanf(\"%lld\",&n);\n    while(n>0)\n    {\n        r=n%10;\n        if(r>)\n        {\n       \n           flag=1;\n        }\n        n=n/10;\n        break;\n    }\n     if(flag==1)\n         printf(\"No\");\n    else\n        printf(\"Yes\");\n        \n    \n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":194,"fileType":"c","requestStartTime":1517913449019}}
{"body": {"column":10,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* solve(int a0, int a1, int a2, int b0, int b1, int b2, int *result_size){\n    // Complete this function\n    if(a0>)\n}\n\nint main() {\n    int a0; \n    int a1; \n    int a2; \n    scanf(\"%d %d %d\", &a0, &a1, &a2);\n    int b0; \n    int b1; \n    int b2; \n    scanf(\"%d %d %d\", &b0, &b1, &b2);\n    int result_size;\n    int* result = solve(a0, a1, a2, b0, b1, b2, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n    \n\n    return 0;\n}\n\n\n","offset":259,"fileType":"c","requestStartTime":1517913862135}}
{"body": {"column":10,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint main() {\n    int a0; \n    int a1; \n    int a2; \n    scanf(\"%d %d %d\", &a0, &a1, &a2);\n    int b0; \n    int b1; \n    int b2; \n    scanf(\"%d %d %d\", &b0, &b1, &b2);\n    int alice,bob;\n    if(a0>)\n\n\n","offset":338,"fileType":"c","requestStartTime":1517913996305}}
{"body": {"column":20,"line":15,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* breakingRecords(int n, int* score) {\n    int i,high,low,res[2],h=0,l=0,c1=0,c2=0;\n    high=score[0];\n    low=score[0];\n    for(i=1;i<n;i++)\n    {\n        if(score[i]>)\n    }\n\nint main() {\n    \n    int n; \n    scanf(\"%i\", &n);\n    int *score = malloc(sizeof(int) * n);\n    for (int score_i = 0; score_i < n; score_i++) {\n       scanf(\"%i\",&score[score_i]);\n    }\n    int result_size;\n    int* result = breakingRecords(n, score);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n\n\n    return 0;\n}\n\n\n","offset":312,"fileType":"c","requestStartTime":1517894103248}}
{"body": {"column":18,"line":24,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    int n,k,a[30],i;\n     int max = a[0];\n    scanf(\"%d%d\",&n,&k);\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    for (i = 0; i < n; i++)\n    \n        if (a[i] > max)\n            max = a[i];\n    {\n        if(k<a[i])\n            printf(\"%d\",max-k);\n        else if(k>a[i])\n            printf(\"0\");\n    }\n    \n\n\n    \n}\n\n\n","offset":436,"fileType":"c","requestStartTime":1517914208860}}
{"body": {"column":18,"line":29,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    int n,k,a[30],i,m;\n    \n    scanf(\"%d%d\",&n,&k);\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    int max = a[0];\n    for (i = 0; i < n; i++)\n    {\n     \n        if (a[i] > max)\n            max=a[i];\n    }\n    {\n        if(k<max){\n            \n            printf(\"%d\",max-k);\n        }\n        else if(k>max)\n        {\n            printf(\"0\");\n        }\n    }\n    \n\n\n    \n}\n\n\n","offset":476,"fileType":"c","requestStartTime":1517914940878}}
{"body": {"column":12,"line":18,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n\nint main() {\n    int n,a[100],x=0,i,r;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    while(n>\n    r=n%10;\n    if(r==1)\n        x++;\n    n=n/10;\n    \n    printf(\"%d\",x);\n\n    return 0;\n}\n\n\n","offset":274,"fileType":"c","requestStartTime":1517915984425}}
{"body": {"column":15,"line":1,"wordToComplete":"include<stdio.","code":"\n#include<stdio.\n\n","offset":17,"fileType":"c","requestStartTime":1517916181152}}
{"body": {"column":11,"line":7,"wordToComplete":"","code":"\n#include<stdio.h>\nint main()\n{\n    int n,a[50],n,max;\n    for(i=o;i<n;i++)\n    {\nscanf(\"%d\".)\n    }\n}\n\n","offset":94,"fileType":"c","requestStartTime":1517916256476}}
{"body": {"column":7,"line":19,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nimport java.util.Scanner;\npublic class OddNumbers \n{\n    public static void main(String [] args)\n    {\n    Scanner sc = new Scanner(System.in);\n    System.out.print(\"Please enter your first & lower number -->\");\n    int I = sc.nextInt();\n    sc.nextLine();\n    System.out.print(\"Please enter your second & higher number -->\");\n    int K = sc.nextInt();\n    sc.\n    \n   \n    }\n}\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res_size;\n    int* res;\n    int _l;\n    scanf(\"%d\", &_l);\n    \n    int _r;\n    scanf(\"%d\", &_r);\n    \n    res = oddNumbers(_l, _r, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":500,"fileType":"c","requestStartTime":1517916402725}}
{"body": {"column":41,"line":15,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    int n,i,sum=0;\n    scanf(\"%d\",&n);\n    int arr[n];\n    for(int arr_i = 0; arr_i < n; arr_i++){\n       scanf(\"%d\",&arr[arr_i]);\n       if arr[arr_i] > 10000000000 break.   \n    }          \n    for(int arr_i = 0; arr_i < n; arr_i++){\n        sum=arr[arr_i]+sum;\n    }\n    printf(\"%d\\n\",sum);\n    return 0;\n}\n\n\n","offset":325,"fileType":"c","requestStartTime":1517917891626}}
{"body": {"column":10,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    \n    int i. ;\n    \n    for (i = 0 ; i < n ; i++){\n        \n    }\n    \n    return 0;\n}\n\n\n","offset":168,"fileType":"c","requestStartTime":1517918134543}}
{"body": {"column":23,"line":18,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    \n    int i,n;\n    scanf(\"%d\",&n);\n    \n    int vet[n];\n    \n    for (i = 0 ; i < n ; i++) scanf(\"%d \",vet[i]);\n    for (i = 0 ; i < n ; i++) sum += vet[i];\n    printf(\"%d\\n\",sum).\n    \n    return 0;\n}\n\n\n","offset":336,"fileType":"c","requestStartTime":1517918252447}}
{"body": {"column":15,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\nvoid main()\n{\n    int i;\n    char s[20].\n}\n\n\n","offset":180,"fileType":"c","requestStartTime":1517898676219}}
{"body": {"column":21,"line":11,"wordToComplete":"Enter no.\"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\nvoid main()\n{\n    int i;\n    printf(\"Enter no.\")\n    \n}\n\n\n","offset":186,"fileType":"c","requestStartTime":1517898776428}}
{"body": {"column":16,"line":16,"wordToComplete":"","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\nstruct node {\n    struct node *left,*right;\n    int val, val1;\n};\ntypedef struct node node;\nnode * addElement(node * root, int x);\n/* Any extra functions you would like to add, code here */\n\nint isPresent(node* root, int val){\n   \n    if(root !=null){\n        \n        if(root.)\n    }\n    \n}\nint main(){\n    node * root = NULL;\n    int a[100005],K,i = 0,j = 0, _element, present;\n    \n    scanf(\"%d\",&K);\n    for( j = 0; j < K;j++ ) {\n        scanf(\"%d\",&a[i++]);    \n    }\n\n    for( i = 0; i < K;i++ ){\n        root = addElement(root,a[i]);\n    }\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d\",&_element);\n        present = isPresent(root, _element);\n        printf(\"%d\\n\", present);\n    }\n    \n    return 0;\n}\n\nnode * addElement(node * root, int x ){\n    if( root == NULL ) {\n        root = (node *) (malloc(sizeof(node))); \n        root->val = x;root->val1 = -1;\n                            root->left = NULL; root->right = NULL;\n        return root;\n    }\n    if( x < root->val ) {\n         root->left = addElement(root->left,x);\n    }\n    else {\n        root->right = addElement(root->right,x);                            \n    }\n    return root;\n}\n","offset":383,"fileType":"c","requestStartTime":1517920052149}}
{"body": {"column":34,"line":19,"wordToComplete":"","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\nstruct node {\n    struct node *left,*right;\n    int val, val1;\n};\ntypedef struct node node;\nnode * addElement(node * root, int x);\n/* Any extra functions you would like to add, code here */\n\nint isPresent(node* root, int val){\n   \n    if(root !=null){\n        \n        if(root.data == val){\n            return true;\n        } else {\n            return isPresent(root.)\n        }\n    }\n    \n}\nint main(){\n    node * root = NULL;\n    int a[100005],K,i = 0,j = 0, _element, present;\n    \n    scanf(\"%d\",&K);\n    for( j = 0; j < K;j++ ) {\n        scanf(\"%d\",&a[i++]);    \n    }\n\n    for( i = 0; i < K;i++ ){\n        root = addElement(root,a[i]);\n    }\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d\",&_element);\n        present = isPresent(root, _element);\n        printf(\"%d\\n\", present);\n    }\n    \n    return 0;\n}\n\nnode * addElement(node * root, int x ){\n    if( root == NULL ) {\n        root = (node *) (malloc(sizeof(node))); \n        root->val = x;root->val1 = -1;\n                            root->left = NULL; root->right = NULL;\n        return root;\n    }\n    if( x < root->val ) {\n         root->left = addElement(root->left,x);\n    }\n    else {\n        root->right = addElement(root->right,x);                            \n    }\n    return root;\n}\n","offset":473,"fileType":"c","requestStartTime":1517920104060}}
{"body": {"column":58,"line":19,"wordToComplete":"","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\nstruct node {\n    struct node *left,*right;\n    int val, val1;\n};\ntypedef struct node node;\nnode * addElement(node * root, int x);\n/* Any extra functions you would like to add, code here */\n\nint isPresent(node* root, int val){\n   \n    if(root !=null){\n        \n        if(root.data == val){\n            return true;\n        } else {\n            return isPresent(root.left,x)||isPresent(root.)\n        }\n    }\n    \n}\nint main(){\n    node * root = NULL;\n    int a[100005],K,i = 0,j = 0, _element, present;\n    \n    scanf(\"%d\",&K);\n    for( j = 0; j < K;j++ ) {\n        scanf(\"%d\",&a[i++]);    \n    }\n\n    for( i = 0; i < K;i++ ){\n        root = addElement(root,a[i]);\n    }\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d\",&_element);\n        present = isPresent(root, _element);\n        printf(\"%d\\n\", present);\n    }\n    \n    return 0;\n}\n\nnode * addElement(node * root, int x ){\n    if( root == NULL ) {\n        root = (node *) (malloc(sizeof(node))); \n        root->val = x;root->val1 = -1;\n                            root->left = NULL; root->right = NULL;\n        return root;\n    }\n    if( x < root->val ) {\n         root->left = addElement(root->left,x);\n    }\n    else {\n        root->right = addElement(root->right,x);                            \n    }\n    return root;\n}\n","offset":497,"fileType":"c","requestStartTime":1517920127646}}
{"body": {"column":17,"line":16,"wordToComplete":"","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\nstruct node {\n    struct node *left,*right;\n    int val, val1;\n};\ntypedef struct node node;\nnode * addElement(node * root, int x);\n/* Any extra functions you would like to add, code here */\n\nint isPresent(node* root, int val){\n   \n    if(root !=null){\n        \n        if(root-> == val){\n            return true;\n        } else {\n            return isPresent(root.left,x)||isPresent(root.right,x);\n        }\n    }\n    return false;\n    \n}\nint main(){\n    node * root = NULL;\n    int a[100005],K,i = 0,j = 0, _element, present;\n    \n    scanf(\"%d\",&K);\n    for( j = 0; j < K;j++ ) {\n        scanf(\"%d\",&a[i++]);    \n    }\n\n    for( i = 0; i < K;i++ ){\n        root = addElement(root,a[i]);\n    }\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d\",&_element);\n        present = isPresent(root, _element);\n        printf(\"%d\\n\", present);\n    }\n    \n    return 0;\n}\n\nnode * addElement(node * root, int x ){\n    if( root == NULL ) {\n        root = (node *) (malloc(sizeof(node))); \n        root->val = x;root->val1 = -1;\n                            root->left = NULL; root->right = NULL;\n        return root;\n    }\n    if( x < root->val ) {\n         root->left = addElement(root->left,x);\n    }\n    else {\n        root->right = addElement(root->right,x);                            \n    }\n    return root;\n}\n","offset":384,"fileType":"c","requestStartTime":1517920217499}}
{"body": {"column":35,"line":19,"wordToComplete":"","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\nstruct node {\n    struct node *left,*right;\n    int val, val1;\n};\ntypedef struct node node;\nnode * addElement(node * root, int x);\n/* Any extra functions you would like to add, code here */\n\nint isPresent(node* root, int val){\n   \n    if(root !=null){\n        \n        if(root->val == val){\n            return true;\n        } else {\n            return isPresent(root->,x)||isPresent(root.right,x);\n        }\n    }\n    return false;\n    \n}\nint main(){\n    node * root = NULL;\n    int a[100005],K,i = 0,j = 0, _element, present;\n    \n    scanf(\"%d\",&K);\n    for( j = 0; j < K;j++ ) {\n        scanf(\"%d\",&a[i++]);    \n    }\n\n    for( i = 0; i < K;i++ ){\n        root = addElement(root,a[i]);\n    }\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d\",&_element);\n        present = isPresent(root, _element);\n        printf(\"%d\\n\", present);\n    }\n    \n    return 0;\n}\n\nnode * addElement(node * root, int x ){\n    if( root == NULL ) {\n        root = (node *) (malloc(sizeof(node))); \n        root->val = x;root->val1 = -1;\n                            root->left = NULL; root->right = NULL;\n        return root;\n    }\n    if( x < root->val ) {\n         root->left = addElement(root->left,x);\n    }\n    else {\n        root->right = addElement(root->right,x);                            \n    }\n    return root;\n}\n","offset":474,"fileType":"c","requestStartTime":1517920229951}}
{"body": {"column":60,"line":19,"wordToComplete":"","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\nstruct node {\n    struct node *left,*right;\n    int val, val1;\n};\ntypedef struct node node;\nnode * addElement(node * root, int x);\n/* Any extra functions you would like to add, code here */\n\nint isPresent(node* root, int val){\n   \n    if(root !=null){\n        \n        if(root->val == val){\n            return true;\n        } else {\n            return isPresent(root->left,x)||isPresent(root->,x);\n        }\n    }\n    return false;\n    \n}\nint main(){\n    node * root = NULL;\n    int a[100005],K,i = 0,j = 0, _element, present;\n    \n    scanf(\"%d\",&K);\n    for( j = 0; j < K;j++ ) {\n        scanf(\"%d\",&a[i++]);    \n    }\n\n    for( i = 0; i < K;i++ ){\n        root = addElement(root,a[i]);\n    }\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d\",&_element);\n        present = isPresent(root, _element);\n        printf(\"%d\\n\", present);\n    }\n    \n    return 0;\n}\n\nnode * addElement(node * root, int x ){\n    if( root == NULL ) {\n        root = (node *) (malloc(sizeof(node))); \n        root->val = x;root->val1 = -1;\n                            root->left = NULL; root->right = NULL;\n        return root;\n    }\n    if( x < root->val ) {\n         root->left = addElement(root->left,x);\n    }\n    else {\n        root->right = addElement(root->right,x);                            \n    }\n    return root;\n}\n","offset":499,"fileType":"c","requestStartTime":1517920240333}}
{"body": {"column":20,"line":12,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    // Complete this function\n    for (int i =0 ; i < arr_size; i++)\n        if (arr[i] >)\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":271,"fileType":"c","requestStartTime":1517920465250}}
{"body": {"column":12,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    // Complete this function\n    int pos.\n    for (int i =0 ; i < arr_size; i++)\n        if (arr[i] > 0 ){\n          pos++;   \n        }\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":224,"fileType":"c","requestStartTime":1517920507696}}
{"body": {"column":14,"line":16,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    // Complete this function\n    int pos=0,neg=0,zero=0;\n    for (int i =0 ; i < arr_size; i++)\n        if (arr[i] > 0 )  pos++; \n        else if (arr[i] == 0) zero++;\n            else neg++;\n    printf(\"\".(float)pos/n)\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":389,"fileType":"c","requestStartTime":1517920606344}}
{"body": {"column":15,"line":16,"wordToComplete":"6.\"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    // Complete this function\n    int pos=0,neg=0,zero=0;\n    for (int i =0 ; i < arr_size; i++)\n        if (arr[i] > 0 )  pos++; \n        else if (arr[i] == 0) zero++;\n            else neg++;\n    printf(\"%6.\",(float)pos/n)\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":390,"fileType":"c","requestStartTime":1517920610952}}
{"body": {"column":17,"line":1,"wordToComplete":"include<stdio.h>","code":"\n#include<stdio.h>\n\n","offset":19,"fileType":"c","requestStartTime":1517920721414}}
{"body": {"column":15,"line":20,"wordToComplete":"6.\"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    // Complete this function\n    float pos=0,neg=0,zero=0;\n    for (int i =0 ; i < arr_size; i++)\n        if (arr[i] > 0 )  pos++; \n        else if (arr[i] == 0) zero++;\n            else neg++;\n    pos = (pos/arr_size);\n    neg = (neg/arr_size);\n    zero = (zero/arr_size);\n    \n    printf(\"%6.\");\n    \n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":477,"fileType":"c","requestStartTime":1517920835057}}
{"body": {"column":14,"line":21,"wordToComplete":"6f\\n\"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    // Complete this function\n    float pos=0,neg=0,zero=0;\n    for (int i =0 ; i < arr_size; i++)\n        if (arr[i] > 0 )  pos++; \n        else if (arr[i] == 0) zero++;\n            else neg++;\n    pos = (pos/arr_size);\n    neg = (neg/arr_size);\n    zero = (zero/arr_size);\n    \n    printf(\"%.6f\\n\",pos);\n    printf(\"%.6f\\n\",neg);\n    printf(\"%6.f\\n\",zero);\n    \n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":502,"fileType":"c","requestStartTime":1517920893594}}
{"body": {"column":14,"line":22,"wordToComplete":"6f\\n\"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    // Complete this function\n    float pos=0,neg=0,zero=0;\n    for (int i =0 ; i < arr_size; i++)\n        if (arr[i] > 0 )  pos++; \n        else if (arr[i] == 0) zero++;\n            else neg++;\n    pos = (pos/arr_size);\n    neg = (neg/arr_size);\n    zero = (zero/arr_size);\n    \n    printf(\"%.6f\\n\",pos);\n    printf(\"%.6f\\n\",neg);\n    printf(\"%.6f\\n\",zero);\n    \n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":528,"fileType":"c","requestStartTime":1517920896906}}
{"body": {"column":20,"line":13,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid staircase(int n) {\n    // Complete this function\n    int i,j;\n    for ( i = 0 ; i < n ; i++ )\n        for (j = 0 .)\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    staircase(n);\n    return 0;\n}\n\n\n","offset":260,"fileType":"c","requestStartTime":1517921042840}}
{"body": {"column":17,"line":34,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\nint exclude = 0;\nlong int maximumPeopleX(int p_size, long int* p, int x_size, long int* x, int y_size, long int* y, int r_size, long int* r) {\n    long int cnt = 0;\n    for (int ti = 0; ti < x_size; ++ti) {\n        bool sunny = true;\n        long int townPos = x[ti];\n        \n        for (int c = 0 ; c < y_size; ++c) \n         if (c != exclude) {\n            long int cloudPos = y[c];\n            if (townPos >= (cloudPos - r[c]) && townPos <= (cloudPos + r[c])) {\n                sunny = false;\n                break;\n            }\n         }\n        if (sunny)\n            cnt += p[ti];\n    }\n    return cnt;\n}\n\nlong int maximumPeople(int p_size, long int* p, int x_size, long int* x, int y_size, long int* y, int r_size, long int* r) {\n    long int maxP = -1;\n \n    for (exclude = 0; exclude < r_size; ++exclude) {\n        long int ppl = maximumPeople(p_size, p, x_size, x, y_size, y, r_size, r);\n        if (ppl >)\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    long int *p = malloc(sizeof(long int) * n);\n    for (int p_i = 0; p_i < n; p_i++) {\n       scanf(\"%li\",&p[p_i]);\n    }\n    long int *x = malloc(sizeof(long int) * n);\n    for (int x_i = 0; x_i < n; x_i++) {\n       scanf(\"%li\",&x[x_i]);\n    }\n    int m; \n    scanf(\"%i\", &m);\n    long int *y = malloc(sizeof(long int) * m);\n    for (int y_i = 0; y_i < m; y_i++) {\n       scanf(\"%li\",&y[y_i]);\n    }\n    long int *r = malloc(sizeof(long int) * m);\n    for (int r_i = 0; r_i < m; r_i++) {\n       scanf(\"%li\",&r[r_i]);\n    }\n    long int result = maximumPeople(n, p, n, x, m, y, m, r);\n    printf(\"%ld\\n\", result);\n    return 0;\n}\n\n\n","offset":1059,"fileType":"c","requestStartTime":1517921446965}}
{"body": {"column":34,"line":15,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid staircase(int n) {\n    // Complete this function\n    int i,j,m;\n    m = n;\n    for ( i = 0 ; i < n ; i++ ){\n        printf(\" \");\n        if (i == m-1) for (j = 0 .)\n    }\n        \n    \n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    staircase(n);\n    return 0;\n}\n\n\n","offset":309,"fileType":"c","requestStartTime":1517921606913}}
{"body": {"column":19,"line":13,"wordToComplete":"0.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid staircase(int n) {\n    // Complete this function\n    int i,j,m;\n    for ( i = 0 ; i < n-1 ; i++ ){\n        for (j = 0.)\n        \n        printf(\"\\n\");\n    }\n} \n    \n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    staircase(n);\n    return 0;\n}\n\n\n","offset":264,"fileType":"c","requestStartTime":1517921755110}}
{"body": {"column":23,"line":14,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid staircase(int n) {\n    // Complete this function\n    int i,j,m;\n    m = n-1;\n    for ( i = 0 ; i < n-1 ; i++ ){\n        for (j = n; j > m ; j)\n        \n        printf(\"\\n\");\n    }\n} \n    \n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    staircase(n);\n    return 0;\n}\n\n\n","offset":281,"fileType":"c","requestStartTime":1517921780697}}
{"body": {"column":21,"line":15,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid staircase(int n) {\n    // Complete this function\n    int i,j,m;\n    m = n-1;\n    for ( i = 0 ; i < n ; i++ ){\n        for (j = n; j > m ; j--){\n            printf(\".\");        \n        }\n        printf(\"\")\n        printf(\"\\n\");\n    }\n} \n    \n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    staircase(n);\n    return 0;\n}\n\n\n","offset":311,"fileType":"c","requestStartTime":1517921892090}}
{"body": {"column":18,"line":13,"wordToComplete":"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    // Declare a variable named 'input_string' to hold our input.\n    char input_string[105]; \n    \n    // Read a full line of input from stdin and save it to our variable, input_string.\n    scanf(\"%[^\\n]\", input_string); \n    \n    // Print a string literal saying \"Hello, World.\" to stdout using printf.\n    printf(\"%s\\n\",);\n    \n    // TODO: Write a line of code here that prints the contents of input_string to stdout.\n    \n    return 0;\n}\n\n","offset":415,"fileType":"c","requestStartTime":1517921989120}}
{"body": {"column":20,"line":13,"wordToComplete":"in","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    // Declare a variable named 'input_string' to hold our input.\n    char input_string[105]; \n    \n    // Read a full line of input from stdin and save it to our variable, input_string.\n    scanf(\"%[^\\n]\", input_string); \n    \n    // Print a string literal saying \"Hello, World.\" to stdout using printf.\n    printf(\"%s\\n\",in);\n    \n    // TODO: Write a line of code here that prints the contents of input_string to stdout.\n    \n    return 0;\n}\n\n","offset":417,"fileType":"c","requestStartTime":1517921991250}}
{"body": {"column":17,"line":17,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid staircase(int n) {\n    // Complete this function\n    int i,j,m;\n    m = n-1;\n    for ( i = 0 ; i < n ; i++ ){\n        for (j = 0; j > m ; j++){\n            printf(\" \");\n        }\n        printf(\".\");\n        m-- ;\n        printf(\"\\n\");\n    }\n} \n    \n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    staircase(n);\n    return 0;\n}\n\n\n","offset":342,"fileType":"c","requestStartTime":1517921990431}}
{"body": {"column":36,"line":13,"wordToComplete":"inp","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    // Declare a variable named 'input_string' to hold our input.\n    char input_string[105]; \n    \n    // Read a full line of input from stdin and save it to our variable, input_string.\n    scanf(\"%[^\\n]\", input_string); \n    \n    // Print a string literal saying \"Hello, World.\" to stdout using printf.\n    printf(\"Hello, World.\\n%s\\n\",inp);\n    \n    // TODO: Write a line of code here that prints the contents of input_string to stdout.\n    \n    return 0;\n}\n\n","offset":433,"fileType":"c","requestStartTime":1517922022751}}
{"body": {"column":28,"line":17,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid staircase(int n) {\n    // Complete this function\n    int i,j,m;\n    m = n-1;\n    for ( i = 0 ; i < n ; i++ ){\n        for (j = 0; j > m ; j++){\n            printf(\" \");\n        }\n        for (k = m ; k < n .)\n        \n        m-- ;\n        printf(\"\\n\");\n    }\n} \n    \n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    staircase(n);\n    return 0;\n}\n\n\n","offset":353,"fileType":"c","requestStartTime":1517922062310}}
{"body": {"column":45,"line":14,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid staircase(int n) {\n    // Complete this function\n    int i,j,m,k;\n    m = n-1;\n    for ( i = 0 ; i < n ; i++ ){\n        for (j = 0; j > m ; j++)    printf(\".\");\n        for (k = m ; k < n ; k++)   printf(\"#\");\n        m-- ;\n        printf(\"\\n\");\n    }\n} \n    \n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    staircase(n);\n    return 0;\n}\n\n\n","offset":303,"fileType":"c","requestStartTime":1517922121942}}
{"body": {"column":12,"line":7,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int N,P;\n    scanf(\"%d\",)\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":105,"fileType":"c","requestStartTime":1517922134365}}
{"body": {"column":18,"line":8,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int N,P;\n    scanf(\"%d\",N);\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":124,"fileType":"c","requestStartTime":1517922185049}}
{"body": {"column":18,"line":9,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int N,P;\n    scanf(\"%d\",N);\n    scanf(\"%d\",P);\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":143,"fileType":"c","requestStartTime":1517922193456}}
{"body": {"column":32,"line":10,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int N,P;\n    scanf(\"%d\",N);\n    scanf(\"%d\",P);\n    int r = (pow(10,9)+7) % N+P;\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":176,"fileType":"c","requestStartTime":1517922450769}}
{"body": {"column":21,"line":11,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int N,P;\n    scanf(\"%d\",N);\n    scanf(\"%d\",P);\n    int r = (pow(10,9)+7) % N+P;N\n    printf(\"%d\\n\",r);\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":199,"fileType":"c","requestStartTime":1517922467810}}
{"body": {"column":30,"line":13,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i;\n    long min,max;\n    for (i = 0 ; i < arr_size.)\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":272,"fileType":"c","requestStartTime":1517922835768}}
{"body": {"column":49,"line":13,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i;\n    long min,max;\n    for (i = 0 ; i < arr_size ; i++) if (arr[i] >)\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":291,"fileType":"c","requestStartTime":1517922850191}}
{"body": {"column":65,"line":13,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i;\n    long min,max;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && arr[i] >)\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":307,"fileType":"c","requestStartTime":1517922865905}}
{"body": {"column":11,"line":17,"wordToComplete":"10.","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int i = 4;\n    double d = 4.0;\n    char s[] = \"HackerRank \";\n    \n    // Declare second integer, double, and String variables.\n    int i;\n    int d;\n    int s;\n    \n    // Read and save an integer, double, and String to your variables.\n    i = 5;\n    d = 10.\n    \n    // Print the sum of both integer variables on a new line.\n    \n    // Print the sum of the double variables on a new line.\n    \n    // Concatenate and print the String variables on a new line\n    // The 's' variable above should be printed first.\n    \n\n\n    return 0;\n}\n","offset":354,"fileType":"c","requestStartTime":1517922950182}}
{"body": {"column":27,"line":15,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min ,max1;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] > 1000000000)) ok = 1 ; else ok = 0;\n    if ( ok = 1 ){\n       for (i=0;i<arr_size.)\n       \n    }\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":395,"fileType":"c","requestStartTime":1517923041706}}
{"body": {"column":22,"line":32,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int a[n],i;\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&a[i]);\n    int k=0;\n    for(i=0;i<n-1;i++)\n    {\n        if(a[i]==1&&a[i+1]==1)\n        {\n            k++;\n            a[i+1]=0;\n        }\n        else if(a[i]==1)\n        {\n            k++;\n        }\n    }\n    if(a[n]==1)\n        printf(\"%d\",k+1);\n    else\n        printf(\"%d\\n\".)\n    \n}\n\n","offset":522,"fileType":"c","requestStartTime":1517923238172}}
{"body": {"column":20,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min ,max1,max2,max3,max4,max5;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] > 1000000000)) ok = 1 ; else ok = 0;\n    if ( ok = 1 ){\n          max1 = arr[1]+arr[2]+arr[3]+arr[4];\n          max2 = arr[2]+arr[3]+arr[4]+arr[5];\n          max3 = arr[3]+arr[4]+arr[5]+arr[1];\n          max4 = arr[4]+arr[5]+arr[1]+arr[2];\n          max5 = arr[5]+arr[1]+arr[2]+arr[3];\n          if (max1 >)\n       \n    }\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":638,"fileType":"c","requestStartTime":1517923208223}}
{"body": {"column":20,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min ,max1,max2,max3,max4,max5;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] > 1000000000)) ok = 1 ; else ok = 0;\n    if ( ok = 1 ){\n          max1 = arr[1]+arr[2]+arr[3]+arr[4];\n          max2 = arr[2]+arr[3]+arr[4]+arr[5];\n          max3 = arr[3]+arr[4]+arr[5]+arr[1];\n          max4 = arr[4]+arr[5]+arr[1]+arr[2];\n          max5 = arr[5]+arr[1]+arr[2]+arr[3];\n          if (max1 >)\n       \n    }\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":638,"fileType":"c","requestStartTime":1517923209871}}
{"body": {"column":26,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min ,max1,max2,max3,max4,max5;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] > 1000000000)) ok = 1 ; else ok = 0;\n    if ( ok = 1 ){\n          max1 = arr[1]+arr[2]+arr[3]+arr[4];\n          max2 = arr[2]+arr[3]+arr[4]+arr[5];\n          max3 = arr[3]+arr[4]+arr[5]+arr[1];\n          max4 = arr[4]+arr[5]+arr[1]+arr[2];\n          max5 = arr[5]+arr[1]+arr[2]+arr[3];\n          if (max1 > max2.)\n       \n    }\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":644,"fileType":"c","requestStartTime":1517923212367}}
{"body": {"column":53,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min ,max1,max2,max3,max4,max5;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] > 1000000000)) ok = 1 ; else ok = 0;\n    if ( ok = 1 ){\n          max1 = arr[1]+arr[2]+arr[3]+arr[4];\n          max2 = arr[2]+arr[3]+arr[4]+arr[5];\n          max3 = arr[3]+arr[4]+arr[5]+arr[1];\n          max4 = arr[4]+arr[5]+arr[1]+arr[2];\n          max5 = arr[5]+arr[1]+arr[2]+arr[3];\n          if (max1 > max2) if (max1 > max3) if (max1.)\n       \n    }\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":671,"fileType":"c","requestStartTime":1517923244816}}
{"body": {"column":54,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min ,max1,max2,max3,max4,max5;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] > 1000000000)) ok = 1 ; else ok = 0;\n    if ( ok = 1 ){\n          max1 = arr[1]+arr[2]+arr[3]+arr[4];\n          max2 = arr[2]+arr[3]+arr[4]+arr[5];\n          max3 = arr[3]+arr[4]+arr[5]+arr[1];\n          max4 = arr[4]+arr[5]+arr[1]+arr[2];\n          max5 = arr[5]+arr[1]+arr[2]+arr[3];\n          if (max1 > max2) if (max1 > max3) if (max1 >)\n       \n    }\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":672,"fileType":"c","requestStartTime":1517923245848}}
{"body": {"column":106,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min ,max1,max2,max3,max4,max5;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] > 1000000000)) ok = 1 ; else ok = 0;\n    if ( ok = 1 ){\n          max1 = arr[1]+arr[2]+arr[3]+arr[4];\n          max2 = arr[2]+arr[3]+arr[4]+arr[5];\n          max3 = arr[3]+arr[4]+arr[5]+arr[1];\n          max4 = arr[4]+arr[5]+arr[1]+arr[2];\n          max5 = arr[5]+arr[1]+arr[2]+arr[3];\n          if (max1 > max2) if (max1 > max3) if (max1 > max4) if (max1 > max5) max = max1; else max = max5.\n       \n    }\n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":724,"fileType":"c","requestStartTime":1517923275017}}
{"body": {"column":20,"line":16,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min ,max,max_t=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] > 1000000000)) ok = 1 ; else ok = 0;\n    while (j < 5){\n        for (i = 0 ; i < arr_size ; i++) max += arr[m%5]; \n        if (max_t > )\n        \n    }\n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":454,"fileType":"c","requestStartTime":1517923564248}}
{"body": {"column":25,"line":23,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min ,max,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] > 1000000000)) ok = 1 ; else ok = 0;\n    while (j < 5){\n        for (i = 0 ; i < arr_size ; i++) max += arr[m%5]; \n        if (max_t > max){ \n            if (max < min) min = max;\n        }\n        else\n            max_t = max;\n        m++;j++;\n    }\n    printf(\"%ld %ld\",min.)\n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":603,"fileType":"c","requestStartTime":1517923722112}}
{"body": {"column":10,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i.\n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":223,"fileType":"c","requestStartTime":1517924082314}}
{"body": {"column":40,"line":15,"wordToComplete":"The sum of i and d is %d,%f. \"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int i = 4;\n    double d = 4.0;\n    char s[] = \"HackerRank \";\n    \n    // Declare second integer, double, and String variables.\n    \n    \n    \n    // Read and save an integer, double, and String to your variables.\n    printf(\"The sum of i and d is %d,%f. \", i);\n    \n    \n    \n    // Print the sum of both integer variables on a new line.\n    \n    // Print the sum of the double variables on a new line.\n    \n    // Concatenate and print the String variables on a new line\n    // The 's' variable above should be printed first.\n    \n\n\n    return 0;\n}\n","offset":349,"fileType":"c","requestStartTime":1517924421112}}
{"body": {"column":39,"line":15,"wordToComplete":"The sum of i and d is %d,%.f \"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int i = 4;\n    double d = 4.0;\n    char s[] = \"HackerRank \";\n    \n    // Declare second integer, double, and String variables.\n    \n    \n    \n    // Read and save an integer, double, and String to your variables.\n    printf(\"The sum of i and d is %d,%.f \", i);\n    \n    \n    \n    // Print the sum of both integer variables on a new line.\n    \n    // Print the sum of the double variables on a new line.\n    \n    // Concatenate and print the String variables on a new line\n    // The 's' variable above should be printed first.\n    \n\n\n    return 0;\n}\n","offset":348,"fileType":"c","requestStartTime":1517924455941}}
{"body": {"column":40,"line":15,"wordToComplete":"The sum of i and d is %d, %.f \"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int i = 4;\n    double d = 4.0;\n    char s[] = \"HackerRank \";\n    \n    // Declare second integer, double, and String variables.\n    \n    \n    \n    // Read and save an integer, double, and String to your variables.\n    printf(\"The sum of i and d is %d, %.f \", i, f);\n    \n    \n    \n    // Print the sum of both integer variables on a new line.\n    \n    // Print the sum of the double variables on a new line.\n    \n    // Concatenate and print the String variables on a new line\n    // The 's' variable above should be printed first.\n    \n\n\n    return 0;\n}\n","offset":349,"fileType":"c","requestStartTime":1517924536675}}
{"body": {"column":24,"line":17,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min=0 ,max=0,max_t,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        while(j<5){\n            for (i = 0 ; i < arr_size-1 ; i++){ max += arr[m%5]; m++; } \n                if (max>){\n                    max_t = max;\n                    printf(\"entro\\n\");\n                }\n                else \n                    if (max < min){ min = max;\n                                  printf(\"ko\\n\");}\n                                   max = 0;\n            j++;\n        }\n    }    \n    printf(\"%ld %ld\",min,max_t);\n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":501,"fileType":"c","requestStartTime":1517924948167}}
{"body": {"column":26,"line":17,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min=0 ,max=0,max_t,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        while(j<5){\n            for (i = 0 ; i < arr_size-1 ; i++){ max += arr[m%5]; m++; } \n                if (max > ){\n                    max_t = max;\n                    printf(\"entro\\n\");\n                }\n                else \n                    if (max < min){ min = max;\n                                  printf(\"ko\\n\");}\n                                   max = 0;\n            j++;\n        }\n    }    \n    printf(\"%ld %ld\",min,max_t);\n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":503,"fileType":"c","requestStartTime":1517924949559}}
{"body": {"column":13,"line":12,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min.max=0,max_t,m=0,j=0,e=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        while(j<5){\n            for (i = 0 ; i < arr_size-1 ; i++){ max += arr[m%5]; m++; } \n                if (max > max_t){    max_t = max; if (e == 0){ min = max; e++; }}\n                else    if (min > max ) min = max;\n            max = 0;\n            j++;\n        }\n    }    \n    printf(\"%ld %ld\",min,max_t);\n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":240,"fileType":"c","requestStartTime":1517925185471}}
{"body": {"column":18,"line":22,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint digitSum(char* n, int k) {\n  char* P = (char *)malloc(512000 * sizeof(char));\n  for(int i=0;i<k;i++){\n    P = strcat(P,n);\n  }\n  char* rs = (char *)malloc(512000 * sizeof(char));\n  strcpy(rs,P);\n  int len = 0;\n  while(len != 1){\n    int r = 0;\n    for(int i=0;i<strlen(rs);i++){\n      r += rs[i] - '0';\n    }\n    rs = (char*)r;\n    len = strlen(rs);\n  }\n  return rs[0] - '0';\n}\n\nint main() {\n    char* n = (char *)malloc(512000 * sizeof(char));\n    int k; \n    scanf(\"%s %i\", n, &k);\n    int result = digitSum(n, k);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n","offset":472,"fileType":"c","requestStartTime":1517925785864}}
{"body": {"column":19,"line":22,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint digitSum(char* n, int k) {\n  char* P = (char *)malloc(512000 * sizeof(char));\n  for(int i=0;i<k;i++){\n    P = strcat(P,n);\n  }\n  char* rs = (char *)malloc(512000 * sizeof(char));\n  strcpy(rs,P);\n  int len = 0;\n  while(len != 1){\n    int r = 0;\n    for(int i=0;i<strlen(rs);i++){\n      r += rs[i] - '0';\n    }\n    rs = (char *)r;\n    len = strlen(rs);\n  }\n  return rs[0] - '0';\n}\n\nint main() {\n    char* n = (char *)malloc(512000 * sizeof(char));\n    int k; \n    scanf(\"%s %i\", n, &k);\n    int result = digitSum(n, k);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n","offset":473,"fileType":"c","requestStartTime":1517925797985}}
{"body": {"column":98,"line":16,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max=0,max_t,m=0,j=0,e=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        while(j<5){\n            for (i = 0 ; i < arr_size-1 ; i++){ max += arr[(m%5)]; m++; printf(\"m mod 5 = %ld \\n\".) } \n                if (max_t < max)    max_t = max; \n                else    if (max < min ) min = max;\n            max = 0;\n            j++;\n        }\n    }    \n    printf(\"%ld %ld\",min,max_t);\n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":503,"fileType":"c","requestStartTime":1517925818057}}
{"body": {"column":28,"line":13,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint countHoles(int num) {\n    string number = Convert.Tostring(num);\nint holes =0;\n    for(int i=0;i<num.sis;i++)\n    {\n        if(i[0] = 4 || i[0] = 6 || i[0] = 0 || i[0] = 9)\n        //if(i[0] = 1 || i[0] = 2 || i[0] = 3 || i[0] = 5 || i[0] = 7)\n        {\n            holes = holes+1;\n        }\n        else if(i[0] = 8)\n        {\n            holes = holes +2;\n        }\n        else\n            holes = holes+0;\n                \n    }\n    return holes;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int num;\n    scanf(\"%d\", &num);\n\n    res = countHoles(num);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":234,"fileType":"c","requestStartTime":1517926775771}}
{"body": {"column":24,"line":13,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint countHoles(int num) {\n    string number = num.\nint holes =0;\n    for(int i=0;i<num.sis;i++)\n    {\n        if(i[0] = 4 || i[0] = 6 || i[0] = 0 || i[0] = 9)\n        //if(i[0] = 1 || i[0] = 2 || i[0] = 3 || i[0] = 5 || i[0] = 7)\n        {\n            holes = holes+1;\n        }\n        else if(i[0] = 8)\n        {\n            holes = holes +2;\n        }\n        else\n            holes = holes+0;\n                \n    }\n    return holes;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int num;\n    scanf(\"%d\", &num);\n\n    res = countHoles(num);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":230,"fileType":"c","requestStartTime":1517926787364}}
{"body": {"column":115,"line":16,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max,max_t,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        while(j<5){\n            for (i = 0 ; i < arr_size-1 ; i++){ printf(\"SOMANDO = %ld(max) + %ld(arr(m mod 5)) = %ld (maxfinal)\\n\".)max += arr[(m%5)]; m++; } \n                if (max_t < max)    {max_t = max; max = 0;}\n                else    if (max < min ) {min = max; max= 0;}\n                else max =0;\n            j++;\n        }\n    }    \n    printf(\"%ld %ld\",min,max_t);\n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":514,"fileType":"c","requestStartTime":1517927047350}}
{"body": {"column":115,"line":16,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max,max_t,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        while(j<5){\n            for (i = 0 ; i < arr_size-1 ; i++){ printf(\"SOMANDO = %ld(max) + %ld(arr(m mod 5)) = %ld (maxfinal)\\n\".)max += arr[(m%5)]; m++; } \n                if (max_t < max)    {max_t = max; max = 0;}\n                else    if (max < min ) {min = max; max= 0;}\n                else max =0;\n            j++;\n        }\n    }    \n    printf(\"%ld %ld\",min,max_t);\n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":514,"fileType":"c","requestStartTime":1517927047902}}
{"body": {"column":69,"line":17,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    int min,max,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        while(j<5){\n            for (i = 0 ; i < arr_size-1 ; i++){ max += arr[(m%5)]; m++; } \n                if (max_t < max)    {max_t = max; max = 0; min = max.}\n                else    if (max < min ) {min = max; max= 0;}\n                else max = 0;\n            j++;\n        }\n    }    \n    printf(\"%d %d\",min,max_t);\n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":544,"fileType":"c","requestStartTime":1517927454871}}
{"body": {"column":20,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > )\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":642,"fileType":"c","requestStartTime":1517928227185}}
{"body": {"column":29,"line":23,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1>)\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":740,"fileType":"c","requestStartTime":1517928256335}}
{"body": {"column":30,"line":26,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 >)\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":852,"fileType":"c","requestStartTime":1517928321087}}
{"body": {"column":26,"line":29,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 >)\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":955,"fileType":"c","requestStartTime":1517928360688}}
{"body": {"column":29,"line":30,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max4 > )\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":991,"fileType":"c","requestStartTime":1517928371272}}
{"body": {"column":21,"line":36,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2>)\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1194,"fileType":"c","requestStartTime":1517928488072}}
{"body": {"column":22,"line":36,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 >)\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1195,"fileType":"c","requestStartTime":1517928490487}}
{"body": {"column":28,"line":36,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 > max3>)\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1201,"fileType":"c","requestStartTime":1517928493327}}
{"body": {"column":25,"line":37,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 > max3)\n                if (max2>)\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1227,"fileType":"c","requestStartTime":1517928501846}}
{"body": {"column":26,"line":37,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 > max3)\n                if (max2 >)\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1228,"fileType":"c","requestStartTime":1517928502534}}
{"body": {"column":29,"line":39,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 > max3)\n                if (max2 > max4)\n                    if (max2 > max5) \n                        max_>\n    }    \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1302,"fileType":"c","requestStartTime":1517928556231}}
{"body": {"column":30,"line":41,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 > max3)\n                if (max2 > max4)\n                    if (max2 > max5) max_t = max2;\n                    else max_t = max5;\n                else\n                    if (max4 >)\n    }           \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1376,"fileType":"c","requestStartTime":1517928620558}}
{"body": {"column":26,"line":44,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 > max3)\n                if (max2 > max4)\n                    if (max2 > max5) max_t = max2;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 >)\n    }           \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1479,"fileType":"c","requestStartTime":1517928650905}}
{"body": {"column":31,"line":45,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 > max3)\n                if (max2 > max4)\n                    if (max2 > max5) max_t = max2;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                    if (max3 > )\n    }           \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1517,"fileType":"c","requestStartTime":1517928683406}}
{"body": {"column":31,"line":48,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 > max3)\n                if (max2 > max4)\n                    if (max2 > max5) max_t = max2;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                    if (max3 > max5) max_t = max3;\n                    else max_t = max5;\n                else\n                    if (max 4 >)\n    }           \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1628,"fileType":"c","requestStartTime":1517928711072}}
{"body": {"column":30,"line":48,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid miniMaxSum(int arr_size, int* arr) {\n    // Complete this function\n    int i,ok;\n    long min,max1,max2,max3,max4,max5,max_t=0,m=0,j=0;\n    for (i = 0 ; i < arr_size ; i++) if ((arr[i] > 0) && (arr[i] < 1000000000)) ok = 1 ; else ok = 0;\n    if (ok == 1){\n        max1 = arr[0]+arr[1]+arr[2]+arr[3];\n        max2 = arr[1]+arr[2]+arr[3]+arr[4];\n        max3 = arr[2]+arr[3]+arr[4]+arr[0];\n        max4 = arr[3]+arr[4]+arr[0]+arr[1];\n        max5 = arr[4]+arr[0]+arr[1]+arr[2];\n        if ( max1 > max2 )\n            if (max1 > max3)\n                if (max1 > max4)\n                    if (max1 > max5) max_t = max1;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                   if(max3 > max5) max_t = max3;\n                   else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n        else\n            if (max2 > max3)\n                if (max2 > max4)\n                    if (max2 > max5) max_t = max2;\n                    else max_t = max5;\n                else\n                    if (max4 > max5) max_t = max4;\n                    else max_t = max5;\n            else\n                if (max3 > max4)\n                    if (max3 > max5) max_t = max3;\n                    else max_t = max5;\n                else\n                    if (max4 >)\n    }           \n    \n    \n}\n\nint main() {\n    int *arr = malloc(sizeof(int) * 5);\n    for (int arr_i = 0; arr_i < 5; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    miniMaxSum(5, arr);\n    return 0;\n}\n\n\n","offset":1627,"fileType":"c","requestStartTime":1517928717688}}
{"body": {"column":15,"line":1,"wordToComplete":"include<stdio.","code":"\n#include<stdio.\n\n\n","offset":17,"fileType":"c","requestStartTime":1517929805802}}
{"body": {"column":17,"line":1,"wordToComplete":"include<stdio.h>","code":"\n#include<stdio.h>\n\n\n","offset":19,"fileType":"c","requestStartTime":1517929806400}}
{"body": {"column":13,"line":15,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar** catAndMouse(int x, int y, int z, int *result_size, int q) {\n    // Complete this function4\n    int a,b,c;\n    for(a=0;a<q;a++){\n        int b = abs(z-x);\n        int c = abs(z-y);\n        if(b>)\n    }\n    \n}\n\nint main() {\n    int q; \n    scanf(\"%i\", &q);\n    for(int a0 = 0; a0 < q; a0++){\n        int x; \n        int y; \n        int z; \n        scanf(\"%i %i %i\", &x, &y, &z);\n        int result_size;\n        char** result = catAndMouse(x, y, z, &result_size, q);\n        for(int result_i = 0; result_i < result_size; result_i++) {\n            if(result_i) {\n                printf(\" \");\n            }\n            printf(\"%s\", result[result_i]);\n        }\n        puts(\"\");\n\n\n    }\n    return 0;\n}\n\n\n","offset":341,"fileType":"c","requestStartTime":1517932369011}}
{"body": {"column":18,"line":17,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar** catAndMouse(int x, int y, int z, int *result_size, int q) {\n    // Complete this function4\n    int a,b,c;\n    for(a=0;a<q;a++){\n        int b = abs(z-x);\n        int c = abs(z-y);\n        if(b>c)\n            return \"Cat A\"\n        else if(c>)\n    }\n    \n}\n\nint main() {\n    int q; \n    scanf(\"%i\", &q);\n    for(int a0 = 0; a0 < q; a0++){\n        int x; \n        int y; \n        int z; \n        scanf(\"%i %i %i\", &x, &y, &z);\n        int result_size;\n        char** result = catAndMouse(x, y, z, &result_size, q);\n        for(int result_i = 0; result_i < result_size; result_i++) {\n            if(result_i) {\n                printf(\" \");\n            }\n            printf(\"%s\", result[result_i]);\n        }\n        puts(\"\");\n\n\n    }\n    return 0;\n}\n\n\n","offset":389,"fileType":"c","requestStartTime":1517932401937}}
{"body": {"column":15,"line":2,"wordToComplete":"include<conio.","code":"\n#include<stdio.h>\n#include<conio.\n\nvoid days(int,int,int,int,int,int);\nint month(int,int);\n\nint mon[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n\nvoid main()\n  {\n    int a1,b1,c1,a2,b2,c2;\n    printf(\"Enter first date(dd mm yyyy) : \");\n    scanf(\"%d%d%d\",&a1,&b1,&c1);\n    printf(\"\\nEnter second date(dd mm yyyy) : \");\n    scanf(\"%d%d%d\",&a2,&b2,&c2);\n    if(c2>=c1)\n        days(c1,c2,b1,b2,a1,a2);\n    else\n        days(c2,c1,b2,b1,a2,a1);\n  getch();\n  }\n\nvoid days(int y1,int y2,int m1,int m2,int d1,int d2)\n  {\n  int count=0,i;\n    for(i=y1;i<y2;i++)\n        {\n            if(i%4==0)\n                count+=366;\n            else\n                count+=365;\n        }\n        count-=month(m1,y1);\n        count-=d1;\n        count+=month(m2,y2);\n        count+=d2;\n        if(count<0)\n            count=count*-1;\n        printf(\"The no. of days b/w the 2 dates = %d days\",count);\n  }\n\nint month(int a,int yy)\n  {\n  int x=0,c;\n    for(c=0;c<a-1;c++)\n        {\n            if(c==1)\n            {\n                if(yy%4==0)\n                    x+=29;\n                else\n                    x+=28;\n            } \n            else\n                x += mon[c];\n        }\n  return(x);\n }\n\n\n","offset":35,"fileType":"c","requestStartTime":1517932852212}}
{"body": {"column":17,"line":2,"wordToComplete":"include<conio.h>","code":"\n#include<stdio.h>\n#include<conio.h>\n\nvoid days(int,int,int,int,int,int);\nint month(int,int);\n\nint mon[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n\nvoid main()\n  {\n    int a1,b1,c1,a2,b2,c2;\n    printf(\"Enter first date(dd mm yyyy) : \");\n    scanf(\"%d%d%d\",&a1,&b1,&c1);\n    printf(\"\\nEnter second date(dd mm yyyy) : \");\n    scanf(\"%d%d%d\",&a2,&b2,&c2);\n    if(c2>=c1)\n        days(c1,c2,b1,b2,a1,a2);\n    else\n        days(c2,c1,b2,b1,a2,a1);\n  getch();\n  }\n\nvoid days(int y1,int y2,int m1,int m2,int d1,int d2)\n  {\n  int count=0,i;\n    for(i=y1;i<y2;i++)\n        {\n            if(i%4==0)\n                count+=366;\n            else\n                count+=365;\n        }\n        count-=month(m1,y1);\n        count-=d1;\n        count+=month(m2,y2);\n        count+=d2;\n        if(count<0)\n            count=count*-1;\n        printf(\"The no. of days b/w the 2 dates = %d days\",count);\n  }\n\nint month(int a,int yy)\n  {\n  int x=0,c;\n    for(c=0;c<a-1;c++)\n        {\n            if(c==1)\n            {\n                if(yy%4==0)\n                    x+=29;\n                else\n                    x+=28;\n            } \n            else\n                x += mon[c];\n        }\n  return(x);\n }\n\n\n","offset":37,"fileType":"c","requestStartTime":1517932852713}}
{"body": {"column":13,"line":8,"wordToComplete":"","code":"\n#include <stdio.h>\n\nint main()\n{\n   int marks;\n   char grade;\n   scanf(\"%d\", &marks);\n   if(marks .//write the code to assign the grade\n\n\n\n   printf(\"%c\", grade);\n   return 0;\n}\n\n\n","offset":101,"fileType":"c","requestStartTime":1517932967082}}
{"body": {"column":13,"line":8,"wordToComplete":"","code":"\n#include <stdio.h>\n\nint main()\n{\n   int marks;\n   char grade;\n   scanf(\"%d\", &marks);\n   if(marks >//write the code to assign the grade\n\n\n\n   printf(\"%c\", grade);\n   return 0;\n}\n\n\n","offset":101,"fileType":"c","requestStartTime":1517932971427}}
{"body": {"column":18,"line":10,"wordToComplete":"","code":"\n#include <stdio.h>\n\nint main()\n{\n   int marks;\n   char grade;\n   scanf(\"%d\", &marks);\n   if(marks >=76 && marks <= 100)\n   { grade = A;}\n    else if(marks>//write the code to assign the grade\n\n\n\n   printf(\"%c\", grade);\n   return 0;\n}\n\n\n","offset":157,"fileType":"c","requestStartTime":1517933219603}}
{"body": {"column":19,"line":10,"wordToComplete":"","code":"\n#include <stdio.h>\n\nint main()\n{\n   int marks;\n   char grade;\n   scanf(\"%d\", &marks);\n   if(marks >=76 && marks <= 100)\n   { grade = A;}\n    else if(marks >//write the code to assign the grade\n\n\n\n   printf(\"%c\", grade);\n   return 0;\n}\n\n\n","offset":158,"fileType":"c","requestStartTime":1517933223077}}
{"body": {"column":19,"line":12,"wordToComplete":"","code":"\n#include <stdio.h>\n\nint main()\n{\n   int marks;\n   char grade;\n   scanf(\"%d\", &marks);\n   if(marks >=76 && marks <= 100)\n   { grade = A;}\n    else if(marks >=51 && marks <=75)\n    {grade= B;}\n    else if(marks >//write the code to assign the grade\n\n\n\n   printf(\"%c\", grade);\n   return 0;\n}\n\n\n","offset":212,"fileType":"c","requestStartTime":1517933287299}}
{"body": {"column":16,"line":43,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *head = list;\n    while(list->)\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":986,"fileType":"c","requestStartTime":1517934391608}}
{"body": {"column":17,"line":44,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *head = list;\n    while(list->next != NULL) {\n        if (list.)\n    }\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1019,"fileType":"c","requestStartTime":1517934405175}}
{"body": {"column":31,"line":45,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *head = list;\n    while(list->next != NULL) {\n        if (list->val > x) {\n            list->next = list->\n        }\n    }\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1062,"fileType":"c","requestStartTime":1517934466292}}
{"body": {"column":37,"line":45,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *head = list;\n    while(list->next != NULL) {\n        if (list->val > x) {\n            list->next = list->next->\n        }\n    }\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1068,"fileType":"c","requestStartTime":1517934469093}}
{"body": {"column":5,"line":74,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct node{\n    int value;\n    struct node *next;\n};\n\nstruct node * \nlist_insert (struct node *head, int value)\n{\n    struct node *node, *new_node;\n    \n    if (head == NULL) {\n        head = malloc (sizeof(struct node));\n        head->value = value;\n        head->next = NULL;\n        return head;\n    }\n    new_node = malloc (sizeof (struct node));\n    new_node->value = value;\n    new_node->next = NULL;\n    node = head;\n    while (node->next != NULL) {\n        node= node->next;\n    }\n    node->next = new_node;\n    return head;\n}\n\nstruct node *\nget_ptr_from_list (struct node *node, int value)\n{\n    struct node *ptr;\n    \n    ptr = node;\n    while (ptr != NULL){\n        if (ptr->value == value) {\n            return ptr;\n        }\n        ptr = ptr->next;\n    }\n    return NULL;\n}\n/*\n * Complete the function below.\n */\nvoid \ndelete_node_in_linked_list (struct node *ptr) {\n\n\n/*\n * Write the code below to delete the node from the list\n * Do not print anything in this function.\n * There is a function in main to print contents of the linked list\n */\n struct node *temp;\n if(ptr!=NULL)\n {\n temp = ptr->next;\n if(temp!=NULL)\n {\nptr->value = temp->value;\nptr->next = temp->next;\nfree(temp);\n}\nelse\n{\nptr->value =NULL;\nptr->\n}\n\n\n }\n\n}\n\nint main() \n{\n    bool res;\n    int n, i, input, node_val;\n    struct node *head= NULL, *node = NULL;\n\n    scanf(\"%d\", &n);\n    for (i=0; i<n; i++) {\n        scanf(\"%d\", &input);\n        head = list_insert(head, input);\n    }\n    scanf(\"%d\", &node_val);\n    node = get_ptr_from_list(head, node_val);\n    delete_node_in_linked_list(node);\n    node = head;\n    while (node != NULL) {\n        printf(\"%d \", node->value);\n        node = node->next;\n    }\n    return 0;\n}\n\n","offset":1369,"fileType":"c","requestStartTime":1517934478365}}
{"body": {"column":21,"line":47,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *head = list;\n    while(list->next != NULL) {\n        if (list->val > x) {\n            list->next = list->next->next;\n        }\n        list = list->\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1105,"fileType":"c","requestStartTime":1517934549471}}
{"body": {"column":28,"line":46,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    while(current != NULL && current->next != NULL) {\n        if (current->val > x) {\n            temp = current->\n            ->next = list->next->next;\n        }\n        list = list->next;\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1113,"fileType":"c","requestStartTime":1517934764258}}
{"body": {"column":21,"line":47,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    while(current != NULL && current->next != NULL) {\n        if (current->val > x) {\n            temp = current->next;\n            current->\n            ->next = list->next->next;\n        }\n        list = list->next;\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1140,"fileType":"c","requestStartTime":1517934778323}}
{"body": {"column":34,"line":47,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    while(current != NULL && current->next != NULL) {\n        if (current->val > x) {\n            temp = current->next;\n            current->next = temp->\n            ->next = list->next->next;\n        }\n        list = list->next;\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1153,"fileType":"c","requestStartTime":1517934781494}}
{"body": {"column":31,"line":50,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    while(current != NULL && current->next != NULL) {\n        if (current->val > x) {\n            temp = current->next;\n            current->next = temp->next;\n            free(temp);\n        }else {\n            current = current->\n        }\n        list = list->next;\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1230,"fileType":"c","requestStartTime":1517934806187}}
{"body": {"column":14,"line":26,"wordToComplete":"","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\nstruct node {\n    struct node *left,*right;\n    int val, val1;\n};\ntypedef struct node node;\nnode * addElement(node * root, int x);\n/* Any extra functions you would like to add, code here */\n\n/* Any extra functions you would like to add, code here */\n\nint isPresent(node* root, int val){\n    /* For your reference\n       struct node {\n        struct node *left,*right;\n        int val;\n    };\n    */\n    if (root == NULL)\n        return 0;\n    if (root->val == val)\n        return 1;\n    \n    if (root->)\n}\nint main(){\n    node * root = NULL;\n    int a[100005],K,i = 0,j = 0, _element, present;\n    \n    scanf(\"%d\",&K);\n    for( j = 0; j < K;j++ ) {\n        scanf(\"%d\",&a[i++]);    \n    }\n\n    for( i = 0; i < K;i++ ){\n        root = addElement(root,a[i]);\n    }\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d\",&_element);\n        present = isPresent(root, _element);\n        printf(\"%d\\n\", present);\n    }\n    \n    return 0;\n}\n\nnode * addElement(node * root, int x ){\n    if( root == NULL ) {\n        root = (node *) (malloc(sizeof(node))); \n        root->val = x;root->val1 = -1;\n                            root->left = NULL; root->right = NULL;\n        return root;\n    }\n    if( x < root->val ) {\n         root->left = addElement(root->left,x);\n    }\n    else {\n        root->right = addElement(root->right,x);                            \n    }\n    return root;\n}\n","offset":608,"fileType":"c","requestStartTime":1517934916374}}
{"body": {"column":30,"line":27,"wordToComplete":"","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\nstruct node {\n    struct node *left,*right;\n    int val, val1;\n};\ntypedef struct node node;\nnode * addElement(node * root, int x);\n/* Any extra functions you would like to add, code here */\n\n/* Any extra functions you would like to add, code here */\n\nint isPresent(node* root, int val){\n    /* For your reference\n       struct node {\n        struct node *left,*right;\n        int val;\n    };\n    */\n    if (root == NULL)\n        return 0;\n    if (root->val == val)\n        return 1;\n    \n    if (root->val < val) \n        return isPresent(root.)\n}\nint main(){\n    node * root = NULL;\n    int a[100005],K,i = 0,j = 0, _element, present;\n    \n    scanf(\"%d\",&K);\n    for( j = 0; j < K;j++ ) {\n        scanf(\"%d\",&a[i++]);    \n    }\n\n    for( i = 0; i < K;i++ ){\n        root = addElement(root,a[i]);\n    }\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d\",&_element);\n        present = isPresent(root, _element);\n        printf(\"%d\\n\", present);\n    }\n    \n    return 0;\n}\n\nnode * addElement(node * root, int x ){\n    if( root == NULL ) {\n        root = (node *) (malloc(sizeof(node))); \n        root->val = x;root->val1 = -1;\n                            root->left = NULL; root->right = NULL;\n        return root;\n    }\n    if( x < root->val ) {\n         root->left = addElement(root->left,x);\n    }\n    else {\n        root->right = addElement(root->right,x);                            \n    }\n    return root;\n}\n","offset":650,"fileType":"c","requestStartTime":1517934932584}}
{"body": {"column":31,"line":27,"wordToComplete":"","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\nstruct node {\n    struct node *left,*right;\n    int val, val1;\n};\ntypedef struct node node;\nnode * addElement(node * root, int x);\n/* Any extra functions you would like to add, code here */\n\n/* Any extra functions you would like to add, code here */\n\nint isPresent(node* root, int val){\n    /* For your reference\n       struct node {\n        struct node *left,*right;\n        int val;\n    };\n    */\n    if (root == NULL)\n        return 0;\n    if (root->val == val)\n        return 1;\n    \n    if (root->val < val) \n        return isPresent(root->)\n}\nint main(){\n    node * root = NULL;\n    int a[100005],K,i = 0,j = 0, _element, present;\n    \n    scanf(\"%d\",&K);\n    for( j = 0; j < K;j++ ) {\n        scanf(\"%d\",&a[i++]);    \n    }\n\n    for( i = 0; i < K;i++ ){\n        root = addElement(root,a[i]);\n    }\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d\",&_element);\n        present = isPresent(root, _element);\n        printf(\"%d\\n\", present);\n    }\n    \n    return 0;\n}\n\nnode * addElement(node * root, int x ){\n    if( root == NULL ) {\n        root = (node *) (malloc(sizeof(node))); \n        root->val = x;root->val1 = -1;\n                            root->left = NULL; root->right = NULL;\n        return root;\n    }\n    if( x < root->val ) {\n         root->left = addElement(root->left,x);\n    }\n    else {\n        root->right = addElement(root->right,x);                            \n    }\n    return root;\n}\n","offset":651,"fileType":"c","requestStartTime":1517934933925}}
{"body": {"column":28,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar* acidNaming(char* acid_name) {\n    // Complete this function\n    for(int i=0;i<acid_name.)\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    for(int a0 = 0; a0 < n; a0++){\n        char* acid_name = (char *)malloc(512000 * sizeof(char));\n        scanf(\"%s\", acid_name);\n        int result_size;\n        char* result = acidNaming(acid_name);\n        printf(\"%s\\n\", result);\n    }\n    return 0;\n}\n\n\n","offset":235,"fileType":"c","requestStartTime":1517934977293}}
{"body": {"column":19,"line":68,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct node{\n    int value;\n    struct node *next;\n};\n\nstruct node * \nlist_insert (struct node *head, int value)\n{\n    struct node *node, *new_node;\n    \n    if (head == NULL) {\n        head = malloc (sizeof(struct node));\n        head->value = value;\n        head->next = NULL;\n        return head;\n    }\n    new_node = malloc (sizeof (struct node));\n    new_node->value = value;\n    new_node->next = NULL;\n    node = head;\n    while (node->next != NULL) {\n        node= node->next;\n    }\n    node->next = new_node;\n    return head;\n}\n\nstruct node *\nget_ptr_from_list (struct node *node, int value)\n{\n    struct node *ptr;\n    \n    ptr = node;\n    while (ptr != NULL){\n        if (ptr->value == value) {\n            return ptr;\n        }\n        ptr = ptr->next;\n    }\n    return NULL;\n}\n/*\n * Complete the function below.\n */\nvoid \ndelete_node_in_linked_list (struct node *ptr) {\n\n\n/*\n * Write the code below to delete the node from the list\n * Do not print anything in this function.\n * There is a function in main to print contents of the linked list\n */\n struct node *temp;\n if(ptr!=NULL)\n {\n temp = ptr->next;\n if(temp!=NULL)\n {\n ptr->value = temp->value;\n ptr->next = temp->\n \n \n \n \n }\n\n\n \n\n}\n\nint main() \n{\n    bool res;\n    int n, i, input, node_val;\n    struct node *head= NULL, *node = NULL;\n\n    scanf(\"%d\", &n);\n    for (i=0; i<n; i++) {\n        scanf(\"%d\", &input);\n        head = list_insert(head, input);\n    }\n    scanf(\"%d\", &node_val);\n    node = get_ptr_from_list(head, node_val);\n    delete_node_in_linked_list(node);\n    node = head;\n    while (node != NULL) {\n        printf(\"%d \", node->value);\n        node = node->next;\n    }\n    return 0;\n}\n\n","offset":1321,"fileType":"c","requestStartTime":1517935168350}}
{"body": {"column":17,"line":44,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    if (current->\n    while(current != NULL && current->next != NULL) {\n        if (current->next->val > x) {\n            temp = current->next;\n            current->next = temp->next;\n            free(temp);\n        }else {\n            current = current->next;\n        }\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1016,"fileType":"c","requestStartTime":1517935206934}}
{"body": {"column":24,"line":45,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    if (current->val > x) {\n        list = current->\n    }\n    while(current != NULL && current->next != NULL) {\n        if (current->next->val > x) {\n            temp = current->next;\n            current->next = temp->next;\n            free(temp);\n        }else {\n            current = current->next;\n        }\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1051,"fileType":"c","requestStartTime":1517935226231}}
{"body": {"column":22,"line":45,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    if (current->val > x) {\n        if (current ->)\n        list = current->next;\n    }\n    while(current != NULL && current->next != NULL) {\n        if (current->next->val > x) {\n            temp = current->next;\n            current->next = temp->next;\n            free(temp);\n        }else {\n            current = current->next;\n        }\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1049,"fileType":"c","requestStartTime":1517935267179}}
{"body": {"column":20,"line":24,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nlong int sum(int i, int j, int* A)\n{\n    long int s = 0;\n    for(int l=i;l<j;l++)\n        for(int m=l+1;m<j+1;m++ )\n            sum = sum + A[l]*A[m];\n    return sum;\n        \n        \n}\nlong int largestValue(int A_size, int* A) {\n    // Return the largest value of any of A's nonempty subarrays.\n    long int max=-100000;\n     for(int i=0;i<A_size;i++)\n        for(int j=i+1;j<A_size+1;j++ )\n            t=sum(i.)\n            if(sum(i,j,A)>max)\n                max\n            sum = sum + A[l]*A[m];\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *A = malloc(sizeof(int) * n);\n    for (int A_i = 0; A_i < n; A_i++) {\n       scanf(\"%i\",&A[A_i]);\n    }\n    long int result = largestValue(n, A);\n    printf(\"%ld\\n\", result);\n    return 0;\n}\n\n\n","offset":554,"fileType":"c","requestStartTime":1517935314677}}
{"body": {"column":17,"line":45,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    if (current == NULL) return NULL;\n    if (current->)\n    /*if (current->val > x) {\n        if (current -> next == NULL) return NULL;\n        list = current->next;\n    }*/\n    while(current != NULL && current->next != NULL) {\n        if (current->next->val > x) {\n            temp = current->next;\n            current->next = temp->next;\n            free(temp);\n        }else {\n            current = current->next;\n        }\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1054,"fileType":"c","requestStartTime":1517935398359}}
{"body": {"column":21,"line":46,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    if (current == NULL) return NULL;\n    if (current-> next == NULL) {\n        if (current->)\n    }\n    /*if (current->val > x) {\n        if (current -> next == NULL) return NULL;\n        list = current->next;\n    }*/\n    while(current != NULL && current->next != NULL) {\n        if (current->next->val > x) {\n            temp = current->next;\n            current->next = temp->next;\n            free(temp);\n        }else {\n            current = current->next;\n        }\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1092,"fileType":"c","requestStartTime":1517935409482}}
{"body": {"column":10,"line":12,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nlong int sum(int i, int j, int* A)\n{\n    long int sum = 0;\n    int l.\n    for( l=i;l<j;l++)\n    {}  for( m=l+1;m<j+1;m++ )\n            sum = sum + A[l]*A[m];}\n    return sum;\n        \n        \n}\nlong int largestValue(int A_size, int* A) {\n    // Return the largest value of any of A's nonempty subarrays.\n    long int max=-100000;\n    long int t;\n    \n     for(int i=0;i<A_size;i++)\n     {for(int j=i+1;j<A_size+1;j++ )\n            t=sum(i,j,A);\n            if(t>max)\n                max=t;}\n            \n    return max;\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *A = malloc(sizeof(int) * n);\n    for (int A_i = 0; A_i < n; A_i++) {\n       scanf(\"%i\",&A[A_i]);\n    }\n    long int result = largestValue(n, A);\n    printf(\"%ld\\n\", result);\n    return 0;\n}\n\n\n","offset":210,"fileType":"c","requestStartTime":1517935522451}}
{"body": {"column":22,"line":19,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint formingMagicSquare(int s_size_rows, int s_size_cols, int** s) {\n    // Complete this function\n    int a,b,c,d,tem;\n    int *cnt[3];\n    for(a=0;a<3;a++){\n        for(b=0;b<3;b++)\n        cnt[a] += s[a][b];\n    }\n    for(c=0;c<2;c++)\n        for(d=0;d<3;d++)\n            if(cnt[c]>){}\n}\n\nint main() {\n    int s[3][3];\n    for (int s_i = 0; s_i < 3; s_i++) {\n       for (int s_j = 0; s_j < 3; s_j++) {\n      \n          scanf(\"%i\",&s[s_i][s_j]);\n       }\n    }\n    int result = formingMagicSquare(3, 3, s);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":425,"fileType":"c","requestStartTime":1517935583756}}
{"body": {"column":21,"line":16,"wordToComplete":"0.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    int iPos = 0;\n    int iNeg = 0;\n    int iZero = 0;\n    int i = 0;\n    \n    for(i = 0; i< arr_size; i++){\n        if(*arr >= 0.)\n    }\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":312,"fileType":"c","requestStartTime":1517935846833}}
{"body": {"column":16,"line":12,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint maxNumber(int a, int b, int c) {\n    int max = a;\n    if (a > b) {\n        if (a > )\n    }\n}\n\n/*\n * Complete the function below.\n * Please store the size of the string array to be returned in result_size pointer. For example,\n * char a[2][6] = {\"hello\", \"world\"};\n * *result_size = 2;\n * return a;\n * \n */\nchar** triangleOrNot(int a_size, int* a, int b_size, int* b, int c_size, int* c, int* result_size) {\n    char result[a_size][4];\n    result_size = a_size; //because the result is equal to the number of triangle passed\n    \n    for(int i =0; i<2; i++){\n        printf(\"%s\\n\", result[i]);\n    }\n    return result;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    char** res;\nint res_size;\n    int a_size = 0;\n    scanf(\"%d\\n\", &a_size);\n\n    int a[a_size];\n    for(int i = 0; i < a_size; i++) {\n        int a_item;\n        scanf(\"%d\", &a_item);\n        a[i] = a_item;\n    }\n\n    int b_size = 0;\n    scanf(\"%d\\n\", &b_size);\n\n    int b[b_size];\n    for(int i = 0; i < b_size; i++) {\n        int b_item;\n        scanf(\"%d\", &b_item);\n        b[i] = b_item;\n    }\n\n    int c_size = 0;\n    scanf(\"%d\\n\", &c_size);\n\n    int c[c_size];\n    for(int i = 0; i < c_size; i++) {\n        int c_item;\n        scanf(\"%d\", &c_item);\n        c[i] = c_item;\n    }\n\n    res = triangleOrNot(a_size, a, b_size, b, c_size, c, &res_size);\n    for (int res_i = 0; res_i < res_size; res_i++) {\n\n        fprintf(f, \"%s\\n\", res[res_i]);\n\n    }\n\n\n    fclose(f);\n    return 0;\n}\n\n","offset":228,"fileType":"c","requestStartTime":1517936326336}}
{"body": {"column":12,"line":11,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint maxNumber(int a, int b, int c) {\n    int max = a;\n    if (a > \n}\n\n/*\n * Complete the function below.\n * Please store the size of the string array to be returned in result_size pointer. For example,\n * char a[2][6] = {\"hello\", \"world\"};\n * *result_size = 2;\n * return a;\n * \n */\nchar** triangleOrNot(int a_size, int* a, int b_size, int* b, int c_size, int* c, int* result_size) {\n    char result[a_size][4];\n    result_size = a_size; //because the result is equal to the number of triangle passed\n    \n    for(int i =0; i<2; i++){\n        printf(\"%s\\n\", result[i]);\n    }\n    return result;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    char** res;\nint res_size;\n    int a_size = 0;\n    scanf(\"%d\\n\", &a_size);\n\n    int a[a_size];\n    for(int i = 0; i < a_size; i++) {\n        int a_item;\n        scanf(\"%d\", &a_item);\n        a[i] = a_item;\n    }\n\n    int b_size = 0;\n    scanf(\"%d\\n\", &b_size);\n\n    int b[b_size];\n    for(int i = 0; i < b_size; i++) {\n        int b_item;\n        scanf(\"%d\", &b_item);\n        b[i] = b_item;\n    }\n\n    int c_size = 0;\n    scanf(\"%d\\n\", &c_size);\n\n    int c[c_size];\n    for(int i = 0; i < c_size; i++) {\n        int c_item;\n        scanf(\"%d\", &c_item);\n        c[i] = c_item;\n    }\n\n    res = triangleOrNot(a_size, a, b_size, b, c_size, c, &res_size);\n    for (int res_i = 0; res_i < res_size; res_i++) {\n\n        fprintf(f, \"%s\\n\", res[res_i]);\n\n    }\n\n\n    fclose(f);\n    return 0;\n}\n\n","offset":207,"fileType":"c","requestStartTime":1517936343433}}
{"body": {"column":19,"line":2,"wordToComplete":"include <iostream.>","code":"\n#include <stdio.h>\n#include <iostream.>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n    int a, b, c;\n    cin<< a;\n    cin<< b;\n    cin<< c;\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":40,"fileType":"c","requestStartTime":1517937360458}}
{"body": {"column":21,"line":9,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n    int a, b, c;\n    scanf(\"%a,%b,%c\".&a,&b,&c);\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":132,"fileType":"c","requestStartTime":1517937686551}}
{"body": {"column":9,"line":11,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n    int a, b, c;\n    scanf(\"%a,%b,%c\",&a,&b,&c);\n    \n    if(a>)\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\n\n","offset":157,"fileType":"c","requestStartTime":1517937838840}}
{"body": {"column":17,"line":14,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    for (int i=0;)\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":242,"fileType":"c","requestStartTime":1517937868108}}
{"body": {"column":30,"line":14,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    for (int i=0; i<grid_size;)\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":255,"fileType":"c","requestStartTime":1517937874876}}
{"body": {"column":37,"line":14,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    \n    for (int i=0; i<grid_size;i++){\n        \n    }\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":262,"fileType":"c","requestStartTime":1517938187917}}
{"body": {"column":21,"line":17,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    \n    for (int i=0; i<51200;i++){\n        for (int k=0;)\n        \n    }\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":325,"fileType":"c","requestStartTime":1517938208497}}
{"body": {"column":33,"line":17,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    \n    for (int i=0; i<51200;i++){\n        for (int k=0;k<grid_size;)\n        \n    }\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":337,"fileType":"c","requestStartTime":1517938214001}}
{"body": {"column":35,"line":15,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    int already_analysed[51200][2];\n    for (int i=0; i<51200;i++){\n        for (int k=0;k<grid_size;k++){\n            if ()\n        }\n        \n    }\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":302,"fileType":"c","requestStartTime":1517938460377}}
{"body": {"column":24,"line":26,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nchar* findNumber(int arr_size, int* arr, int k) {\n    int i;\n    int found = 0;\n    char str ret_str[4];\n    \n    for (i = 0; i < arr_size; i++) {\n        if (arr[i] == k) {\n            found = 1;\n            break;\n        }\n    }\n    \n    if (found)\n        sprintf(ret_str,\"YES\\n\");\n    else\n        sprintf(ret_str.)\n\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    char* res;\n    \n    int _arr_size = 0;\n    int _arr_i;\n    scanf(\"%d\\n\", &_arr_size);\n    int _arr[_arr_size];\n    for(_arr_i = 0; _arr_i < _arr_size; _arr_i++) {\n        int _arr_item;\n        scanf(\"%d\", &_arr_item);\n        \n        _arr[_arr_i] = _arr_item;\n    }\n    \n    int _k;\n    scanf(\"%d\", &_k);\n    \n    res = findNumber(_arr_size, _arr, _k);\n    fprintf(f, \"%s\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":498,"fileType":"c","requestStartTime":1517938485246}}
{"body": {"column":13,"line":27,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    int already_analysed[51200][2];\n\n    for (int i=0; i<51200;i++){\n        for (int k=0;k<grid_size;k++){\n            //printf('%c',grid[])\n            /*if(grid[i]=='Y'){\n                \n            }\n            else()*/\n        }\n        \n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":531,"fileType":"c","requestStartTime":1517938735321}}
{"body": {"column":31,"line":18,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    int already_analysed[51200][2];\n\n    for (int i=0; i<grid_size;i++){\n        printf(\"%s\\n\",grid[i]);\n        for (int k=0;k<51200;k++){\n            /*printf('%c',grid[])\n            if(grid[i]=='Y'){\n                \n            }\n            else()*/\n        }\n        \n    }\nprintf(\"----------\\n\\n\\n\")\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":371,"fileType":"c","requestStartTime":1517938878213}}
{"body": {"column":27,"line":28,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    int already_analysed[51200][2];\n\n    for (int i=0; i<grid_size;i++){\n        printf(\"%s\\n\",grid[i]);\n        for (int k=0;k<51200;k++){\n            /*printf('%c',grid[])\n            if(grid[i]=='Y'){\n                \n            }\n            else()*/\n        }\n        \n    }\nprintf(\"----------\\n\\n\\n\");\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":575,"fileType":"c","requestStartTime":1517938891725}}
{"body": {"column":12,"line":16,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    int already_analysed[51200][2];\n    int k=0;\n    for (int i=0; i<grid_size;i++){\n        printf(\"%s\\n\",grid[i]);\n\n        \n    }\nprintf(\"----------\\n\\n\\n\");\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":315,"fileType":"c","requestStartTime":1517938953609}}
{"body": {"column":14,"line":17,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int k=0;\n    char temp;\n\n    for (int i=0; i<grid_size;i++){\n        printf(\"%s\\n\",grid[i]);\n        while ()\n        \n    }\nprintf(\"----------\\n\\n\\n\");\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":332,"fileType":"c","requestStartTime":1517939062577}}
{"body": {"column":16,"line":22,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int k=0;\n    char temp;\n\n    for (int i=0; i<grid_size;i++){\n        printf(\"%s\\n\",grid[i]);\n        while (grid[k]!='\\0'){\n            k++;\n        }\n        \n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":449,"fileType":"c","requestStartTime":1517939186827}}
{"body": {"column":21,"line":25,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int k=0;\n    char temp;\n\n    for (int i=0; i<grid_size;i++){\n        printf(\"%s\\n\",grid[i]);\n        while (*grid[k]!='\\0'){\n            printf(\"%c\")\n            k++;\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":507,"fileType":"c","requestStartTime":1517939319452}}
{"body": {"column":34,"line":22,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int k=0;\n    char temp;\n\n    for (int i=0; i<grid_size;i++){\n        printf(\"%s\\n\",grid[i]);\n        while (*grid[k]!='\\0'){\n            printf(\"%c\",*grid[k]);\n            k++;\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":468,"fileType":"c","requestStartTime":1517939332564}}
{"body": {"column":24,"line":7,"wordToComplete":"hello,world.\"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nmain()\n{\n    printf(\"hello,world.\");\n    printf(\"welcome to 30 days of code!\");\n}   \n\n","offset":112,"fileType":"c","requestStartTime":1517939396619}}
{"body": {"column":12,"line":25,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int k=0;\n    char temp;\n\n    for (int i=0; i<grid_size;i++){\n        printf(\"%s\\n\",grid[i]);\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*grid[k]);\n            k++;\n        }\n        k+à;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":512,"fileType":"c","requestStartTime":1517939450677}}
{"body": {"column":12,"line":25,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int k=0;\n    char temp;\n\n    for (int i=0; i<grid_size;i++){\n        printf(\"%s\\n\",grid[i]);\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*grid[k]);\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":512,"fileType":"c","requestStartTime":1517939452701}}
{"body": {"column":19,"line":16,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int nb_field=0;\n    int k=0;\n    char temp;\n\n    for (int i=0; i<grid_size;i++){\n        //printf(\"%s\\n\",grid[i]);\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k))\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":324,"fileType":"c","requestStartTime":1517939572415}}
{"body": {"column":34,"line":25,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int nb_field=0;\n    int k=0;\n    char temp;\n\n    for (int i=0; i<grid_size;i++){\n        //printf(\"%s\\n\",grid[i]);\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                printf(\"found\\n\");\n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":568,"fileType":"c","requestStartTime":1517939909507}}
{"body": {"column":23,"line":16,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int nb_field=0,k=0;;\n    int k=0;\n    char temp;\n    \n    for (int i=0; i<grid_size;i++){\n        //printf(\"%s\\n\",grid[i]);\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                if(i==0 && k=0){\n                    \n                }\n                if(i==0){\n                    \n                }\n                if()\n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":328,"fileType":"c","requestStartTime":1517940047429}}
{"body": {"column":17,"line":19,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int nb_field=0,k=0,k_max=0;\n    char temp;\n\n    for (int i=0;)\n    \n    for (int i=0; i<grid_size;i++){\n        //printf(\"%s\\n\",grid[i]);\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                if(i==0 && k=0){\n                    \n                }\n                if(i==0){\n                    \n                }\n                if()\n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":370,"fileType":"c","requestStartTime":1517940061301}}
{"body": {"column":16,"line":20,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int nb_field=0,k=0,k_max=0;\n    char temp;\n\n    while (*(grid[1]+k_max)!='\\0'){\n        k_max++;\n    \n    for (int i=0; i<grid_size;i++){\n        //printf(\"%s\\n\",grid[i]);\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                if(i==0 && k=0){\n                    \n                }\n                if(i==0){\n                    \n                }\n                if()\n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":405,"fileType":"c","requestStartTime":1517940107674}}
{"body": {"column":25,"line":22,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n    \n    int better_tab[51200][grid_size];    \n    //int already_analysed[51200][2];\n    int nb_field=0,k=0,k_max=0;\n    char temp;\n\n    while (*(grid[1]+k_max)!='\\0'){\n        k_max++;\n    }\n    printf(\"%d\\n\",k_max);\n    \n    for (int i=0; i<grid_size;i++){\n        //printf(\"%s\\n\",grid[i]);\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                if(i==0 && k=0){\n                    \n                }\n                if(i==0){\n                    \n                }\n                if()\n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":437,"fileType":"c","requestStartTime":1517940123769}}
{"body": {"column":45,"line":50,"wordToComplete":"check all the bigger values from head.","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    LinkedListNode *current = list;\n    LinkedListNode *temp;\n    if (current == NULL) return NULL; //check if the list is empty\n    // check if the list has only one element\n    if (current-> next == NULL) {\n        if (current->val > x) return NULL;\n        return list;\n    }\n    // check all the bigger values from head.\n    while (current->val > x && current != NULL) {\n        current = current->next;\n    }\n    list = current;\n    while(current != NULL && current->next != NULL) {\n        if (current->next->val > x) {\n            temp = current->next;\n            current->next = temp->next;\n            free(temp);\n        }else {\n            current = current->next;\n        }\n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1261,"fileType":"c","requestStartTime":1517940567935}}
{"body": {"column":17,"line":52,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n\n    while (*(grid[1]+k_max)!='\\0'){\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0;)\n\n\n    \n    for (int i=0; i<grid_size;i++){\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                \n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1133,"fileType":"c","requestStartTime":1517941194665}}
{"body": {"column":32,"line":52,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n\n    while (*(grid[1]+k_max)!='\\0'){\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;)\n\n\n    \n    for (int i=0; i<grid_size;i++){\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                \n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1148,"fileType":"c","requestStartTime":1517941200633}}
{"body": {"column":21,"line":53,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n\n    while (*(grid[1]+k_max)!='\\0'){\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;)\n    }\n\n\n    \n    for (int i=0; i<grid_size;i++){\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                \n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1175,"fileType":"c","requestStartTime":1517941210369}}
{"body": {"column":31,"line":53,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n\n    while (*(grid[1]+k_max)!='\\0'){\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;)\n    }\n\n\n    \n    for (int i=0; i<grid_size;i++){\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                \n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1185,"fileType":"c","requestStartTime":1517941218120}}
{"body": {"column":26,"line":54,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n\n    while (*(grid[1]+k_max)!='\\0'){\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab==0;\n        }\n    }\n\n\n    \n    for (int i=0; i<grid_size;i++){\n        while (*(grid[i]+k)!='\\0'){\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                \n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1217,"fileType":"c","requestStartTime":1517941229648}}
{"body": {"column":20,"line":61,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n\n    \n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;)\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                \n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1378,"fileType":"c","requestStartTime":1517941355884}}
{"body": {"column":30,"line":61,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n\n    \n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;)\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                \n            }\n            k++;\n        }\n        k=0;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1388,"fileType":"c","requestStartTime":1517941368260}}
{"body": {"column":35,"line":64,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n\n    \n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;k++)\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                better_tab[i][k]=1;\n            }\n        }\n\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1502,"fileType":"c","requestStartTime":1517941404731}}
{"body": {"column":42,"line":66,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n\n    \n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;k++)\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                better_tab[i][k]=1;\n            }\n            printf(\"%d\",better_tab[i][k]);\n    }\n\n\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1559,"fileType":"c","requestStartTime":1517941479136}}
{"body": {"column":13,"line":37,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n\n    \n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;k++)\n            printf(\"%c\",*(grid[i]+k));\n            if(*(grid[i]+k)=='Y'){\n                better_tab[i][k]=1;\n            }\n            printf(\"%d\",better_tab[i][k]);\n    }\n\n\n        printf(\"\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":901,"fileType":"c","requestStartTime":1517941519287}}
{"body": {"column":21,"line":64,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n\n    \n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;k++)\n            printf(\"%c\",*(grid[i]+k));\nprintf(\"i:%d k:%d\\n\";)\n            if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }\n            printf(\"%d\",better_tab[i][k]);\n    }\n\n\n        printf(\"\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1467,"fileType":"c","requestStartTime":1517941650651}}
{"body": {"column":26,"line":64,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n\n    \n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;k++)\n            printf(\"%c\",*(grid[i]+k));\nprintf(\"i:%d k:%d\\n\",i,k);\n            if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }\n            printf(\"%d\",better_tab[i][k]);\n    }\n\n\n        printf(\"\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1472,"fileType":"c","requestStartTime":1517941656659}}
{"body": {"column":15,"line":59,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\nprintf(\"test\");\n    \n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;k++)\n            printf(\"%c\",*(grid[i]+k));\n            printf(\"i:%d k:%d\\n\",i,k);\n            if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }\n            printf(\"%d\",better_tab[i][k]);\n    }\n\n\n        printf(\"\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1343,"fileType":"c","requestStartTime":1517941690555}}
{"body": {"column":23,"line":59,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n    int i_late, k_late;\n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;k++)\n            printf(\"%c\",*(grid[i-1]+k-1));\n            printf(\"i:%d k:%d\\n\",i,k);\n            if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }\n            printf(\"%d\",better_tab[i][k]);\n    }\n\n\n        printf(\"\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1351,"fileType":"c","requestStartTime":1517941771992}}
{"body": {"column":17,"line":69,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n    int i_late=0, k_late=0;\n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;k++){\n            printf(\"%c\",*(grid[i-1]+(k-1)));\n            printf(\"i:%d k:%d\\n\",i,k);\n            /*if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }*/\n            //printf(\"%d\",better_tab[i][k]);\n        }\n        i_late++;\n    }\n\n\n        printf(\"\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1681,"fileType":"c","requestStartTime":1517941919252}}
{"body": {"column":21,"line":68,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n    int i_late=0, k_late=0;\n    for (int i=1; i<grid_size-1;i++){\n        for(int k=1;k<k_max-1;k++){\n            printf(\"%c\",*(grid[i-1]+(k-1)));\n            printf(\"i:%d k:%d\\n\",i,k);\n            /*if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }*/\n            //printf(\"%d\",better_tab[i][k]);\n            k_late++;\n        }\n        i_late++;\n    }\n\n\n        printf(\"\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1675,"fileType":"c","requestStartTime":1517941925036}}
{"body": {"column":21,"line":58,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    \n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\nint grid2=gridsize-1;\n    for (int i=1; (i<grid_size-1);i++){\n        for(int k=1;k<(k_max-1);k++){\n           // printf(\"%c\",*(grid[i_late]+k_late));\n            printf(\"i:%d k:%d \\n\",i,k);\n            /* if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }*/\n            //printf(\"%d\",better_tab[i][k]);\n        }\n    }\n\n\n        printf(\"\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1348,"fileType":"c","requestStartTime":1517942164669}}
{"body": {"column":26,"line":50,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, char **grid, int i, int k){\n                \n                if(i==0 && k==0){\n                    \n                }\n                else if(i==0){\n                    \n                }\n                else if(k==0){\n                }\n                else if(i==0 && k==k_max){\n                    \n                }\n                else if(k==k_max){\n                    \n                }\n                else if(i==grid_size && k==k_max){\n                    \n                }\n                else if(i==grid_size && k==0 ){\n                    \n                }\n                else if (i==grid_size){\n                    \n                }\n                else{\n                    \n                }\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=-1;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n    printf(\"kmax : %d\\n\");\n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\nint grid2=grid_size-1;\n    for (int i=1; i<grid2;i++){\n        for(int k=1;k<(k_max-1);k++){\n           // printf(\"%c\",*(grid[i_late]+k_late));\n            printf(\"i:%d k:%d \\n\",i,k);\n            /* if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }*/\n            //printf(\"%d\",better_tab[i][k]);\n        }\n    }\n\n\n        printf(\"\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1178,"fileType":"c","requestStartTime":1517942274202}}
{"body": {"column":26,"line":11,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, int* better_tab, int i, int k){\n    \n    (*better_tab)[i][k]=0;\n\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=0;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n\n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){ // creating a new tab so it's easier\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n    for (int i=1; i<grid_size+1;i++){ // Adding border to browse it more easily \n        for(int k=1;k<k_max+1;k++){\n             if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }\n        }\n    }\n\n    for (int i=0; i<grid_size+2;i++){ // Browsing and first call of recursive function\n        for(int k=0;k<k_max+2;k++){\n             if(*(grid[i-1]+(k-1))=='Y'){\n               farmer(grid_size,k_max,&better_tab,i,k)\n            }\n           // printf(\"%d\",better_tab[i][k]);\n        }\n        //printf(\"\\n\");\n    }\n\n\n        \n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":241,"fileType":"c","requestStartTime":1517942999326}}
{"body": {"column":55,"line":46,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint farmer(int grid_size, int k_max, int* better_tab, int i, int k){\n    \n    (*better_tab)[i][k]=0;\n\n    return 0;\n}\n\n/*\n * Complete the function below.\n */\nint Group(int grid_size, char** grid) {\n\n    int nb_field=0,k=0,k_max=0;\n    \n    while (*(grid[1]+k_max)!='\\0'){ // This only work with squared or rectangle, easy to modify otherwise\n        k_max++;\n    }\n\n    int better_tab[k_max+2][grid_size+2];\n    \n    for (int i=0; i<grid_size+2;i++){ // creating a new tab so it's easier\n        for (int k=0;k<k_max+2;k++){\n            better_tab[i][k]=0;\n        }\n    }\n\n    for (int i=1; i<grid_size+1;i++){ // Adding border to browse it more easily \n        for(int k=1;k<k_max+1;k++){\n             if(*(grid[i-1]+(k-1))=='Y'){\n                better_tab[i][k]=1;\n            }\n        }\n    }\n\n    for (int i=0; i<grid_size+2;i++){ // Browsing and first call of recursive function\n        for(int k=0;k<k_max+2;k++){\n             if(*(grid[i-1]+(k-1))=='Y'){\n               farmer(grid_size,k_max,&better_tab,i,k);\n            }\n            printf(\"%d\",better_tab[i][k]);\n        }\n        printf(\"\\n\");\n    }\n\n\n        \n    \n    return 0;\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int res;\n    int grid_size = 0;\n    scanf(\"%d\\n\", &grid_size);\n\n    char* grid[grid_size];\n    for(int i = 0; i < grid_size; i++) {\n        char* grid_item;\n        grid_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",grid_item);\n        grid[i] = grid_item;\n    }\n\n    res = Group(grid_size, grid);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":1161,"fileType":"c","requestStartTime":1517943017636}}
{"body": {"column":10,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* solve(int a0, int a1, int a2, int b0, int b1, int b2, int *result_size){\n    // Complete this function\n    if(a0>)\n}\n\nint main() {\n    int a0; \n    int a1; \n    int a2; \n    scanf(\"%d %d %d\", &a0, &a1, &a2);\n    int b0; \n    int b1; \n    int b2; \n    scanf(\"%d %d %d\", &b0, &b1, &b2);\n    int result_size;\n    int* result = solve(a0, a1, a2, b0, b1, b2, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n    \n\n    return 0;\n}\n\n\n","offset":259,"fileType":"c","requestStartTime":1517943214493}}
{"body": {"column":21,"line":21,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below. use au8OutputArray as the array to store the results \n * Please store the size of the int array to be returned in result_size pointer. For example,\n * int a[3] = {1, 2, 3};\n * *result_size = 3;\n * return a;\n * \n */\n\n\nint au8OutputArray[256];\nint* vidPrintReverseInclusive(int u8LowerNumber, int u8UpperNumber, int* result_size) {\n\n   if (u8LowerNumber>)\nint i,j;\n  au8OutputArray[0]= u8UpperNumber;\n    int tempupper;\n    tempupper=u8UpperNumber;\n    \nfor(i=1; i<=(u8UpperNumber-u8LowerNumber);i++){\n    tempupper--;\n   au8OutputArray[i]=tempupper;\n      \n    }\n        \n   *result_size=(u8UpperNumber-u8LowerNumber)+1;\n  \n        \n    return au8OutputArray;\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res_size;\n    int* res;\n    int _u8LowerNumber;\n    scanf(\"%d\", &_u8LowerNumber);\n    \n    int _u8UpperNumber;\n    scanf(\"%d\", &_u8UpperNumber);\n    \n    res = vidPrintReverseInclusive(_u8LowerNumber, _u8UpperNumber, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":527,"fileType":"c","requestStartTime":1517944190716}}
{"body": {"column":39,"line":51,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct Tree node;\ntypedef struct TreeNode array;\n\n\nvoid inOrderTraversal(node*);\nnode* addNode(node*, int, int, array**, array**);  /* since this problem requires adding right and left at the same time */\nnode* createTree(int);   /* This will create the root node.  int allows for an optional value, but this problem root->data = 1 */\nvoid freeTree(node*);\nnode* deserialize(node*, int*, int, int, array*);\nnode* swapNodes(node*);  /* later determine parameters needed */\n\n\n\ntypedef struct Tree{\n    int data;\n    node *left;\n    node *right;\n}node;\n\ntypedef struct TreeNode{\n    node *data;\n    array *next;\n    array *prev;\n}array;\n\n\nnode* deserialize(node *tree, int* values, int index, int val_size, array* level, node **cur_node){\n    node *buf = NULL;\n    \n    if(tree == NULL){\n        tree = createTree(1);\n        level = (array*)malloc(sizeof(array));\n        level->data = tree;\n        level->next = NULL;\n        level->prev = NULL;\n        *cur_node = tree;\n        tree = deserialize(tree, values, 0, val_size, level, cur_node);\n    }else{\n        array *cur_level = level;\n        array *nextLevel = NULL;\n        while(cur_level != NULL && index < val_size){\n            if(index % 2 == 0){\n                \n            }else{\n                array *tmp = cur_level;\n                cur_level = cur_level->\n            }\n            \n            \n            array *tmp = cur_level;\n            cur_level = cur_level->next;\n            if(tmp != NULL){\n                free(tmp);\n            }\n            \n            index++;\n        }\n    }\n    \n    \n    return tree;\n}\n\n\n\n\n\nint main() {\n    node *tree = createTree(1);\n    \n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\nnode* createTree(int value){\n    node *root = NULL;\n    \n    if(value != -1){\n        root = (node*)malloc(sizeof(node));\n        root->data = value;\n        root->right = NULL;\n        root->left = NULL;\n    }\n    \n    return root;\n}\n\nnode* addNode(node *root, int l_value, int r_value, array** front, array** back){\n    if(l_value == -1 && r_value == -1){\n        return root;\n    }\n    if(root == NULL){\n        root = createTree(1);\n    }\n    array *level = *front;\n    if(level == NULL){\n        level = (array*)malloc(sizeof(array));\n        level->next = NULL;\n        level->prev = NULL;\n        level->data = NULL;\n        *back = level;\n    }\n    \n    array *buf = NULL;\n    \n    \n    root->left = createTree(l_value);\n    if(root->left != NULL){\n        if(level->data == NULL){\n            level->data = root->left;\n        }else{\n            buf = (array*)malloc(sizeof(array));\n            buf->data = root->left;\n            buf->prev = level;\n            level->next = buf;\n            level = buf;\n        }\n        \n    }\n    \n    root->right = createTree(r_value);\n    if(root->right != NULL){\n        if(level->data == NULL){\n            level->data = root->right;\n        }else{\n            buf = (array*)malloc(sizeof(array));\n            buf->data = root->right;\n            buf->prev = level;\n            level->next = buf;\n            level = buf;\n        }\n    }\n    \n    *front = level;\n    return root;\n}\n\n\nvoid freeTree(node *tree){\n    if(tree != NULL){\n        if(tree->left != NULL){\n            freeTree(tree->left);\n        }\n        if(tree->right != NULL){\n            freeTree(tree->right);\n        }\n        free(tree);\n    }\n}\n\nvoid inOrderTraversal(node *root) {\n    \n    \n    if(root->left != NULL){\n        inOrder(root->left);\n    }\n    printf(\"%d \", root->data);\n    if(root->right != NULL){\n        inOrder(root->right);\n    }\n}\n\n","offset":1411,"fileType":"c","requestStartTime":1517944473051}}
{"body": {"column":26,"line":49,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct Tree node;\ntypedef struct TreeNode array;\n\n\nvoid inOrderTraversal(node*);\nnode* addNode(node*, int, int, array**, array**);  /* since this problem requires adding right and left at the same time */\nnode* createTree(int);   /* This will create the root node.  int allows for an optional value, but this problem root->data = 1 */\nvoid freeTree(node*);\nnode* deserialize(node*, int*, int, int, array*);\nnode* swapNodes(node*);  /* later determine parameters needed */\n\n\n\ntypedef struct Tree{\n    int data;\n    node *left;\n    node *right;\n}node;\n\ntypedef struct TreeNode{\n    node *data;\n    array *next;\n    array *prev;\n}array;\n\n\nnode* deserialize(node *tree, int* values, int index, int val_size, array* level, node **cur_node){\n    node *buf = NULL;\n    \n    if(tree == NULL){\n        tree = createTree(1);\n        level = (array*)malloc(sizeof(array));\n        level->data = tree;\n        level->next = NULL;\n        level->prev = NULL;\n        *cur_node = tree;\n        tree = deserialize(tree, values, 0, val_size, level, cur_node);\n    }else{\n        array *cur_level = level;\n        array *nextLevel = NULL;\n        while(cur_level != NULL && index < val_size){\n            if(index % 2 == 0){\n                if(values[index] != -1){\n                    root->\n                }\n            }else{\n                if(values[index] != -1){\n                    \n                }\n                \n                array *tmp = cur_level;\n                cur_level = cur_level->next;\n                if(tmp != NULL){\n                    free(tmp);\n                }\n            }\n            \n            \n            \n            index++;\n        }\n    }\n    \n    \n    return tree;\n}\n\n\n\n\n\nint main() {\n    node *tree = createTree(1);\n    \n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n\nnode* createTree(int value){\n    node *root = NULL;\n    \n    if(value != -1){\n        root = (node*)malloc(sizeof(node));\n        root->data = value;\n        root->right = NULL;\n        root->left = NULL;\n    }\n    \n    return root;\n}\n\nnode* addNode(node *root, int l_value, int r_value, array** front, array** back){\n    if(l_value == -1 && r_value == -1){\n        return root;\n    }\n    if(root == NULL){\n        root = createTree(1);\n    }\n    array *level = *front;\n    if(level == NULL){\n        level = (array*)malloc(sizeof(array));\n        level->next = NULL;\n        level->prev = NULL;\n        level->data = NULL;\n        *back = level;\n    }\n    \n    array *buf = NULL;\n    \n    \n    root->left = createTree(l_value);\n    if(root->left != NULL){\n        if(level->data == NULL){\n            level->data = root->left;\n        }else{\n            buf = (array*)malloc(sizeof(array));\n            buf->data = root->left;\n            buf->prev = level;\n            level->next = buf;\n            level = buf;\n        }\n        \n    }\n    \n    root->right = createTree(r_value);\n    if(root->right != NULL){\n        if(level->data == NULL){\n            level->data = root->right;\n        }else{\n            buf = (array*)malloc(sizeof(array));\n            buf->data = root->right;\n            buf->prev = level;\n            level->next = buf;\n            level = buf;\n        }\n    }\n    \n    *front = level;\n    return root;\n}\n\n\nvoid freeTree(node *tree){\n    if(tree != NULL){\n        if(tree->left != NULL){\n            freeTree(tree->left);\n        }\n        if(tree->right != NULL){\n            freeTree(tree->right);\n        }\n        free(tree);\n    }\n}\n\nvoid inOrderTraversal(node *root) {\n    \n    \n    if(root->left != NULL){\n        inOrder(root->left);\n    }\n    printf(\"%d \", root->data);\n    if(root->right != NULL){\n        inOrder(root->right);\n    }\n}\n\n","offset":1363,"fileType":"c","requestStartTime":1517944909489}}
{"body": {"column":7,"line":15,"wordToComplete":"tem","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint u32FindLongestConsecutiveOccurrence(int as32Array_size, int* as32Array, int s32Number) {\nint i ;\n    int count,tempcount;\n    count=0;\n    tem\n    for(i=0;i<as32Array_size;i++){\n        \n        if(as32Array[i]==s32Number)\n        \n    }\n\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res;\n    \n    int _as32Array_size = 0;\n    int _as32Array_i;\n    scanf(\"%d\\n\", &_as32Array_size);\n    int _as32Array[_as32Array_size];\n    for(_as32Array_i = 0; _as32Array_i < _as32Array_size; _as32Array_i++) {\n        int _as32Array_item;\n        scanf(\"%d\", &_as32Array_item);\n        \n        _as32Array[_as32Array_i] = _as32Array_item;\n    }\n    \n    int _s32Number;\n    scanf(\"%d\", &_s32Number);\n    \n    res = u32FindLongestConsecutiveOccurrence(_as32Array_size, _as32Array, _s32Number);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":325,"fileType":"c","requestStartTime":1517945078050}}
{"body": {"column":16,"line":22,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint* Swap(int A_size, int* A, int B_size, int* B) {\n\n    int i,temp;\n    temp=0;\n    // Add your code here\n    if(A_size!=B_size){\n        printf(\"can't do it becase differnet size \\n\");\n        }\n    if(A_size=B_size){\n        for(i=0;i<A_size;i++){\n            \n           temp=;\n            a[]\n        }\n    }\n    // End\n    \nReturn A;\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int* res;\n    \n    int _A_size = 0;\n    int _A_i;\n    scanf(\"%d\\n\", &_A_size);\n    int _A[_A_size];\n    for(_A_i = 0; _A_i < _A_size; _A_i++) {\n        int _A_item;\n        scanf(\"%d\", &_A_item);\n        \n        _A[_A_i] = _A_item;\n    }\n    \n    \n    int _B_size = 0;\n    int _B_i;\n    scanf(\"%d\\n\", &_B_size);\n    int _B[_B_size];\n    for(_B_i = 0; _B_i < _B_size; _B_i++) {\n        int _B_item;\n        scanf(\"%d\", &_B_item);\n        \n        _B[_B_i] = _B_item;\n    }\n    \n    res = Swap(_A_size, _A, _B_size, _B);\n    int res_i;\n    for(res_i=0; res_i < _A_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":459,"fileType":"c","requestStartTime":1517945937204}}
{"body": {"column":12,"line":22,"wordToComplete":"n","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n * Please store the size of the int array to be returned in result_size pointer. For example,\n * int a[3] = {1, 2, 3};\n * *result_size = 3;\n * return a;\n * \n */\nint a[100];\nint* isPowerOf2(int nums_size, int* nums, int* result_size) {\nint i;\n    for(i=0;i<nums_size;i++){\n        \n        if(n)\n    }\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    int* res;\nint res_size;\n    int nums_size = 0;\n    scanf(\"%d\\n\", &nums_size);\n\n    int nums[nums_size];\n    for(int i = 0; i < nums_size; i++) {\n        int nums_item;\n        scanf(\"%d\", &nums_item);\n        nums[i] = nums_item;\n    }\n\n    res = isPowerOf2(nums_size, nums, &res_size);\n    for (int res_i = 0; res_i < res_size; res_i++) {\n\n        fprintf(f, \"%d\\n\", res[res_i]);\n\n    }\n\n\n    fclose(f);\n    return 0;\n}\n\n","offset":469,"fileType":"c","requestStartTime":1517946490289}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\ni","fileType":"c","line":13,"column":1,"wordToComplete":"i","offset":279}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint f","fileType":"c","line":13,"column":5,"wordToComplete":"f","offset":283}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint d","fileType":"c","line":13,"column":5,"wordToComplete":"d","offset":283}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint dat","fileType":"c","line":13,"column":7,"wordToComplete":"dat","offset":285}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint daty","fileType":"c","line":13,"column":8,"wordToComplete":"daty","offset":286}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint datya","fileType":"c","line":13,"column":9,"wordToComplete":"datya","offset":287}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint data","fileType":"c","line":13,"column":8,"wordToComplete":"data","offset":286}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint data[] \n\np","fileType":"c","line":15,"column":1,"wordToComplete":"p","offset":292}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint data[] \n\npr","fileType":"c","line":15,"column":2,"wordToComplete":"pr","offset":293}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint data[] \n\npro","fileType":"c","line":15,"column":3,"wordToComplete":"pro","offset":294}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint data[] \n\npron","fileType":"c","line":15,"column":4,"wordToComplete":"pron","offset":295}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint data[] \n\npront","fileType":"c","line":15,"column":5,"wordToComplete":"pront","offset":296}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint data[] \n\npri","fileType":"c","line":15,"column":3,"wordToComplete":"pri","offset":294}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint data[] \n\nprin","fileType":"c","line":15,"column":4,"wordToComplete":"prin","offset":295}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n\n\ngiven an array of integer, print out number in frequency order\n\nint data[] = { 3, 5, 6, 8, 8, 5, 3, 3 /*, 34566778*/};\n\n3 – 3, 5 – 2, 8 – 2 ,  6 – 1\n\n\n\nint data[] \n\nprint","fileType":"c","line":15,"column":5,"wordToComplete":"print","offset":296}}
{"body": {"column":17,"line":20,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n * Please store the size of the int array to be returned in result_size pointer. For example,\n * int a[3] = {1, 2, 3};\n * *result_size = 3;\n * return a;\n * \n */\nint* oddNumbers(int l, int r, int* result_size) {\n\n    for (int i=l; i<=r; i++) [\n      if (i%2 != 0) {\n          System.\n      }\n    ]\n\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res_size;\n    int* res;\n    int _l;\n    scanf(\"%d\", &_l);\n    \n    int _r;\n    scanf(\"%d\", &_r);\n    \n    res = oddNumbers(_l, _r, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":457,"fileType":"c","requestStartTime":1517949433716}}
{"body": {"column":21,"line":20,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n * Please store the size of the int array to be returned in result_size pointer. For example,\n * int a[3] = {1, 2, 3};\n * *result_size = 3;\n * return a;\n * \n */\nint* oddNumbers(int l, int r, int* result_size) {\n\n    for (int i=l; i<=r; i++) [\n      if (i%2 != 0) {\n          System.out.\n      }\n    ]\n\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res_size;\n    int* res;\n    int _l;\n    scanf(\"%d\", &_l);\n    \n    int _r;\n    scanf(\"%d\", &_r);\n    \n    res = oddNumbers(_l, _r, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":461,"fileType":"c","requestStartTime":1517949434517}}
{"body": {"column":15,"line":26,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* solve(int a0, int a1, int a2, int b0, int b1, int b2, int *result_size){\n    // Complete this function\nint res=0;\n    static int result[3];\n    int counter=0;\n    if(a0>b0){\n        counter++;\n        result[0]=1;\n    }\n    else{\n         counter++;\n        result[1]=1;\n    }\n if(a1>b1){\n        counter++;\n        result[0]=1;\n    }\n    else if(b1>{\n         counter++;\n        result[1]=1;\n    }\n    if(a1>b1){\n        counter++;\n        result[0]=1;\n    }\n    else{\n         counter++;\n        result[1]=1;\n    }\n    *result_size=counter;\n    return result;\n\n    \n}\n\nint main() {\n    int a0; \n    int a1; \n    int a2; \n    scanf(\"%d %d %d\", &a0, &a1, &a2);\n    int b0; \n    int b1; \n    int b2; \n    scanf(\"%d %d %d\", &b0, &b1, &b2);\n    int result_size;\n    int* result = solve(a0, a1, a2, b0, b1, b2, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n    \n\n    return 0;\n}\n\n\n","offset":496,"fileType":"c","requestStartTime":1517950127723}}
{"body": {"column":9,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar* super_reduced_string(char* s){\n    int dupFlag = 1;\n    if(s.)\n    \n}\n\nint main() {\n    char* s = (char *)malloc(512000 * sizeof(char));\n    scanf(\"%s\", s);\n    int result_size;\n    char* result = super_reduced_string(s);\n    printf(\"%s\\n\", result);\n    return 0;\n}\n\n\n","offset":208,"fileType":"c","requestStartTime":1517950718276}}
{"body": {"column":89,"line":11,"wordToComplete":"nested loop so the x spaces are printed on every line.","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nvoid print_rect(int x, int width, int height){\n    int h;\n    int i;\n    int j;\n    for(i = 0; i < height; i++){ //loop to get program to keep repeating what's happening in the nested loop for as long as \n        for(h = 0; h < x; h++){ // nested loop so the x spaces are printed on every line.\n            printf(\" \");\n        }\n\n        for(j = 0; j < width; j++){\n            printf(\"*\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid print_tri(int x, int base){\n  int h;\n  int i;\n  int j;\n  int k;\n\n  for(i = 0; i < base; i++){\n    for(k = 0; k < x; k++){\n      printf(\" \");\n    }\n    for(h = base - 1; h > 0; h--){\n      if(h > i){\n        printf(\" \");\n      }\n    }\n\n    for (j = 0; j < i; j++){\n      printf(\"* \");\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print_trapezoid(int x, int top, int height){\n  int h;\n  int i;\n  int j;\n  int k;\n\n  for(i = 0; i < height; i++){\n    for(k = 0; k < x; k++){\n      printf(\" \");\n    }\n    for(h = height - 1; h > 0; h--){\n      if(h > i){\n        printf(\" \");\n      }\n    }\n\n    for (j = 0; j < top; j++){\n      printf(\"*\");\n    }\n    printf(\"\\n\");\n    top += 2;\n  }\n}\n\nint main(){\n  int x;\n  scanf(\"%i\", &x);\n  int base;\n  scanf(\"%i\", &base);\n  int width;\n  scanf(\"%i\", &width);\n  int height;\n  scanf(\"%i\", &height);\n  int x2;\n  scanf(\"%i\", &x2);\n  int top;\n  scanf(\"%i\", &top);\n  int height2;\n  scanf(\"%i\", &height2);\n\n  print_tri(x, base);\n  print_rect(x, width, height);\n  print_trapezoid(x2, top, height2);\n\n  return 0;\n}\n\n\n","offset":374,"fileType":"c","requestStartTime":1517950831975}}
{"body": {"column":20,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar* super_reduced_string(char* s){\n    int dupFlag = 1;\n    char prev;\n    int i;\n    if(s.size() == 0){\n        return \"Empty String\";\n    }\n    while(dupFlag == 1){\n        dupFlag = 0;\n        prev = s[0]\n        i = 1;\n        while(i < s.)\n    }\n    \n}\n\nint main() {\n    char* s = (char *)malloc(512000 * sizeof(char));\n    scanf(\"%s\", s);\n    int result_size;\n    char* result = super_reduced_string(s);\n    printf(\"%s\\n\", result);\n    return 0;\n}\n\n\n","offset":386,"fileType":"c","requestStartTime":1517950846495}}
{"body": {"column":142,"line":15,"wordToComplete":"nested loop so that the amount of stars needed for the width of the rectangle is printed on every line.","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nvoid print_rect(int x, int width, int height){\n    int h;\n    int i;\n    int j;\n    for(i = 0; i < height; i++){ //loop to get program to keep repeating what's happening in the nested loop for as long as \n        for(h = 0; h < x; h++){ // nested loop so the x spaces are printed on every line.\n            printf(\" \");\n        }\n\n        for(j = 0; j < width; j++){ // nested loop so that the amount of stars needed for the width of the rectangle is printed on every line.\n            printf(\"*\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid print_tri(int x, int base){\n  int h;\n  int i;\n  int j;\n  int k;\n\n  for(i = 0; i < base; i++){\n    for(k = 0; k < x; k++){\n      printf(\" \");\n    }\n    for(h = base - 1; h > 0; h--){\n      if(h > i){\n        printf(\" \");\n      }\n    }\n\n    for (j = 0; j < i; j++){\n      printf(\"* \");\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print_trapezoid(int x, int top, int height){\n  int h;\n  int i;\n  int j;\n  int k;\n\n  for(i = 0; i < height; i++){\n    for(k = 0; k < x; k++){\n      printf(\" \");\n    }\n    for(h = height - 1; h > 0; h--){\n      if(h > i){\n        printf(\" \");\n      }\n    }\n\n    for (j = 0; j < top; j++){\n      printf(\"*\");\n    }\n    printf(\"\\n\");\n    top += 2;\n  }\n}\n\nint main(){\n  int x;\n  scanf(\"%i\", &x);\n  int base;\n  scanf(\"%i\", &base);\n  int width;\n  scanf(\"%i\", &width);\n  int height;\n  scanf(\"%i\", &height);\n  int x2;\n  scanf(\"%i\", &x2);\n  int top;\n  scanf(\"%i\", &top);\n  int height2;\n  scanf(\"%i\", &height2);\n\n  print_tri(x, base);\n  print_rect(x, width, height);\n  print_trapezoid(x2, top, height2);\n\n  return 0;\n}\n\n\n","offset":553,"fileType":"c","requestStartTime":1517950892924}}
{"body": {"column":9,"line":19,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\n\nstruct Node {\n    Node* parent;\n    char** value;\n    Node** childs;\n};\n\nint findMutationDistance(char* start, char* end, int bank_size, char** bank) {\n    bank.\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    char* _start;\n    _start = (char *)malloc(512000 * sizeof(char));\n    scanf(\"\\n%[^\\n]\",_start);\n    \n    char* _end;\n    _end = (char *)malloc(512000 * sizeof(char));\n    scanf(\"\\n%[^\\n]\",_end);\n    \n    \n    int _bank_size = 0;\n    int _bank_i;\n    scanf(\"%d\\n\", &_bank_size);\n    char* _bank[_bank_size];\n    for(_bank_i = 0; _bank_i < _bank_size; _bank_i++) {\n        char* _bank_item;\n        _bank_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",_bank_item);\n        \n        _bank[_bank_i] = _bank_item;\n    }\n    \n    res = findMutationDistance(_start, _end, _bank_size, _bank);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":341,"fileType":"c","requestStartTime":1517951467382}}
{"body": {"column":33,"line":28,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar* super_reduced_string(char* s){\n    int dupFlag = 1;\n    char prev;\n    int i;\n    if(s.size() == 0){\n        return \"Empty String\";\n    }\n    prev = s[0];\n    i = 1;\n    while(i < s.size()){\n        if(s[i] == prev){\n            s = splice_remove(s, i-1, i+1);\n        }\n    }\n}\n\nchar* splice_remove(char* s, int start, int stop){\n    char* retArr;\n    strncpy ( retArr, s, start );\n    strncpy ( retArr, s[stop], s. ); \n    str3[5] = '\\0';  \n}\n\nint main() {\n    char* s = (char *)malloc(512000 * sizeof(char));\n    scanf(\"%s\", s);\n    int result_size;\n    char* result = super_reduced_string(s);\n    printf(\"%s\\n\", result);\n    return 0;\n}\n\n\n","offset":563,"fileType":"c","requestStartTime":1517951930062}}
{"body": {"column":18,"line":29,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar* super_reduced_string(char* s){\n    int dupFlag = 1;\n    char prev;\n    int i;\n    if(s.size() == 0){\n        return \"Empty String\";\n    }\n    prev = s[0];\n    i = 1;\n    while(i < s.size()){\n        if(s[i] == prev){\n            s = splice_remove(s, i-1, i+1);\n        }\n    }\n}\n\nchar* splice_remove(char* s, int start, int stop){\n    char* retArr;\n    strncpy ( retArr, s, start );\n    strncpy ( retArr, s[stop], s.size()-stop ); \n    retArr[retArr.] = '\\0';  \n}\n\nint main() {\n    char* s = (char *)malloc(512000 * sizeof(char));\n    scanf(\"%s\", s);\n    int result_size;\n    char* result = super_reduced_string(s);\n    printf(\"%s\\n\", result);\n    return 0;\n}\n\n\n","offset":597,"fileType":"c","requestStartTime":1517951947555}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    l\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":20,"column":5,"wordToComplete":"l","offset":290}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    li\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":20,"column":6,"wordToComplete":"li","offset":291}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    lis\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":20,"column":7,"wordToComplete":"lis","offset":292}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    lis\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":20,"column":7,"wordToComplete":"lis","offset":292}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":20,"column":8,"wordToComplete":"list","offset":293}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":20,"column":8,"wordToComplete":"list","offset":293}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *h\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":20,"column":11,"wordToComplete":"h","offset":296}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":20,"column":14,"wordToComplete":"head","offset":299}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *headl\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":20,"column":15,"wordToComplete":"headl","offset":300}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    i\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":21,"column":5,"wordToComplete":"i","offset":306}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n        r\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":9,"wordToComplete":"r","offset":334}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n        re\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":10,"wordToComplete":"re","offset":335}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n        re\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":10,"wordToComplete":"re","offset":335}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n        ret\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":11,"wordToComplete":"ret","offset":336}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n        retu\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":12,"wordToComplete":"retu","offset":337}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n        retur\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":13,"wordToComplete":"retur","offset":338}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n    }\n    w\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":5,"wordToComplete":"w","offset":336}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n    }\n    wh\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":6,"wordToComplete":"wh","offset":337}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n    }\n    whi\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":7,"wordToComplete":"whi","offset":338}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n    }\n    whil\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":8,"wordToComplete":"whil","offset":339}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    if (head == NULL) {\n    }\n    while\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":9,"wordToComplete":"while","offset":340}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    l\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        \n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":21,"column":5,"wordToComplete":"l","offset":306}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *t\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        \n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":21,"column":11,"wordToComplete":"t","offset":312}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHe\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        \n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":21,"column":16,"wordToComplete":"tempHe","offset":317}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHea\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        \n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":21,"column":17,"wordToComplete":"tempHea","offset":318}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        \n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":21,"column":18,"wordToComplete":"tempHead","offset":319}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        h\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":9,"wordToComplete":"h","offset":393}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        he\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":10,"wordToComplete":"he","offset":394}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        he\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":10,"wordToComplete":"he","offset":394}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        hea\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":11,"wordToComplete":"hea","offset":395}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        head\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":12,"wordToComplete":"head","offset":396}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        head = h\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":16,"wordToComplete":"h","offset":400}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        head = he\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":17,"wordToComplete":"he","offset":401}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        head = head\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":19,"wordToComplete":"head","offset":403}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        head = head->n\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":22,"wordToComplete":"n","offset":406}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        head = head->ne\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":23,"wordToComplete":"ne","offset":407}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        head = head->nex\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":24,"wordToComplete":"nex","offset":408}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        head = head->next\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":25,"wordToComplete":"next","offset":409}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        t\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":9,"wordToComplete":"t","offset":393}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHe\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":14,"wordToComplete":"tempHe","offset":398}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHea\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":15,"wordToComplete":"tempHea","offset":399}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":16,"wordToComplete":"tempHead","offset":400}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = h\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":20,"wordToComplete":"h","offset":404}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = he\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":21,"wordToComplete":"he","offset":405}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = hea\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":22,"wordToComplete":"hea","offset":406}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":25,"column":23,"wordToComplete":"head","offset":407}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        t\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":9,"wordToComplete":"t","offset":418}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHe\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":14,"wordToComplete":"tempHe","offset":423}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHea\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":15,"wordToComplete":"tempHea","offset":424}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":16,"wordToComplete":"tempHead","offset":425}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->n\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":19,"wordToComplete":"n","offset":428}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->nex\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":21,"wordToComplete":"nex","offset":430}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":22,"wordToComplete":"next","offset":431}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = h\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":26,"wordToComplete":"h","offset":435}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = he\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":27,"wordToComplete":"he","offset":436}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = he\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":27,"wordToComplete":"he","offset":436}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = hea\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":28,"wordToComplete":"hea","offset":437}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":29,"wordToComplete":"head","offset":438}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->n\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":32,"wordToComplete":"n","offset":441}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->ne\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":33,"wordToComplete":"ne","offset":442}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->nex\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":34,"wordToComplete":"nex","offset":443}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":26,"column":35,"wordToComplete":"next","offset":444}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\ni","fileType":"c","line":4,"column":1,"wordToComplete":"i","offset":145}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nin","fileType":"c","line":4,"column":2,"wordToComplete":"in","offset":146}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nin","fileType":"c","line":4,"column":2,"wordToComplete":"in","offset":146}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint","fileType":"c","line":4,"column":3,"wordToComplete":"int","offset":147}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        t\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":9,"wordToComplete":"t","offset":455}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        te\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":10,"wordToComplete":"te","offset":456}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tem\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":11,"wordToComplete":"tem","offset":457}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        temp\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":12,"wordToComplete":"temp","offset":458}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        temp\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":12,"wordToComplete":"temp","offset":458}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHe\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":14,"wordToComplete":"tempHe","offset":460}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHea\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":15,"wordToComplete":"tempHea","offset":461}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":16,"wordToComplete":"tempHead","offset":462}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = t\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":20,"wordToComplete":"t","offset":466}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHe\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":25,"wordToComplete":"tempHe","offset":471}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHea\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":26,"wordToComplete":"tempHea","offset":472}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":27,"wordToComplete":"tempHead","offset":473}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint c","fileType":"c","line":4,"column":5,"wordToComplete":"c","offset":149}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->n\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":30,"wordToComplete":"n","offset":476}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->ne\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":31,"wordToComplete":"ne","offset":477}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->nex\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":32,"wordToComplete":"nex","offset":478}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->next\n        head = head->next;\n    }\n    \n}\n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":33,"wordToComplete":"next","offset":479}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint s","fileType":"c","line":4,"column":5,"wordToComplete":"s","offset":149}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint st","fileType":"c","line":4,"column":6,"wordToComplete":"st","offset":150}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint str","fileType":"c","line":4,"column":7,"wordToComplete":"str","offset":151}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strl","fileType":"c","line":4,"column":8,"wordToComplete":"strl","offset":152}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strle","fileType":"c","line":4,"column":9,"wordToComplete":"strle","offset":153}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen","fileType":"c","line":4,"column":10,"wordToComplete":"strlen","offset":154}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    f\n}","fileType":"c","line":6,"column":5,"wordToComplete":"f","offset":176}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    fo\n}","fileType":"c","line":6,"column":6,"wordToComplete":"fo","offset":177}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    fo\n}","fileType":"c","line":6,"column":6,"wordToComplete":"fo","offset":177}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    for\n}","fileType":"c","line":6,"column":7,"wordToComplete":"for","offset":178}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    i\n    for(i=0; array[i]=='\\0'; i++);\n    \n}","fileType":"c","line":6,"column":5,"wordToComplete":"i","offset":176}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    in\n    for(i=0; array[i]=='\\0'; i++);\n    \n}","fileType":"c","line":6,"column":6,"wordToComplete":"in","offset":177}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    in\n    for(i=0; array[i]=='\\0'; i++);\n    \n}","fileType":"c","line":6,"column":6,"wordToComplete":"in","offset":177}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int\n    for(i=0; array[i]=='\\0'; i++);\n    \n}","fileType":"c","line":6,"column":7,"wordToComplete":"int","offset":178}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i\n    for(i=0; array[i]=='\\0'; i++);\n    \n}","fileType":"c","line":6,"column":9,"wordToComplete":"i","offset":180}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]=='\\0'; i++)\n    ;\n    r\n    \n}","fileType":"c","line":9,"column":5,"wordToComplete":"r","offset":226}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]=='\\0'; i++)\n    ;\n    re\n    \n}","fileType":"c","line":9,"column":6,"wordToComplete":"re","offset":227}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]=='\\0'; i++)\n    ;\n    re\n    \n}","fileType":"c","line":9,"column":6,"wordToComplete":"re","offset":227}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]=='\\0'; i++)\n    ;\n    ret\n    \n}","fileType":"c","line":9,"column":7,"wordToComplete":"ret","offset":228}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]=='\\0'; i++)\n    ;\n    ret\n    \n}","fileType":"c","line":9,"column":7,"wordToComplete":"ret","offset":228}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]=='\\0'; i++)\n    ;\n    retu\n    \n}","fileType":"c","line":9,"column":8,"wordToComplete":"retu","offset":229}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]=='\\0'; i++)\n    ;\n    retu\n    \n}","fileType":"c","line":9,"column":8,"wordToComplete":"retu","offset":229}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]=='\\0'; i++)\n    ;\n    retur\n    \n}","fileType":"c","line":9,"column":9,"wordToComplete":"retur","offset":230}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]=='\\0'; i++)\n    ;\n    return i\n    \n}","fileType":"c","line":9,"column":12,"wordToComplete":"i","offset":233}}
{"body": {"column":24,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar* splice_remove(char* s, int start, int stop){\n    char* retArr;\n    strncpy ( retArr, s., start );\n    strncpy ( retArr, s[stop], strlen(s)-stop ); \n    retArr[strlen(retArr)] = '\\0';\n    printf(\"%s\\n\", retArr);\n    return retArr;\n}\n\nchar* super_reduced_string(char* s){\n    int dupFlag = 1;\n    char prev;\n    int i;\n    if(strlen(s) == 0){\n        return \"Empty String\";\n    }\n    prev = s[0];\n    i = 1;\n    while(i < strlen(s)){\n        if(s[i] == prev){\n            s = splice_remove(s, i-1, i+1);\n        }\n    }\n    return s;\n}\n\nint main() {\n    char* s = (char *)malloc(512000 * sizeof(char));\n    scanf(\"%s\", s);\n    int result_size;\n    char* result = super_reduced_string(s);\n    printf(\"%s\\n\", result);\n    return 0;\n}\n\n\n","offset":234,"fileType":"c","requestStartTime":1517952454765}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nv","fileType":"c","line":14,"column":1,"wordToComplete":"v","offset":296}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid s","fileType":"c","line":14,"column":6,"wordToComplete":"s","offset":301}}
{"body": {"column":24,"line":12,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar* splice_remove(char* s, int start, int stop){\n    char* retArr;\n    strncpy ( retArr, s.start(), start );\n    strncpy ( retArr, s., strlen(s)-stop ); \n    retArr[strlen(retArr)] = '\\0';\n    printf(\"%s\\n\", retArr);\n    return retArr;\n}\n\nchar* super_reduced_string(char* s){\n    int dupFlag = 1;\n    char prev;\n    int i;\n    if(strlen(s) == 0){\n        return \"Empty String\";\n    }\n    prev = s[0];\n    i = 1;\n    while(i < strlen(s)){\n        if(s[i] == prev){\n            s = splice_remove(s, i-1, i+1);\n        }\n    }\n    return s;\n}\n\nint main() {\n    char* s = (char *)malloc(512000 * sizeof(char));\n    scanf(\"%s\", s);\n    int result_size;\n    char* result = super_reduced_string(s);\n    printf(\"%s\\n\", result);\n    return 0;\n}\n\n\n","offset":276,"fileType":"c","requestStartTime":1517952460195}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid st","fileType":"c","line":14,"column":7,"wordToComplete":"st","offset":302}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid str","fileType":"c","line":14,"column":8,"wordToComplete":"str","offset":303}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strr","fileType":"c","line":14,"column":9,"wordToComplete":"strr","offset":304}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strre","fileType":"c","line":14,"column":10,"wordToComplete":"strre","offset":305}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev","fileType":"c","line":14,"column":11,"wordToComplete":"strrev","offset":306}}
{"body": {"column":24,"line":12,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nchar* splice_remove(char* s, int start, int stop){\n    char* retArr;\n    strncpy ( retArr, s.start(), start );\n    strncpy ( retArr, s., strlen(s)-stop ); \n    retArr[strlen(retArr)] = '\\0';\n    printf(\"%s\\n\", retArr);\n    return retArr;\n}\n\nchar* super_reduced_string(char* s){\n    int dupFlag = 1;\n    char prev;\n    int i;\n    if(strlen(s) == 0){\n        return \"Empty String\";\n    }\n    prev = s[0];\n    i = 1;\n    while(i < strlen(s)){\n        if(s[i] == prev){\n            s = splice_remove(s, i-1, i+1);\n        }\n    }\n    return s;\n}\n\nint main() {\n    char* s = (char *)malloc(512000 * sizeof(char));\n    scanf(\"%s\", s);\n    int result_size;\n    char* result = super_reduced_string(s);\n    printf(\"%s\\n\", result);\n    return 0;\n}\n\n\n","offset":276,"fileType":"c","requestStartTime":1517952462507}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    i\n}","fileType":"c","line":16,"column":5,"wordToComplete":"i","offset":328}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int l\n}","fileType":"c","line":16,"column":9,"wordToComplete":"l","offset":332}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int le\n}","fileType":"c","line":16,"column":10,"wordToComplete":"le","offset":333}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len\n}","fileType":"c","line":16,"column":11,"wordToComplete":"len","offset":334}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = s\n}","fileType":"c","line":16,"column":15,"wordToComplete":"s","offset":338}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    l\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":5,"wordToComplete":"l","offset":326}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    \n    f\n}","fileType":"c","line":18,"column":5,"wordToComplete":"f","offset":362}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    \n    fo\n}","fileType":"c","line":18,"column":6,"wordToComplete":"fo","offset":363}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    \n    fo\n}","fileType":"c","line":18,"column":6,"wordToComplete":"fo","offset":363}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    \n    for\n}","fileType":"c","line":18,"column":7,"wordToComplete":"for","offset":364}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *c\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":11,"wordToComplete":"c","offset":332}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *curr\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":14,"wordToComplete":"curr","offset":335}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    i\n    for()\n}","fileType":"c","line":17,"column":5,"wordToComplete":"i","offset":357}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    in\n    for()\n}","fileType":"c","line":17,"column":6,"wordToComplete":"in","offset":358}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currH\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":15,"wordToComplete":"currH","offset":336}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHe\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":16,"wordToComplete":"currHe","offset":337}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHea\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":17,"wordToComplete":"currHea","offset":338}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i\n    for()\n}","fileType":"c","line":17,"column":9,"wordToComplete":"i","offset":361}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead\n    if (head == NULL) {\n    }\n    while (head->next != NULL) {\n        tempHead = head;\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":22,"column":18,"wordToComplete":"currHead","offset":339}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        c\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":9,"wordToComplete":"c","offset":452}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        curr\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":12,"wordToComplete":"curr","offset":455}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currH\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":13,"wordToComplete":"currH","offset":456}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHe\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":14,"wordToComplete":"currHe","offset":457}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHea\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":15,"wordToComplete":"currHea","offset":458}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":16,"wordToComplete":"currHead","offset":459}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->n\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":19,"wordToComplete":"n","offset":462}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->ne\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":20,"wordToComplete":"ne","offset":463}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->nex\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":21,"wordToComplete":"nex","offset":464}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":22,"wordToComplete":"next","offset":465}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = t\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":26,"wordToComplete":"t","offset":469}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = te\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":27,"wordToComplete":"te","offset":470}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tem\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":28,"wordToComplete":"tem","offset":471}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = temp\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":29,"wordToComplete":"temp","offset":472}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = temp\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":29,"wordToComplete":"temp","offset":472}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHe\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":31,"wordToComplete":"tempHe","offset":474}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHea\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":32,"wordToComplete":"tempHea","offset":475}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":33,"wordToComplete":"tempHead","offset":476}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->n\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":36,"wordToComplete":"n","offset":479}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->ne\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":37,"wordToComplete":"ne","offset":480}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->nex\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":38,"wordToComplete":"nex","offset":481}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":27,"column":39,"wordToComplete":"next","offset":482}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        t\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":28,"column":9,"wordToComplete":"t","offset":493}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHe\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":28,"column":14,"wordToComplete":"tempHe","offset":498}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHea\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":28,"column":15,"wordToComplete":"tempHea","offset":499}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":28,"column":16,"wordToComplete":"tempHead","offset":500}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *h\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":28,"column":21,"wordToComplete":"h","offset":505}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *he\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":28,"column":22,"wordToComplete":"he","offset":506}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":28,"column":24,"wordToComplete":"head","offset":508}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        t\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":9,"wordToComplete":"t","offset":519}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempH\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":13,"wordToComplete":"tempH","offset":523}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHe\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":14,"wordToComplete":"tempHe","offset":524}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHea\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":15,"wordToComplete":"tempHea","offset":525}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":16,"wordToComplete":"tempHead","offset":526}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->n\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":19,"wordToComplete":"n","offset":529}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->ne\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":20,"wordToComplete":"ne","offset":530}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->nex\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":21,"wordToComplete":"nex","offset":531}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":22,"wordToComplete":"next","offset":532}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = t\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":26,"wordToComplete":"t","offset":536}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHe\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":31,"wordToComplete":"tempHe","offset":541}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHea\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":32,"wordToComplete":"tempHea","offset":542}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":29,"column":33,"wordToComplete":"tempHead","offset":543}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *h\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":30,"column":10,"wordToComplete":"h","offset":555}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":30,"column":13,"wordToComplete":"head","offset":558}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    c\n    for(;i<len/2; i++, j--)\n    {\n        \n    }\n}","fileType":"c","line":18,"column":5,"wordToComplete":"c","offset":377}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    ch\n    for(;i<len/2; i++, j--)\n    {\n        \n    }\n}","fileType":"c","line":18,"column":6,"wordToComplete":"ch","offset":378}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    ch\n    for(;i<len/2; i++, j--)\n    {\n        \n    }\n}","fileType":"c","line":18,"column":6,"wordToComplete":"ch","offset":378}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = t\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":30,"column":17,"wordToComplete":"t","offset":562}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char t\n    for(;i<len/2; i++, j--)\n    {\n        \n    }\n}","fileType":"c","line":18,"column":10,"wordToComplete":"t","offset":382}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char te\n    for(;i<len/2; i++, j--)\n    {\n        \n    }\n}","fileType":"c","line":18,"column":11,"wordToComplete":"te","offset":383}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char tem\n    for(;i<len/2; i++, j--)\n    {\n        \n    }\n}","fileType":"c","line":18,"column":12,"wordToComplete":"tem","offset":384}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHJe\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":30,"column":23,"wordToComplete":"tempHJe","offset":568}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp\n    for(;i<len/2; i++, j--)\n    {\n        \n    }\n}","fileType":"c","line":18,"column":13,"wordToComplete":"temp","offset":385}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHJea\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":30,"column":24,"wordToComplete":"tempHJea","offset":569}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHe\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":30,"column":22,"wordToComplete":"tempHe","offset":567}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHea\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":30,"column":23,"wordToComplete":"tempHea","offset":568}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead\n        tempHead->next = head->next;\n        tempHead = tempHead->next;\n        head = head->next;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":30,"column":24,"wordToComplete":"tempHead","offset":569}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        t\n    }\n}","fileType":"c","line":21,"column":9,"wordToComplete":"t","offset":430}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        te\n    }\n}","fileType":"c","line":21,"column":10,"wordToComplete":"te","offset":431}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        te\n    }\n}","fileType":"c","line":21,"column":10,"wordToComplete":"te","offset":431}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = a\n    }\n}","fileType":"c","line":21,"column":16,"wordToComplete":"a","offset":437}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    t\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":5,"wordToComplete":"t","offset":346}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        a\n    }\n}","fileType":"c","line":22,"column":9,"wordToComplete":"a","offset":455}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHe\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":10,"wordToComplete":"tempHe","offset":351}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHea\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":11,"wordToComplete":"tempHea","offset":352}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":12,"wordToComplete":"tempHead","offset":353}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = h\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":16,"wordToComplete":"h","offset":357}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":23,"column":19,"wordToComplete":"head","offset":360}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    c\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":5,"wordToComplete":"c","offset":367}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    cu\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":6,"wordToComplete":"cu","offset":368}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    curr\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":8,"wordToComplete":"curr","offset":370}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currH\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":9,"wordToComplete":"currH","offset":371}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = a\n    }\n}","fileType":"c","line":22,"column":20,"wordToComplete":"a","offset":466}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHe\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":10,"wordToComplete":"currHe","offset":372}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHea\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":11,"wordToComplete":"currHea","offset":373}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":12,"wordToComplete":"currHead","offset":374}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = h\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":16,"wordToComplete":"h","offset":378}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = he\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":17,"wordToComplete":"he","offset":379}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = hea\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":18,"wordToComplete":"hea","offset":380}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":24,"column":19,"wordToComplete":"head","offset":381}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        a\n    }\n}","fileType":"c","line":23,"column":9,"wordToComplete":"a","offset":484}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        a\n    }\n}","fileType":"c","line":23,"column":9,"wordToComplete":"a","offset":484}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = t\n    }\n}","fileType":"c","line":23,"column":20,"wordToComplete":"t","offset":495}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = te\n    }\n}","fileType":"c","line":23,"column":21,"wordToComplete":"te","offset":496}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = te\n    }\n}","fileType":"c","line":23,"column":21,"wordToComplete":"te","offset":496}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = tem\n    }\n}","fileType":"c","line":23,"column":22,"wordToComplete":"tem","offset":497}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = tem\n    }\n}","fileType":"c","line":23,"column":22,"wordToComplete":"tem","offset":497}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp\n    }\n}","fileType":"c","line":23,"column":23,"wordToComplete":"temp","offset":498}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    r\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":34,"column":5,"wordToComplete":"r","offset":624}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    i\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":18,"column":5,"wordToComplete":"i","offset":377}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":18,"column":6,"wordToComplete":"if","offset":378}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        r\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":9,"wordToComplete":"r","offset":398}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        re\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":10,"wordToComplete":"re","offset":399}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        re\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":10,"wordToComplete":"re","offset":399}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        ret\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":11,"wordToComplete":"ret","offset":400}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        ret\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":11,"wordToComplete":"ret","offset":400}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        retu\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":12,"wordToComplete":"retu","offset":401}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        retu\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":12,"wordToComplete":"retu","offset":401}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        retur\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":13,"wordToComplete":"retur","offset":402}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        retur\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":13,"wordToComplete":"retur","offset":402}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n// implement strlen\n\nint strlen(char array[])\n{\n    int i=0;\n    for(; array[i]!='\\0'; i++)\n    ;\n    return i;\n}\n\n// implement strrev (so, abc becomes cba)\n// abcd   dcba\nvoid strrev(char array[])\n{\n    int len = strlen(array);\n    int i=0, j=len;\n    if(len == 0)\n        return\n    char temp;\n    for(;i<len/2; i++, j--)\n    {\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","fileType":"c","line":19,"column":14,"wordToComplete":"return","offset":403}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    if (head == NULL) {\n    }\n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        tempHead = *head;\n        *h\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":31,"column":10,"wordToComplete":"h","offset":562}}
{"body": {"column":16,"line":1,"wordToComplete":"include <stdio.","code":"\n#include <stdio.\n\n","offset":18,"fileType":"c","requestStartTime":1517953030959}}
{"body": {"column":16,"line":2,"wordToComplete":"include stdlib.","code":"\n#include <stdio.h>\n#include stdlib.\n\n","offset":37,"fileType":"c","requestStartTime":1517953038494}}
{"body": {"column":17,"line":2,"wordToComplete":"include <stdlib.","code":"\n#include <stdio.h>\n#include <stdlib.\n\n","offset":38,"fileType":"c","requestStartTime":1517953043653}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        t\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":9,"wordToComplete":"t","offset":561}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHe\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":14,"wordToComplete":"tempHe","offset":566}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHea\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":15,"wordToComplete":"tempHea","offset":567}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":16,"wordToComplete":"tempHead","offset":568}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->n\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":19,"wordToComplete":"n","offset":571}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->ne\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":20,"wordToComplete":"ne","offset":572}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->nex\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":21,"wordToComplete":"nex","offset":573}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":22,"wordToComplete":"next","offset":574}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next = c\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":26,"wordToComplete":"c","offset":578}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next = curr\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":29,"wordToComplete":"curr","offset":581}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->n\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":19,"wordToComplete":"n","offset":571}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->nex\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":21,"wordToComplete":"nex","offset":573}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":22,"wordToComplete":"next","offset":574}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next = c\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":26,"wordToComplete":"c","offset":578}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next = curr\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":29,"wordToComplete":"curr","offset":581}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next = currH\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":30,"wordToComplete":"currH","offset":582}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next = currHe\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":31,"wordToComplete":"currHe","offset":583}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next = currHea\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":32,"wordToComplete":"currHea","offset":584}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct List\n{\n    struct List*    next;\n    int    payload;\n} List;\n\n/*\n * Complete the function below.\n */\n    \nvoid\nlist_reverse(List* list, List** reversed)\n{\n    // TODO implement this\n    // 1 2 3\n    // ^\n    // 2 1 3 \n    // 3 2 1\n    list *head;\n    list *tempHead;\n    list *currHead;\n    tempHead = head;\n    currHead = head;\n    \n    while (currHead->next != NULL) {\n        tempHead = currHead->next;\n        currHead->next = tempHead->next;\n        //tempHead = *head;\n        tempHead->next = currHead\n        tempHead->next = tempHead;\n        *head = tempHead;\n    }\n    \n}\n\n\n// \n\n/* The code below is framework / test harness.  You need not read or modify any of the code.\n*/\n\nList*\nlist_from_file(FILE* f)\n{\n    if (f == NULL)\n    {\n        return NULL;\n    }\n    List* head = NULL;\n    List* tail = NULL;\n    unsigned int x;\n    while (fscanf(f, \"%d\", &x) == 1)\n    {\n        if (head == NULL)\n        {\n            head = malloc(sizeof(List));\n            head->payload = x;\n            head->next = NULL;\n            tail = head;\n        }\n        else\n        {\n            List* l = malloc(sizeof(List));\n            l->payload = x;\n            l->next = NULL;\n            tail->next = l;\n            tail = l;\n        }\n    }\n    return head;\n}\n\nvoid\nlist_to_file(const List* list, FILE* f)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n    for ( ; list; list = list->next)\n    {\n        fprintf(f, \"%d \", list->payload);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    List* reversed = NULL;\n    List* list = list_from_file(stdin);\n    list_reverse(list, &reversed);\n    list_to_file(reversed, stdout);\n    return 0;\n}","fileType":"c","line":32,"column":33,"wordToComplete":"currHead","offset":585}}
{"body": {"column":58,"line":52,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 input chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // letters are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97). )\n                }\n            }\n        }\n    }\n    \n    \n    \n    \n    return 0;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":1268,"fileType":"c","requestStartTime":1517953602481}}
{"body": {"column":11,"line":35,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 input chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\nint findMax (int i, int j){\n    if (i >)\n    \n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // letters are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    int max = 0;\n    \n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        \n                    }\n                }\n            }\n        }\n    }\n    \n    \n    \n    \n    return 0;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":777,"fileType":"c","requestStartTime":1517953787454}}
{"body": {"column":42,"line":10,"wordToComplete":"comments to hopefully make it readable.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations\n    // of substrings of s using 2 unique chars,\n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":244,"fileType":"c","requestStartTime":1517954223459}}
{"body": {"column":48,"line":11,"wordToComplete":"The time complexity of this solution is O(n).","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n// The time complexity of this solution is O(n).\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":293,"fileType":"c","requestStartTime":1517954569803}}
{"body": {"column":1,"line":13,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n// The time complexity of this solution is O(n). We iterate through\n// the string once to get all the unique chars present in s, then\n.\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":380,"fileType":"c","requestStartTime":1517954606441}}
{"body": {"column":2,"line":13,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n// The time complexity of this solution is O(n). We iterate through\n// the string once to get all the unique chars present in s, then\n..\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":381,"fileType":"c","requestStartTime":1517954606596}}
{"body": {"column":77,"line":14,"wordToComplete":"combinations of the alphabet (if s contains every letter of the alphabet).","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n// The time complexity of this solution is O(n). We iterate through\n// the string once to get all the unique chars present in s, then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// iterating through \n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":527,"fileType":"c","requestStartTime":1517954721063}}
{"body": {"column":16,"line":18,"wordToComplete":"form is O(n).","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n// The time complexity of this solution is O(n). We iterate through\n// the string once to get all the unique chars present in s, then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// On each iteration, we at most iterate through the n chars of s twice,\n// if s already is a string with only 2 distinct chars, such that\n// the total time complexity is O(325(2n) + n) = O(651n) which in asymptotic\n// form is O(n).\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":760,"fileType":"c","requestStartTime":1517954823392}}
{"body": {"column":17,"line":18,"wordToComplete":"form is O(n)..","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n// The time complexity of this solution is O(n). We iterate through\n// the string once to get all the unique chars present in s, then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// On each iteration, we at most iterate through the n chars of s twice,\n// if s already is a string with only 2 distinct chars, such that\n// the total time complexity is O(325(2n) + n) = O(651n) which in asymptotic\n// form is O(n)..\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":761,"fileType":"c","requestStartTime":1517954823497}}
{"body": {"column":60,"line":13,"wordToComplete":"the string once to get all the unique chars present in s. then,","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// On each iteration, we at most iterate through the n chars of s twice,\n// if s already is a string with only 2 distinct chars, such that\n// the total time complexity is O(325(2n) + n) = O(651n) which in asymptotic\n// form is O(n).\n// \n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":380,"fileType":"c","requestStartTime":1517954854199}}
{"body": {"column":49,"line":20,"wordToComplete":"The space complexity of this solution is O(n).","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n).\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":748,"fileType":"c","requestStartTime":1517955059651}}
{"body": {"column":49,"line":22,"wordToComplete":"in twoCharacters() after obtaining its length.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n). We at most keep 2\n// copies of s in memory at any time, since we free the temp string\n// in twoCharacters() after obtaining its length.\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":884,"fileType":"c","requestStartTime":1517955115269}}
{"body": {"column":30,"line":23,"wordToComplete":"complexity is O(2n) = O(n).","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n). We at most keep 2\n// copies of s in memory at any time, since we free the temp string\n// in twoCharacters() after obtaining its length. Thus total space \n// complexity is O(2n) = O(n).\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    for(int i = 0; i < strlen(s) - 1; ++i){\n        if(s[i] == s[i+1]){\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){\n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":933,"fileType":"c","requestStartTime":1517955129459}}
{"body": {"column":19,"line":23,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid insertionSort1(int n, int arr_size, int* arr) {\n    int i;\n    int rightMost = arr[arr_size - 1];\n    arr[arr_size - 1] = arr[arr_size - 2];\n    for (i = arr_size - 2; i >= 0; i--) {\n        (if i > n) {\n            arr[i - 1] = arr[i];\n        }\n        else {\n            arr[i] = n;\n        }\n        \n        //print\n        for (i = 0; i < arr_size; i++) {\n            System.\n        }\n        \n    }\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    insertionSort1(n, n, arr);\n    return 0;\n}\n\n\n","offset":527,"fileType":"c","requestStartTime":1517955339009}}
{"body": {"column":5,"line":44,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n). We keep at most 2\n// copies of s in memory at any time, since we free the temp string\n// in twoCharacters() after obtaining its length. Thus total space \n// complexity is O(2n) which in asymptotic form is O(n).\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    \n    // Boolean array to track which unique chars\n    // are present in s\n    bool arr[26];\n    \n    for(int i = 0; i < strlen(s) - 1; ++i){\n        // Check the chars are alternating\n        if(s[i] == s[i+1]){\n            return false;\n        }\n        // Add unique chars to arr\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }        \n    }\n    \n    .\n    int count = 0;\n    for (int i = 0; i < 26; ++i){\n        if(arr[i]){\n            ++count;\n        }\n    }\n    if(count != 2)\n    {\n        return false;\n    }\n    \n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){                 \n                    char* temp = buildString((char)(i+97), (char)(j+97), s);                    \n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":1426,"fileType":"c","requestStartTime":1517956050500}}
{"body": {"column":6,"line":44,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n). We keep at most 2\n// copies of s in memory at any time, since we free the temp string\n// in twoCharacters() after obtaining its length. Thus total space \n// complexity is O(2n) which in asymptotic form is O(n).\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    \n    // Boolean array to track which unique chars\n    // are present in s\n    bool arr[26];\n    \n    for(int i = 0; i < strlen(s) - 1; ++i){\n        // Check the chars are alternating\n        if(s[i] == s[i+1]){\n            return false;\n        }\n        // Add unique chars to arr\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }        \n    }\n    \n    ..\n    int count = 0;\n    for (int i = 0; i < 26; ++i){\n        if(arr[i]){\n            ++count;\n        }\n    }\n    if(count != 2)\n    {\n        return false;\n    }\n    \n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){                 \n                    char* temp = buildString((char)(i+97), (char)(j+97), s);                    \n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":1427,"fileType":"c","requestStartTime":1517956050617}}
{"body": {"column":20,"line":45,"wordToComplete":"return false.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n). We keep at most 2\n// copies of s in memory at any time, since we free the temp string\n// in twoCharacters() after obtaining its length. Thus total space \n// complexity is O(2n) which in asymptotic form is O(n).\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    \n    // Boolean array to track which unique chars\n    // are present in s\n    bool arr[26];\n    \n    for(int i = 0; i < strlen(s) - 1; ++i){\n        // Check the chars are alternating\n        if(s[i] == s[i+1]){\n            return false;\n        }\n        // Add unique chars to arr\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }        \n    }\n    \n    // If s is not composed of exactly 2 unique chars,\n    // return false.\n    int count = 0;\n    for (int i = 0; i < 26; ++i){\n        if(arr[i]){\n            ++count;\n        }\n    }\n    if(count != 2)\n    {\n        return false;\n    }\n    \n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc(strlen(s)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if(!arr[(int)(s[i]-97)]){\n            arr[(int)(s[i]-97)] = true;\n        }\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){                 \n                    char* temp = buildString((char)(i+97), (char)(j+97), s);                    \n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":1496,"fileType":"c","requestStartTime":1517956067162}}
{"body": {"column":9,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid insertionSort1(int n, int arr_size, int* arr) {\n    int i;\n    int j;\n    int rightMost = arr[arr_size - 1];\n    int incr;\n    for (i = 1; i < arr_size; i++) {\n        \n        //if (arr[i] > rightMost) {\n        //    incr = i + 1;\n        //    arr[incr] = arr[i];\n        //}\n        .else if (arr[i] < rightMost) {\n            incr = i + 1;\n            arr[incr] = rightMost;\n        }\n        \n        \n        \n        //print\n        for (j = 0; j < arr_size; j++) {\n            printf(\"%d \", arr[j]);\n        }\n        printf(\"\\n\");\n        \n    }  \n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    insertionSort1(n, n, arr);\n    return 0;\n}\n\n\n","offset":434,"fileType":"c","requestStartTime":1517957513966}}
{"body": {"column":10,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid insertionSort1(int n, int arr_size, int* arr) {\n    int i;\n    int j;\n    int rightMost = arr[arr_size - 1];\n    int incr;\n    for (i = 1; i < arr_size; i++) {\n        \n        //if (arr[i] > rightMost) {\n        //    incr = i + 1;\n        //    arr[incr] = arr[i];\n        //}\n        ..else if (arr[i] < rightMost) {\n            incr = i + 1;\n            arr[incr] = rightMost;\n        }\n        \n        \n        \n        //print\n        for (j = 0; j < arr_size; j++) {\n            printf(\"%d \", arr[j]);\n        }\n        printf(\"\\n\");\n        \n    }  \n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    insertionSort1(n, n, arr);\n    return 0;\n}\n\n\n","offset":435,"fileType":"c","requestStartTime":1517957514167}}
{"body": {"column":15,"line":110,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n). We keep at most 2\n// copies of s in memory at any time, since we free the temp string\n// in twoCharacters() after obtaining its length. Thus total space \n// complexity is O(2n) which in asymptotic form is O(n).\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    \n    // Boolean array to track which unique chars\n    // are present in s\n    bool arr[26];\n    for(int i = 0; i < 26; ++i){\n        arr[i] = false;\n    }\n    \n    for(int i = 0; i < strlen(s) - 1; ++i){\n        // Check the chars are alternating\n        if(s[i] == s[i+1]){\n            return false;\n        }\n        // Mark arr[i] true if the ith letter\n        // of the alphabet is in s                    \n        arr[(int)(s[i]-97)] = true;\n        arr[(int)(s[i+1]-97)] = true;               \n    }\n    \n    // If s is not composed of exactly 2 unique chars,\n    // string is not valid\n    int count = 0;\n    for (int i = 0; i < 26; ++i){\n        if(arr[i]){\n            ++count;\n        }\n    }\n    if(count != 2)\n    {\n        return false;\n    }\n    \n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc((strlen(s)+1)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    for(int i = 0; i < 26; ++i){\n        arr[i] = false;\n    }\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        arr[(int)(s[i]-97)] = true;\n    }\n    \n    int count = 0;\n    for(int i = 0; i < 26; ++i){\n        if(arr[i]){\n            ++count;\n        }\n    }\n    \n    if (count >)\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){                 \n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":2838,"fileType":"c","requestStartTime":1517958944534}}
{"body": {"column":10,"line":51,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    frame.sync[2] = {0};\n    frame.sequence = 0;\n    frame.timestamp = 0;\n    frame.\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    \n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":2038,"fileType":"c","requestStartTime":1517959119636}}
{"body": {"column":27,"line":51,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    frame.sync[2] = {0};\n    frame.sequence = 0;\n    frame.timestamp = 0;\n    frame.stream_context_t.\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    \n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":2055,"fileType":"c","requestStartTime":1517959127996}}
{"body": {"column":21,"line":48,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    stream_context_t.\n    frame.sync[2] = {0};\n    frame.sequence = 0;\n    frame.timestamp = 0;\n    frame.stream_context_t.\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    \n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":1975,"fileType":"c","requestStartTime":1517959141699}}
{"body": {"column":28,"line":48,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    context.message_frame_t.\n    frame.sync[2] = {0};\n    frame.sequence = 0;\n    frame.timestamp = 0;\n    frame.stream_context_t.\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    \n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":1982,"fileType":"c","requestStartTime":1517959258995}}
{"body": {"column":12,"line":50,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    context.frame.sync[2]={0};\n    context.frame.sequence = 0;\n    context.frame.timestamp = 0;\n    frame.stream_context_t.\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    \n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":2029,"fileType":"c","requestStartTime":1517959287395}}
{"body": {"column":18,"line":48,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    context.frame.\n    context.frame.sequence = 0;\n    context.frame.timestamp = 0;\n    context.frame.stream_context_t.\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    \n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":1972,"fileType":"c","requestStartTime":1517959311210}}
{"body": {"column":23,"line":100,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n). We keep at most 2\n// copies of s in memory at any time, since we free the temp string\n// in twoCharacters() after obtaining its length. Thus total space \n// complexity is O(2n) which in asymptotic form is O(n).\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    \n    // Boolean array to track which unique chars\n    // are present in s\n    bool arr[26];\n    for(int i = 0; i < 26; ++i){\n        arr[i] = false;\n    }\n    \n    for(int i = 0; i < strlen(s) - 1; ++i){\n        // Check the chars are alternating\n        if(s[i] == s[i+1]){\n            return false;\n        }\n        // Mark arr[i] true if the ith letter\n        // of the alphabet is in s                    \n        arr[(int)(s[i]-97)] = true;\n        arr[(int)(s[i+1]-97)] = true;               \n    }\n    \n    // If s is not composed of exactly 2 unique chars,\n    // string is not valid\n    int count = 0;\n    for (int i = 0; i < 26; ++i){\n        if(arr[i]){\n            ++count;\n        }\n    }\n    if(count != 2)\n    {\n        return false;\n    }\n    \n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    \n    char* newString = (char*) malloc((strlen(s)+1)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    for(int i = 0; i < 26; ++i){\n        arr[i] = false;\n    }\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        assert(s[i]-97>)\n        arr[(int)(s[i]-97)] = true;\n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){                 \n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001 * sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":2685,"fileType":"c","requestStartTime":1517959312142}}
{"body": {"column":18,"line":49,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    context.frame.stream_context_t.sync[2] = {0};\n    context.frame.\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    \n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":2022,"fileType":"c","requestStartTime":1517959354362}}
{"body": {"column":12,"line":52,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    context.frame.stream_context_t.sync[2] = {0};\n    context.frame.stream_context_t.sequence = 0;\n    context.frame.stream_context_t.timestamp = 0;\n    context.frame.stream_context_t.state = null;\n    context.\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    \n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":2164,"fileType":"c","requestStartTime":1517959419969}}
{"body": {"column":27,"line":61,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    context.frame.stream_context_t.sync[2] = {0};\n    context.frame.stream_context_t.sequence = 0;\n    context.frame.stream_context_t.timestamp = 0;\n    context.frame.stream_context_t.state = null;\n    context.frame.stream_context_t.checksum = 0;\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    scanf(\"%x %x\", context.)\n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":2583,"fileType":"c","requestStartTime":1517959864109}}
{"body": {"column":78,"line":61,"wordToComplete":"","code":"#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Structure representing the sensor's message frame - as described in the problem statement.\ntypedef struct message_frame {\n\tuint8_t sync[2];    // 2 sync bytes (0x33 + 0xCC)\n\tuint8_t sequence;   // 1-byte message sequence number\n\tuint32_t timestamp; // 4-byte timestamp\n\tuint8_t state;      // 1-byte event state\n\tuint8_t checksum;   // 1-byte checksum of the above fields.\n} message_frame_t;\n\n// Forward declaration of a function that computes the checksum for a complete message \n// frame.  The result is returned as an 8-bit unsigned integer.\n// [in] frame -- pointer to a complete message frame \nstatic uint8_t compute_frame_checksum(const message_frame_t* frame);\n\n// Forward declaration of a function that processes a single byte of stream data, \n// and inserts it into the timestamp of a message frame.  This will generate a \n// correct timestamp when called consecutively on the 4 adjacent bytes of a stream \n// that make up a frame's timestamp.\n//\n// [in/out] frame -- pointer to an in-progress message frame\n// [in] stream_byte -- byte to inject into the frame's timestamp field\nstatic void compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte);\n\n// Forward declaration of the function to display properly decoded frame data.\n// This function is to be called by the user whenever a correctly formatted data\n// frame is encountered.\n// [in] frame -- pointer to a complete message frame \nstatic void print_sensor_data(const message_frame_t* frame);\n\n// Provided to user as skeleton\ntypedef struct { \n\tmessage_frame_t frame;\n    bool message_Complete;\n    //! ToDo: Add data elements capable of preserving the sensor's data stream\n\t//! state across calls to process_sensor_data_stream()\n} stream_context_t;\n\nstatic void reset_stream_context(stream_context_t* context)\n{\n    context.frame.stream_context_t.sync[2] = {0};\n    context.frame.stream_context_t.sequence = 0;\n    context.frame.stream_context_t.timestamp = 0;\n    context.frame.stream_context_t.state = null;\n    context.frame.stream_context_t.checksum = 0;\n   \t//! ToDo: Implement this function to reset the stream's state.\n}\n\n// Definition provided to uesr\nstatic void process_sensor_data_stream(const uint8_t* byte_stream, size_t num_bytes, stream_context_t* context)\n{\n\t//! ToDo: Implement the function to process the byte stream.  Call print_sensor_data() whenever a valid \n\t//! data frame has been detected\n    scanf(\"%x %x\", context.stream_context_t.sync[0], context.stream_context_t.)\n    //! Note: Multiple frames may be delivered in a single call to this function, and a single frame may be delivered\n    //!       across 2 or more calls to this function.\n}\n// Compute the checksum for a message frame \nuint8_t compute_frame_checksum(const message_frame_t* frame)\n{\n\tuint8_t checksum = 0;\n\tchecksum += frame->sync[0];\n\tchecksum += frame->sync[1];\n\tchecksum += frame->sequence;\n\tchecksum += (uint8_t)(frame->timestamp >> 24);\n\tchecksum += (uint8_t)((frame->timestamp & 0x00FF0000) >> 16);\n\tchecksum += (uint8_t)((frame->timestamp & 0x0000FF00) >> 8);\n\tchecksum += (uint8_t)(frame->timestamp & 0x000000FF);\n\tchecksum += frame->state;\n\treturn checksum;\n}\n\nvoid compute_frame_timestamp(message_frame_t* frame, uint8_t stream_byte)\n{\n\tframe->timestamp >>= 8; \n\tframe->timestamp |= ((uint32_t)stream_byte) << 24;\n}\n\nvoid print_sensor_data(const message_frame_t* frame)\n{\n\tprintf(\"seq=%u, timestamp=%u, state=%u\\n\", frame->sequence, frame->timestamp, frame->state);\n}\n\nint main(void)\n{\n\tstream_context_t context = {0};\t\n\treset_stream_context(&context);\n\n\t// The sensor's byte stream is broken into fragments, which are reported to this service via \n    // standard input for the purpose of this challenge.\n    //\n    // Message fragments contain an integer representing the number of bytes received from the sensor,\n    // followed by a series of hex bytes containing the raw data from the sensor as described in the \n    // problem statement.  \n    //\n    // The data stream / test case is terminated when a fragment length <= 0 is read from standard input.\n    \n\tint num_bytes_in_fragment = 0;\n\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t\n\twhile (num_bytes_in_fragment > 0) {\n\t\tuint8_t* fragment = (uint8_t*)malloc(num_bytes_in_fragment);\n\t\t\n\t\tfor (int i = 0; i < num_bytes_in_fragment; i++) {\n\t\t\tunsigned int value;\n\t\t\tscanf(\" 0x%02X\", &value);\n\t\t\tfragment[i] = (uint8_t)value;\n\t\t}\n\t\t\t\t\n\t\tprocess_sensor_data_stream(fragment, num_bytes_in_fragment, &context);\n\t\tfree(fragment);\n\t\tscanf(\"%d\", &num_bytes_in_fragment);\t\n\t}\n\treturn 0;\t\n}\n\n","offset":2634,"fileType":"c","requestStartTime":1517959922452}}
{"body": {"column":53,"line":116,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n). We keep at most 2\n// copies of s in memory at any time, since we free the temp string\n// in twoCharacters() after obtaining its length. Thus total space \n// complexity is O(2n) which in asymptotic form is O(n).\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    \n    // Boolean array to track which unique chars\n    // are present in s\n    bool arr[26];\n    for(int i = 0; i < 26; ++i){\n        arr[i] = false;\n    }\n    \n    for(int i = 0; i < strlen(s) - 1; ++i){\n        // Check the chars are alternating\n        if(s[i] == s[i+1]){\n            return false;\n        }\n        // Mark arr[i] true if the ith letter\n        // of the alphabet is in s                    \n        arr[(int)(s[i]-97)] = true;\n        arr[(int)(s[i+1]-97)] = true;               \n    }\n    \n    // If s is not composed of exactly 2 unique chars,\n    // string is not valid\n    int count = 0;\n    for (int i = 0; i < 26; ++i){\n        if(arr[i]){\n            ++count;\n        }\n    }\n    if(count != 2)\n    {\n        return false;\n    }\n    \n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s){\n    char* newString = (char*) malloc(1001*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < strlen(s); ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    bool arr[26];\n    for(int i = 0; i < 26; ++i){\n        arr[i] = false;\n    }\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        if (s[i]-97 >= 0 && s[i]-97 <26){\n            arr[(int)(s[i]-97)] = true;\n        }\n        \n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]){                 \n                    char* temp = buildString((char)(i+97), (char)(j+97), s);\n                    printf(\"%c %c %s\\n\",(char)(i+97).temp);                                            \n                    if(checkString(temp)){\n                        max = findMax(max, strlen(temp));\n                    }\n                    free(temp);\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc(1001*sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":3254,"fileType":"c","requestStartTime":1517960096911}}
{"body": {"column":32,"line":5,"wordToComplete":"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {printf(Hello, World.)\n    // Declare a variable named 'input_string' to hold our input.\n    char input_string[105]; \n    \n    // Read a full line of input from stdin and save it to our variable, input_string.\n    scanf(\"%[^\\n]\", input_string); \n    \n    // Print a string literal saying \"Hello, World.\" to stdout using printf.\n    printf(\"Hello, World.\\n\");\n    \n    // TODO: Write a line of code here that prints the contents of input_string to stdout.\n    \n    return 0;\n}\n\n","offset":111,"fileType":"c","requestStartTime":1517961066524}}
{"body": {"column":22,"line":5,"wordToComplete":"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main(Hello, World.\n    // Declare a variable named 'input_string' to hold our input.\n    char input_string[105]; \n    \n    // Read a full line of input from stdin and save it to our variable, input_string.\n    scanf(\"%[^\\n]\", input_string); \n    \n    // Print a string literal saying \"Hello, World.\" to stdout using printf.\n    printf(\"Hello, World.\\n\");\n    \n    // TODO: Write a line of code here that prints the contents of input_string to stdout.\n    \n    return 0;\n}\n\n","offset":101,"fileType":"c","requestStartTime":1517961116269}}
{"body": {"column":12,"line":21,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n * Please store the size of the int array to be returned in result_size pointer. For example,\n * int a[3] = {1, 2, 3};\n * *result_size = 3;\n * return a;\n * \n */\nint* oddNumbers(int l, int r, int* result_size) {\n    char* result[50];\n    for (int i=l; i <= r; i++)\n    {\n        if (l % 2 == 1){\n           . printf(\"%d\", result[i-l]);\n            result[i-l] = l;\n            result_size += 1;\n        }\n        else {\n            result[i-l] = l+1;\n            result_size += 1;\n        }\n    }\n    printf(\"%s\", result)\n    return result;\n\n\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res_size;\n    int* res;\n    int _l;\n    scanf(\"%d\", &_l);\n    \n    int _r;\n    scanf(\"%d\", &_r);\n    \n    res = oddNumbers(_l, _r, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":482,"fileType":"c","requestStartTime":1517961302220}}
{"body": {"column":13,"line":21,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n * Please store the size of the int array to be returned in result_size pointer. For example,\n * int a[3] = {1, 2, 3};\n * *result_size = 3;\n * return a;\n * \n */\nint* oddNumbers(int l, int r, int* result_size) {\n    char* result[50];\n    for (int i=l; i <= r; i++)\n    {\n        if (l % 2 == 1){\n           .. printf(\"%d\", result[i-l]);\n            result[i-l] = l;\n            result_size += 1;\n        }\n        else {\n            result[i-l] = l+1;\n            result_size += 1;\n        }\n    }\n    printf(\"%s\", result)\n    return result;\n\n\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res_size;\n    int* res;\n    int _l;\n    scanf(\"%d\", &_l);\n    \n    int _r;\n    scanf(\"%d\", &_r);\n    \n    res = oddNumbers(_l, _r, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":483,"fileType":"c","requestStartTime":1517961302340}}
{"body": {"column":26,"line":113,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// The time complexity of this solution is O(n). We first iterate through\n// the string once to get all the unique chars present in s. Then,\n// worst case scenario, we iterate through all 325 possible 2 letter \n// combinations of the alphabet (if s contains every letter of the alphabet).\n// For each combination, we iterate through s once to build the new string,\n// such that the total time complexity is O(326n) which in asymptotic\n// form is O(n).\n\n// The space complexity of this solution is O(n). We keep at most 2\n// copies of s in memory at any time, since we free the temp string\n// in twoCharacters() after obtaining its length. Thus total space \n// complexity is O(2n) which in asymptotic form is O(n).\n\n// I used several helper functions to clarify code and added\n// comments to hopefully make it readable.\n\n\n// Check if string is a valid \"t\" string\nbool checkString (char* s){\n    \n    // Boolean array to track which unique chars\n    // are present in s\n    bool arr[26];\n    for(int i = 0; i < 26; ++i){\n        arr[i] = false;\n    }\n    \n    int len = (int) strlen(s);\n    \n    for(int i = 0; i < len-1; ++i){\n        // Check the chars are alternating\n        if(s[i] == s[i+1]){\n            return false;\n        }\n        // Mark arr[i] true if the ith letter\n        // of the alphabet is in s                    \n        arr[(int)(s[i]-97)] = true;\n        arr[(int)(s[i+1]-97)] = true;               \n    }\n    \n    // If s is not composed of exactly 2 unique chars,\n    // string is not valid\n    int count = 0;\n    for (int i = 0; i < 26; ++i){\n        if(arr[i]){\n            ++count;\n        }\n    }\n    if(count != 2)\n    {\n        return false;\n    }\n    \n    return true;\n}\n\n// Return a new string that is a copy of string s\n// with all chars except 2 given chars removed\nchar* buildString (char c1, char c2, char* s, int n){\n    char* newString = (char*) malloc((n+1)*sizeof(char));\n    int count = -1;\n    for(int i = 0; i < n; ++i){\n        if(s[i] == c1 || s[i] == c2){\n            newString[++count] = s[i];\n        }\n    }\n    \n    return newString;\n}\n\n// Return max of 2 integers\nint findMax (int i, int j){\n    if (i > j){\n        return i;\n    }\n    else{\n        return j;\n    }\n}\n\nint twoCharacters(char* s, int n) {\n    \n    // Boolean array to track which unique\n    // chars are in string s\n    int arr[26] = {0};\n    /*for(int i = 0; i < 26; ++i){\n        arr[i] = false;\n    }*/\n    \n    // Mark arr[i] as true if the ith letter\n    // of the alphabet is in string s\n    for(int i = 0; i < n; ++i){\n        arr[(int)(s[i]-97)] += 1;        \n    }\n    \n    // Max length of possible \"t\" strings given s\n    int max = 0;\n    \n    // Iterate through all possible combinations of \n    // substrings of s using 2 unique chars, \n    // and take the max length of valid \"t\" strings\n    for(int i = 0; i < 25; ++i){\n        if(arr[i]>0){\n            for(int j = i+1; j < 26; ++j){\n                if(arr[j]>){                 \n                    char* temp = buildString((char)(i+97), (char)(j+97), s, n);\n                    if(checkString(temp)){\n                        max = findMax(max, (int)strlen(temp));\n                    }\n                    //free(temp); \n                    // I know this is a memory leak but I couldn't \n                    // figure out why freeing temp breaks a few test cases                   \n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int l; \n    scanf(\"%i\", &l);\n    char* s = (char *)malloc((l+1)*sizeof(char));\n    scanf(\"%s\", s);\n    int result = twoCharacters(s, l);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\n","offset":3085,"fileType":"c","requestStartTime":1517962088359}}
{"body": {"column":10,"line":19,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint* solve(int a0, int a1, int a2, int b0, int b1, int b2, int *result_size){\n    // Complete this function\n    if(a0>b0){\n        result_size[0] = 1;\n    }\n    else if (b0>a0){\n        result_size[0]=1;\n    }\n    else\n    {}\n    if(a1>)\n}\n\nint main() {\n    int a0; \n    int a1; \n    int a2; \n    scanf(\"%d %d %d\", &a0, &a1, &a2);\n    int b0; \n    int b1; \n    int b2; \n    scanf(\"%d %d %d\", &b0, &b1, &b2);\n    int result_size;\n    int* result = solve(a0, a1, a2, b0, b1, b2, &result_size);\n    for(int result_i = 0; result_i < result_size; result_i++) {\n        if(result_i) {\n            printf(\" \");\n        }\n        printf(\"%d\", result[result_i]);\n    }\n    puts(\"\");\n    \n\n    return 0;\n}\n\n\n","offset":377,"fileType":"c","requestStartTime":1517963706352}}
{"body": {"column":16,"line":13,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nchar* findNumber(int arr_size, int* arr, int k) \n{\n    if(arr_size>)\n    for(int x=0; x<=arr_size; x++)\n    {\n        if(arr==k)\n            ret = \"YES\";\n        else\n            ret = \"NO\";\n    }\n    \n    return ret;\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    char* res;\n    \n    int _arr_size = 0;\n    int _arr_i;\n    scanf(\"%d\\n\", &_arr_size);\n    int _arr[_arr_size];\n    for(_arr_i = 0; _arr_i < _arr_size; _arr_i++) {\n        int _arr_item;\n        scanf(\"%d\", &_arr_item);\n        \n        _arr[_arr_i] = _arr_item;\n    }\n    \n    int _k;\n    scanf(\"%d\", &_k);\n    \n    res = findNumber(_arr_size, _arr, _k);\n    fprintf(f, \"%s\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":246,"fileType":"c","requestStartTime":1517963842897}}
{"body": {"column":15,"line":6,"wordToComplete":"","code":"\n#include <stdio.h>\n\nvoid update(int *a,int *b) {\n    // Complete this function    \n    sum = *a + *b;\n    diff = *a >\n}\n\nint main() {\n    int a, b;\n    int *pa = &a, *pb = &b;\n    \n    scanf(\"%d %d\", &a, &b);\n    update(pa, pb);\n    printf(\"%d\\n%d\", a, b);\n\n    return 0;\n}\n\n\n","offset":119,"fileType":"c","requestStartTime":1517965408761}}
{"body": {"column":16,"line":17,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    int n; \n    scanf(\"%i\", &n);\n    int *a = malloc(sizeof(int) * n);\n    for (int a_i = 0; a_i < n; a_i++) {\n       scanf(\"%i\",&a[a_i]);\n    }\n    int m=0;\n    for (int i=0; i<n; i++){\n        if a[i]>\n    }\n    for (int i=0; i<n; i++){\n        for (int j=0; j<n; j++){\n            if a[i]\n        }\n    }\n    return 0;\n}\n\n\n","offset":375,"fileType":"c","requestStartTime":1517971189889}}
{"body": {"column":9,"line":19,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n * Please store the size of the int array to be returned in result_size pointer. For example,\n * int a[3] = {1, 2, 3};\n * *result_size = 3;\n * return a;\n * \n */\nint result[100001];\nint* oddNumbers(int l, int r, int* result_size) {\n    int size = 0;\n    if(l.)\n    for(int i = 0; i < )    \n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res_size;\n    int* res;\n    int _l;\n    scanf(\"%d\", &_l);\n    \n    int _r;\n    scanf(\"%d\", &_r);\n    \n    res = oddNumbers(_l, _r, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":433,"fileType":"c","requestStartTime":1517974643846}}
{"body": {"column":18,"line":19,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n * Please store the size of the int array to be returned in result_size pointer. For example,\n * int a[3] = {1, 2, 3};\n * *result_size = 3;\n * return a;\n * \n */\nint result[100001];\nint* oddNumbers(int l, int r, int* result_size) {\n    int size = 0;\n    if(l/2==0 && .)\n    for(int i = 0; i < )    \n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res_size;\n    int* res;\n    int _l;\n    scanf(\"%d\", &_l);\n    \n    int _r;\n    scanf(\"%d\", &_r);\n    \n    res = oddNumbers(_l, _r, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":442,"fileType":"c","requestStartTime":1517974651068}}
{"body": {"column":11,"line":19,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M,i;\n    scanf(\"%d\",&M);\n    \n    while(scanf(\"%d\",&i) == 1){\n        struct Node *n = (struct Node*)malloc(sizeof(struct Node));\n        n->\n    }\n    return 0;\n}\n\n\n","offset":380,"fileType":"c","requestStartTime":1517975027751}}
{"body": {"column":11,"line":20,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M,i;\n    scanf(\"%d\",&M);\n    \n    while(scanf(\"%d\",&i) == 1){\n        struct Node *n = (struct Node*)malloc(sizeof(struct Node));\n        n->value = i;\n        n->\n    }\n    return 0;\n}\n\n\n","offset":402,"fileType":"c","requestStartTime":1517975051366}}
{"body": {"column":19,"line":13,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint count_palindromes(char* S) {\n    int length = S.\n    for ()\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n        f = fopen(output_path, \"w\");\n    }\n    else {\n        f = stdout;\n    }\n\n    int res;\n    char* S;\n    S = (char *)malloc(512000 * sizeof(char));\n    scanf(\"\\n%[^\\n]\",S);\n\n    res = count_palindromes(S);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":232,"fileType":"c","requestStartTime":1517975628690}}
{"body": {"column":19,"line":13,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint count_palindromes(char* S) {\n    int length = S.\n    for ()\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n        f = fopen(output_path, \"w\");\n    }\n    else {\n        f = stdout;\n    }\n\n    int res;\n    char* S;\n    S = (char *)malloc(512000 * sizeof(char));\n    scanf(\"\\n%[^\\n]\",S);\n\n    res = count_palindromes(S);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":232,"fileType":"c","requestStartTime":1517975656425}}
{"body": {"column":18,"line":8,"wordToComplete":"import <iostreaM>","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#import <iostreaM>\n/*\n * Complete the function below.\n */\nint count_palindromes(char* S) {\n    int length = sizeof(S) / sizeof(char);\n    for (unsigned int i=0; i!=length; ++i)\n    {\n        std::cout << S[i] << std::endl;\n    }\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n        f = fopen(output_path, \"w\");\n    }\n    else {\n        f = stdout;\n    }\n\n    int res;\n    char* S;\n    S = (char *)malloc(512000 * sizeof(char));\n    scanf(\"\\n%[^\\n]\",S);\n\n    res = count_palindromes(S);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":158,"fileType":"c","requestStartTime":1517975844125}}
{"body": {"column":18,"line":8,"wordToComplete":"import <iostream>","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#import <iostream>\n/*\n * Complete the function below.\n */\nint count_palindromes(char* S) {\n    int length = sizeof(S) / sizeof(char);\n    for (unsigned int i=0; i!=length; ++i)\n    {\n        std::cout << S[i] << std::endl;\n    }\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n        f = fopen(output_path, \"w\");\n    }\n    else {\n        f = stdout;\n    }\n\n    int res;\n    char* S;\n    S = (char *)malloc(512000 * sizeof(char));\n    scanf(\"\\n%[^\\n]\",S);\n\n    res = count_palindromes(S);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":158,"fileType":"c","requestStartTime":1517975844822}}
{"body": {"column":35,"line":43,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\ntypedef struct LinkedListNode LinkedListNode;\n\nstruct LinkedListNode{\n    int val;\n    LinkedListNode *next;\n};\n\nLinkedListNode* _insert_node_into_singlylinkedlist(LinkedListNode *head, LinkedListNode *tail, int val){\n    if(head == NULL) {\n        head = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        head->val = val;\n        head->next = NULL;\n        tail = head;\n    }\n    else {\n        LinkedListNode *node = (LinkedListNode *) (malloc(sizeof(LinkedListNode)));\n        node->val = val;\n        node->next = NULL;\n        tail->next = node;\n        tail = tail->next;\n    }\n    return tail;\n}\n\n/*\n * Complete the function below.\n */\n/*\nFor your reference:\nLinkedListNode {\n    int val;\n    LinkedListNode *next;\n};\n*/\nLinkedListNode* removeNodes(LinkedListNode* list, int x) {\n    if(list == NULL)    return list;\n    if(list->next == NULL && list-.)\n    LinkedListNode *prev_node = list;\n    LinkedListNode *curr_node = list->next;\n    while(curr_node != NULL) {\n        if(curr_node->val > x) {\n            prev_node->next=curr_node->next;\n            curr_node = curr_node->next;\n        }\n        else{\n            prev_node = curr_node;\n            curr_node = curr_node->next;\n        }\n        \n    }\n    return list;\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    LinkedListNode* res;\n    \n    int _list_size = 0;\n    int _list_item;\n    LinkedListNode* _list = NULL;\n    LinkedListNode* _list_tail = NULL;\n    scanf(\"%d\\n\", &_list_size);\n    int _list_i;\n    for(_list_i = 0; _list_i < _list_size; _list_i++) {\n        scanf(\"%d\", &_list_item);\n        if(_list_i == 0) {\n    \t_list = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n    \t_list_tail = _list;\n    \t}\n        else {\n    \t    _list_tail = _insert_node_into_singlylinkedlist(_list, _list_tail, _list_item);\n        }\n    }\n    \n    int _x;\n    scanf(\"%d\", &_x);\n    \n    res = removeNodes(_list, _x);\n    while (res != NULL) {\n        fprintf(f, \"%d\\n\", res->val);\n        \n        res = res->next;\n    }\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":1009,"fileType":"c","requestStartTime":1517975577558}}
{"body": {"column":22,"line":15,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint check_log_history(int events_size, char** events) {\n    for (unsigned int i=0; i<events_size; ++i)\n    {\n        if (events[i].)\n    }\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n        f = fopen(output_path, \"w\");\n    }\n    else {\n        f = stdout;\n    }\n\n    int res;\n    int events_size = 0;\n    scanf(\"%d\\n\", &events_size);\n\n    char* events[events_size];\n    for(int i = 0; i < events_size; i++) {\n        char* events_item;\n        events_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",events_item);\n        events[i] = events_item;\n    }\n\n    res = check_log_history(events_size, events);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":311,"fileType":"c","requestStartTime":1517977225649}}
{"body": {"column":29,"line":17,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nint check_log_history(int events_size, char** events) {\n    for (unsigned int i=0; i<events_size; ++i)\n    {\n        if (events[i].substr(0, 7) == \"ACQUIRE\")\n        {\n        } else if (events[i].)\n    }\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n        f = fopen(output_path, \"w\");\n    }\n    else {\n        f = stdout;\n    }\n\n    int res;\n    int events_size = 0;\n    scanf(\"%d\\n\", &events_size);\n\n    char* events[events_size];\n    for(int i = 0; i < events_size; i++) {\n        char* events_item;\n        events_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",events_item);\n        events[i] = events_item;\n    }\n\n    res = check_log_history(events_size, events);\n    fprintf(f, \"%d\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":377,"fileType":"c","requestStartTime":1517977250131}}
{"body": {"column":18,"line":53,"wordToComplete":"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n\ntypedef struct node node_t;\nstruct node \n{\n    int val;\n    struct node *next;\n};\n\nnode_t* list_add(node_t* head, int val)\n{\n    node_t* node = (node_t *) (malloc(sizeof(node_t)));\n    node->val = val;\n    node->next = NULL;\n\n    if(head == NULL) {\n        head = node;;\n    } else {\n        node_t *end = head;\n        while (end->next != NULL) {\n            end = end->next;\n        }\n        end->next = node;\n    }\n    return head;\n}\n\n/*\nFor your reference:\nstruct node\n{\n    int val;\n    struct node *next;\n};\n*/\n\nnode_t* remove_all_with_val(node_t* head, int val) \n{\n    /*\n    Fill in the logic\n    */\n    // if list is empty return \n    if (head == NULL)   return NULL;\n    \n    node_t *current = head, *prev = head;\n    \n    while(current != NULL) {\n        if (current->val == val) {\n            / * remove this */\n            prev->\n        }\n        prev = current;\n        current = current->next;\n    }\n    return head;\n}\n\nint main() \n{\n    int i, val, size, item;\n    scanf(\"%d %d\", &val, &size);\n    \n    /* Input */\n    node_t* head = NULL;\n    for(i = 0; i < size; i++) {\n        scanf(\"%d\", &item);\n        head = list_add(head, item);\n    }\n    \n    /* Removal */\n    head = remove_all_with_val(head, val);\n  \n    /* Output */\n    node_t* current = head;\n  \twhile (current != NULL) {\n        printf(\"%d \", current->val);\n        current = current->next;\n    }\n    \n    return 0;\n}\n\n","offset":942,"fileType":"c","requestStartTime":1517977393216}}
{"body": {"column":34,"line":53,"wordToComplete":"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n\ntypedef struct node node_t;\nstruct node \n{\n    int val;\n    struct node *next;\n};\n\nnode_t* list_add(node_t* head, int val)\n{\n    node_t* node = (node_t *) (malloc(sizeof(node_t)));\n    node->val = val;\n    node->next = NULL;\n\n    if(head == NULL) {\n        head = node;;\n    } else {\n        node_t *end = head;\n        while (end->next != NULL) {\n            end = end->next;\n        }\n        end->next = node;\n    }\n    return head;\n}\n\n/*\nFor your reference:\nstruct node\n{\n    int val;\n    struct node *next;\n};\n*/\n\nnode_t* remove_all_with_val(node_t* head, int val) \n{\n    /*\n    Fill in the logic\n    */\n    // if list is empty return \n    if (head == NULL)   return NULL;\n    \n    node_t *current = head, *prev = head;\n    \n    while(current != NULL) {\n        if (current->val == val) {\n            / * remove this */\n            prev->next = current->\n        }\n        prev = current;\n        current = current->next;\n    }\n    return head;\n}\n\nint main() \n{\n    int i, val, size, item;\n    scanf(\"%d %d\", &val, &size);\n    \n    /* Input */\n    node_t* head = NULL;\n    for(i = 0; i < size; i++) {\n        scanf(\"%d\", &item);\n        head = list_add(head, item);\n    }\n    \n    /* Removal */\n    head = remove_all_with_val(head, val);\n  \n    /* Output */\n    node_t* current = head;\n  \twhile (current != NULL) {\n        printf(\"%d \", current->val);\n        current = current->next;\n    }\n    \n    return 0;\n}\n\n","offset":958,"fileType":"c","requestStartTime":1517977396431}}
{"body": {"column":15,"line":1,"wordToComplete":"include<stdio.","code":"\n#include<stdio.\n\n","offset":17,"fileType":"c","requestStartTime":1517978077009}}
{"body": {"column":16,"line":2,"wordToComplete":"include<string.","code":"\n#include<stdio.h>\n#include<string.\n\n","offset":36,"fileType":"c","requestStartTime":1517978083724}}
{"body": {"column":19,"line":2,"wordToComplete":"include<string.hz.","code":"\n#include<stdio.h>\n#include<string.hz.\n\n","offset":39,"fileType":"c","requestStartTime":1517978085556}}
{"body": {"column":14,"line":3,"wordToComplete":"include<math.","code":"\n#include<stdio.h>\n#include<string.h>\n#include<math.\n\n","offset":53,"fileType":"c","requestStartTime":1517978097744}}
{"body": {"column":16,"line":4,"wordToComplete":"include<stdlib.","code":"\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.\n\n","offset":72,"fileType":"c","requestStartTime":1517978104763}}
{"body": {"column":10,"line":10,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n   long a,b,c;\n    scanf (\"%d %d %d\", &a, &b, &c);\n    if (a>)\n    return 0;\n}\n\n\n","offset":155,"fileType":"c","requestStartTime":1517978825364}}
{"body": {"column":14,"line":11,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n   long a,b,c;\n    scanf (\"%d %d %d\", &a, &b, &c);\n    if (a>b)\n        if (a>)\n    return 0;\n}\n\n\n","offset":172,"fileType":"c","requestStartTime":1517978992775}}
{"body": {"column":14,"line":16,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n   long a,b,c;\n    scanf (\"%d %d %d\", &a, &b, &c);\n    if (a>b)\n        if (a>c)\n            printf(\"%d\", a);\n    else\n        printf (\"%d\", c);\n    else\n        if (b>)\n    return 0;\n}\n\n\n","offset":262,"fileType":"c","requestStartTime":1517979034987}}
{"body": {"column":15,"line":1,"wordToComplete":"include<stdio.","code":"\n#include<stdio.\n\n","offset":17,"fileType":"c","requestStartTime":1517979141396}}
{"body": {"column":16,"line":2,"wordToComplete":"include<stdlib.","code":"\n#include<stdio.h>\n#include<stdlib.\nint main()\n{\n    int n,a,b,c,d,e,f;\n    printf(\"enter number of games\");\n    scanf(\"%d %d\",&n);\n    printf(\"enter scores in respective game\");\n    scanf(\"%\")\n}\n\n","offset":36,"fileType":"c","requestStartTime":1517979394404}}
{"body": {"column":9,"line":24,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint A[1000];\nint B[1000];\n\nint main(){\n    int n,m,x;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&x);\n        A[x]++;\n    }\n        scanf(\"%d\",&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d\",&x);\n        B[x]++;\n    }\n    if(m>)\n}\n\n","offset":392,"fileType":"c","requestStartTime":1517979456114}}
{"body": {"column":20,"line":26,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint A[1000];\nint B[1000];\n\nint main(){\n    int n,m,x;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&x);\n        A[x]++;\n    }\n        scanf(\"%d\",&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d\",&x);\n        B[x]++;\n    }\n    if(m>=n)\n        for(int i=0;i<=1000;i++){\n            if(B[i]>)\n        }\n}\n\n","offset":450,"fileType":"c","requestStartTime":1517979506410}}
{"body": {"column":10,"line":11,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    int a.\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n\n","offset":242,"fileType":"c","requestStartTime":1517979658007}}
{"body": {"column":18,"line":17,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n * Please store the size of the int array to be returned in result_size pointer. For example,\n * int a[3] = {1, 2, 3};\n * *result_size = 3;\n * return a;\n * \n */\nint* oddNumbers(int l, int r, int* result_size) {\n    for(int i = l.)\n\n\n}\n\nint main() {\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    FILE *f;\n    if (output_path != NULL) {\n    \tf = fopen(output_path, \"w\");\n    }\n    else {\n    \tf = stdout;\n    }\n    \n    int res_size;\n    int* res;\n    int _l;\n    scanf(\"%d\", &_l);\n    \n    int _r;\n    scanf(\"%d\", &_r);\n    \n    res = oddNumbers(_l, _r, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":404,"fileType":"c","requestStartTime":1517980091095}}
{"body": {"column":11,"line":71,"wordToComplete":"","code":"\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid fill(int **c , int n int p){\n  int i;\n  for(i=0;i<p;i++){\n    int a1 , a2;\n    scanf(\"%d %d\",&a1,&a2);\n    if(a1<a2){\n      int t = a1;\n      a1= a2;\n      a2 = t;\n    }\n    c[a1][a2] =1;\n  }\n}\n\nvoid print(int **c,int n){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<i+1;j++){\n\t\t\tprintf(\"%d\\t\",c[i][j]);\n\t\t}\n\tprintf(\"\\n\");\n\t}\n}\n\nvoid complete(int **c, int n){\n\t//printf(\"==============================\\n\");\n\tint i,j,k;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0 ; j<i+1 ; j++ ){\n\t\t\tif(c[i][j]){\n\t\t\t\tfor(k=j;k<n;k++){\n\t\t\t\t\tc[i][k] = c[k][j];\n\t\t\t\t}\n\t\t\t\t//printf(\"i:%d j:%d\\n\",i,j);\n\t\t\t\t//print(c,n);\n\t\t\t\t//printf(\"===============================\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nint count(int **c , int n){\n\tint i ,j;\n\tint count =0;\n\t//print(c,n);\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<i+1;j++){\n\t\t\tcount+= !(c[i][j]);\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\t\n\tint n , p ;\n\tint **c;\n\tint i,j;\n\t\n\tscanf(\"%d %d\",&n,&p);\n\tc = (int **)malloc(n*sizeof(int *));\n\t\n\tfor(i=0;i<n;i++){\n\t\tc[i] = (int *)calloc(i+1,sizeof(int));\n\t\tc[i][i] = 1;\n\t}\n  \n  fill(c,n.)\n\t\n\tcomplete(c,n);\n\tprintf(\"%d\",count(c,n));\n\t//print(c,n);\n\t\n\treturn 0;\n}\n\n\n","offset":1053,"fileType":"c","requestStartTime":1517980804746}}
{"body": {"column":18,"line":57,"wordToComplete":"d\"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\nstruct node\n{\n    int info;\n    struct node *next;\n};\ntypedef struct node *nodeptr;\nnodeptr getnode();\nnodeptr insert();\nvoid display();\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    nodeptr first;\n    first=NULL;\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n    first=insert(first);\n    }\n    display(first);\n    return 0;\n}\n\nnodeptr getnode()\n{\n    nodeptr p;\n    p=(nodeptr)malloc(sizeof(struct node));\n    p->info=0;\n    p->next=NULL;\n    return p;\n}\nnodeptr insert(nodeptr p)\n{\n    nodeptr p1;\n    p1=getnode();\n    scanf(\"%d\",&p1->info);\n    if(p==NULL)\n    {\n        p=p1;\n        return p;\n    }\n    p1->next=p;\n    return p1;\n}\nvoid display(nodeptr p)\n{\n    nodeptr p1;\n    p1=p;\n    while(p1!=NULL)\n    {\n        printf(\"->%d\",p1->info);\n        p1=p1->next;\n    }\n}\n\n","offset":880,"fileType":"c","requestStartTime":1517982208411}}
{"body": {"column":13,"line":55,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\nstruct node\n{\n    int info;\n    struct node *next;\n};\ntypedef struct node *nodeptr;\nnodeptr getnode();\nnodeptr insert();\nvoid display();\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    nodeptr first;\n    first=NULL;\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n    first=insert(first);\n    }\n    display(first);\n    return 0;\n}\n\nnodeptr getnode()\n{\n    nodeptr p;\n    p=(nodeptr)malloc(sizeof(struct node));\n    p->info=0;\n    p->next=NULL;\n    return p;\n}\nnodeptr insert(nodeptr p)\n{\n    nodeptr p1;\n    p1=getnode();\n    scanf(\"%d\",&p1->info);\n    if(p==NULL)\n    {\n        p=p1;\n        return p;\n    }\n    p1->next=p;\n    return p1;\n}\nvoid display(nodeptr p)\n{\n    nodeptr p1;\n    p1=p;\n   while(p1->=1)\n   {\n        printf(\"->%d\",p1->info);\n        p1=p1->next;\n   }                    \n}\n\n","offset":849,"fileType":"c","requestStartTime":1517982548747}}
{"body": {"column":15,"line":46,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\nstruct node\n{\n    int info;\n    struct node *next;\n};\ntypedef struct node *nodeptr;\nnodeptr getnode();\nnodeptr insert();\nvoid display();\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    nodeptr first;\n    first=NULL;\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n    first=insert(first);\n    }\n    display(first);\n    return 0;\n}\n\nnodeptr getnode()\n{\n    nodeptr p;\n    p=(nodeptr)malloc(sizeof(struct node));\n    p->info=0;\n    p->next=NULL;\n    return p;\n}\nnodeptr insert(nodeptr p)\n{\n    nodeptr p1,p2;\n    p1=getnode();\n    scanf(\"%d\",&p1->info);\n  \n  p2=p;\n    while(p2->next!=NULL)\n        p2=p2->\n}\nvoid display(nodeptr p)\n{\n    nodeptr p1;\n    p1=p;\n   while(p1!=NULL)\n   {\n        printf(\"->%d\",p1->info);\n        p1=p1->next;\n   }                    \n}\n\n","offset":746,"fileType":"c","requestStartTime":1517982758793}}
{"body": {"column":8,"line":47,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\nstruct node\n{\n    int info;\n    struct node *next;\n};\ntypedef struct node *nodeptr;\nnodeptr getnode();\nnodeptr insert();\nvoid display();\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    nodeptr first;\n    first=NULL;\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n    first=insert(first);\n    }\n    display(first);\n    return 0;\n}\n\nnodeptr getnode()\n{\n    nodeptr p;\n    p=(nodeptr)malloc(sizeof(struct node));\n    p->info=0;\n    p->next=NULL;\n    return p;\n}\nnodeptr insert(nodeptr p)\n{\n    nodeptr p1,p2;\n    p1=getnode();\n    scanf(\"%d\",&p1->info);\n  \n  p2=p;\n    while(p2->next!=NULL)\n        p2=p2->next;\n    p2->\n}\nvoid display(nodeptr p)\n{\n    nodeptr p1;\n    p1=p;\n   while(p1!=NULL)\n   {\n        printf(\"->%d\",p1->info);\n        p1=p1->next;\n   }                    \n}\n\n","offset":760,"fileType":"c","requestStartTime":1517982771098}}
{"body": {"column":27,"line":42,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\nstruct node\n{\n    int info;\n    struct node *next;\n};\ntypedef struct node *nodeptr;\nnodeptr getnode();\nnodeptr insert();\nvoid display();\n\nint main() {\n    nodeptr first;\n    first=NULL;\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n    first=insert(first);\n    }\n    display(first);\n    return 0;\n}\n\nnodeptr getnode()\n{\n    nodeptr p;\n    p=(nodeptr)malloc(sizeof(struct node));\n    p->info=0;\n    p->next=NULL;\n    return p;\n}\nnodeptr insert(nodeptr p)\n{\n    int k;\n    nodeptr p1,p2;\n    p1=getnode();\n    int pos;\n    scanf(\"%d%d\",&p1->info.);\n    if(p==NULL)\n    {\n        p=p1;\n        return p;\n    }\n    else\n    {\n  \n        scanf(\"%d\",&k);\n        p2=p;\n        while((p2->info!=k)\n            p2=p2->next;\n        p1->next=p2->next;\n        p2->next=p1;\n    return p;\n    }\n}\nvoid display(nodeptr p)\n{\n    nodeptr p1;\n    p1=p;\n   while(p1 != NULL)\n   {\n       printf(\"%d\",p1->info);\n       p1=p->next;\n   }   \n    printf(\"\\n\"); \n}\n\n","offset":639,"fileType":"c","requestStartTime":1517985694714}}
{"body": {"column":15,"line":1,"wordToComplete":"include<stdio.>","code":"\n#include<stdio.>\n\n","offset":17,"fileType":"c","requestStartTime":1517987139792}}
{"body": {"column":15,"line":1,"wordToComplete":"include<stdio.>","code":"\n#include<stdio.>\n\n","offset":17,"fileType":"c","requestStartTime":1517988517963}}
{"body": {"column":14,"line":16,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    int n,j; \n    scanf(\"%d\",&n);\n    int *arr = malloc(sizeof(int) * n);\n    for(int arr_i = 0; arr_i < n; arr_i++){\n       scanf(\"%d\",&arr[arr_i]);\n    }\n    for(j=n;j>0;j--){\n        printf(\"%d\",arr[n]);\n    }\n    return 0;\n}\n\n\n","offset":323,"fileType":"c","requestStartTime":1517989017357}}
{"body": {"column":14,"line":16,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    int n,j; \n    scanf(\"%d\",&n);\n    int *arr = malloc(sizeof(int) * n);\n    for(int arr_i = 0; arr_i < n; arr_i++){\n       scanf(\"%d\",&arr[arr_i]);\n    }\n    for(j=n;j>;j++){\n        printf(\"%2d\",arr[j]);\n    }\n    return 0;\n}\n\n\n","offset":323,"fileType":"c","requestStartTime":1517989407812}}
{"body": {"column":14,"line":16,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    int n,j; \n    scanf(\"%d\",&n);\n    int *arr = malloc(sizeof(int) * n);\n    for(int arr_i = 0; arr_i < n; arr_i++){\n       scanf(\"%d\",&arr[arr_i]);\n    }\n    for(j=n;j>;j++){\n        printf(\"%2d\",arr[j]);\n    }\n    return 0;\n}\n\n\n","offset":323,"fileType":"c","requestStartTime":1517989480109}}
{"body": {"column":28,"line":26,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct pieces{\n    char id[4];\n    int r[4];\n    int c[4];\n    int num;\n};\n\nint waysToGiveACheck(int board_size_rows, int board_size_cols, char** board) {\n    \n    struct pieces WhitePieces;\n    struct pieces BlackPieces;\n    int bking_coor[2];\n    int wking_coor[2];\n    \n    for(int i = 0; i < 8; i++){\n        for(int j = 0; j < 8; j++){\n            if(board[i][j] = 'K'){\n                WhitePieces.\n            }\n        }\n    }\n    \n    \n}\n\nint main() {\n    int t; \n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[8][8];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 8; board_j++) {\n      \n              scanf(\"%c\",&board[board_i][board_j]);\n           }\n        }\n        int result = waysToGiveACheck(board);\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}\n\n\n","offset":545,"fileType":"c","requestStartTime":1517989765256}}
{"body": {"column":22,"line":44,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() {\n    int t; \n    scanf(\"%i\", &t);\n\n\n    for(int a0 = 0; a0 < t; a0++){\n        char board[8][8];\n        int r = 0;\n\n          int k[2];\n         int p[2];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 8; board_j++) {\n              scanf(\"%c\",&board[board_i][board_j]);\n               \n               if (board[board_i][board_j] == 'k'){\n                   k[0] = 8-board_i;\n                   k[1] = board_j;\n               } else if (board_i == 1 && board[board_i][board_j] == 'P'){\n                   p[0] = 8-board_i;\n                   p[1] = board_j;\n               }\n           }\n        }\n\n    \n        if (p[1] - k[1] == 2 && p[0] == k[0])\n            ++r;\n        if (p[1] - k[1] == p[0] - 1 - k[0] || p[1] - k[1] == k[0] - p[0] + 1)\n            r += 2;\n        else if (p[1] == k[1])\n            ++r;\n        if (k[0] == p[0] + 1 && p[1] == k[1])\n            ++r;\n        \n        printf(\"%d\\n\".)\n       // printf(\"k(%d %d) p (%d %d) %d\\n\", k[0], k[1], p[0], p[1], r);\n\n    }\n    return 0;\n}\n\n\n","offset":1112,"fileType":"c","requestStartTime":1517989775488}}
{"body": {"column":39,"line":110,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct pieces{\n    char id[4];\n    int r[4];\n    int c[4];\n    int num;\n};\n\nint waysToGiveACheck(int board_size_rows, int board_size_cols, char** board) {\n    \n    struct pieces WhitePieces;\n    struct pieces BlackPieces;\n    int bking_coor[2];\n    int wking_coor[2];\n    int pawn_coor[2];\n    int cnt1 = 0;\n    int cnt2 = 0;\n    \n    for(int i = 0; i < 8; i++){\n        for(int j = 0; j < 8; j++){\n            if(board[i][j] = 'K'){\n                WhitePieces.id[cnt1] = 'K';\n                WhitePieces.r[cnt1] = i;\n                WhitePieces.c[cnt1] = j;\n                WhitePieces.num = ++cnt1;\n                wking_coor[0] = i;\n                wking_coor[1] = j;\n            }\n            else if(board[i][j] = 'Q'){\n                WhitePieces.id[cnt1] = 'Q';\n                WhitePieces.r[cnt1] = i;\n                WhitePieces.c[cnt1] = j;\n                WhitePieces.num = ++cnt1;\n            }\n            else if(board[i][j] = 'N'){\n                WhitePieces.id[cnt1] = 'N';\n                WhitePieces.r[cnt1] = i;\n                WhitePieces.c[cnt1] = j;\n                WhitePieces.num = ++cnt1;\n            }\n            else if(board[i][j] = 'B'){\n                WhitePieces.id[cnt1] = 'B';\n                WhitePieces.r[cnt1] = i;\n                WhitePieces.c[cnt1] = j;\n                WhitePieces.num = ++cnt1;\n            }\n            else if(board[i][j] = 'R'){\n                WhitePieces.id[cnt1] = 'R';\n                WhitePieces.r[cnt1] = i;\n                WhitePieces.c[cnt1] = j;\n                WhitePieces.num = ++cnt1;\n            }\n            else if(board[i][j] = 'P'){\n                WhitePieces.id[cnt1] = 'P';\n                WhitePieces.r[cnt1] = i;\n                WhitePieces.c[cnt1] = j;\n                WhitePieces.num = ++cnt1;\n            }\n            else if(board[i][j] = 'k'){\n                BlackPieces.id[cnt2] = 'k';\n                BlackPieces.r[cnt2] = i;\n                BlackPieces.c[cnt2] = j;\n                BlackPieces.num = ++cnt2;\n                bking_coor[0] = i;\n                bking_coor[1] = j;\n            }\n            else if(board[i][j] = 'q'){\n                BlackPieces.id[cnt2] = 'q';\n                BlackPieces.r[cnt2] = i;\n                BlackPieces.c[cnt2] = j;\n                BlackPieces.num = ++cnt2;\n            }\n            else if(board[i][j] = 'n'){\n                BlackPieces.id[cnt2] = 'n';\n                BlackPieces.r[cnt2] = i;\n                BlackPieces.c[cnt2] = j;\n                BlackPieces.num = ++cnt2;\n            }\n            else if(board[i][j] = 'b'){\n                BlackPieces.id[cnt2] = 'b';\n                BlackPieces.r[cnt2] = i;\n                BlackPieces.c[cnt2] = j;\n                BlackPieces.num = ++cnt2;\n            }\n            else if(board[i][j] = 'r'){\n                BlackPieces.id[cnt2] = 'r';\n                BlackPieces.r[cnt2] = i;\n                BlackPieces.c[cnt2] = j;\n                BlackPieces.num = ++cnt2;\n            }\n            else if(board[i][j] = 'p'){\n                BlackPieces.id[cnt2] = 'p';\n                BlackPieces.r[cnt2] = i;\n                BlackPieces.c[cnt2] = j;\n                BlackPieces.num = ++cnt2;\n            }\n            \n        }\n    }\n    \n    for(int i = 0; i < 4; i++){\n        if(WhitePieces.id[i] == 'P'){\n            pawn_coor[0] = WhitePieces.[r]\n        }\n    }\n    \n    \n}\n\nint main() {\n    int t; \n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[8][8];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 8; board_j++) {\n      \n              scanf(\"%c\",&board[board_i][board_j]);\n           }\n        }\n        int result = waysToGiveACheck(board);\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}\n\n\n","offset":3482,"fileType":"c","requestStartTime":1517991325898}}
{"body": {"column":17,"line":2,"wordToComplete":"include <string.","code":"\n#include <stdio.h>\n#include <string.\nint main() {\nchar s1[20], s2[20];\n    int i, j, n;\n    \nreturn 0;\n}\n\n","offset":38,"fileType":"c","requestStartTime":1517990537791}}
{"body": {"column":6,"line":19,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint waysToGiveACheck(char board[8][8]) {\n    int pospx=0,pospy=0,poskx=0,posky=0;\n    int option;\n    /..for(int i=0;i<8;i++)\n    {\n        for(int j=0;j<8;j++)\n        {   \n           printf(\"%c  \",board[i][j]);\n           \n        }\n    }.\n    for(int i=0;i<8;i++)\n    {\n        for(int j=0;j<8;j++)\n        {\n             if(board[i][j]=='P')\n            {\n                pospx=i;\n                pospy=j;  \n                break;\n            }\n        }\n    }\n    for(int i=0;i<8;i++)\n    {\n        for(int j=0;j<8;j++)\n        {   \n            if(board[i][j]=='k')\n            {\n                poskx=i;\n                posky=j;\n                break;\n            }\n           \n        }\n    }\n    //printf(\"P=> %d %d\",pospx,pospy);\n    //printf(\"K=> %d %d\",poskx,posky);\n    pospx=pospx-1;\n    if((pospy-posky==2)&&(poskx-pospx==1))\n    {\n        option = 1;\n    }\n    else if(pospy==posky)\n    {\n        option = 2;\n    }\n    else\n    {\n        while((pospx!=poskx)&&(pospy!=posky))\n        {\n            pospx=pospx+1;\n            pospy=pospy-1;\n        }\n        if((pospx==poskx)&&(pospy==posky))\n        {\n            option = 2;\n        }\n    }\n    return option;\n}\n\nint main() {\n    int t; \n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[8][8];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 8; board_j++) {\n      \n              scanf(\"%c\",&board[board_i][board_j]);\n           }\n        }\n        for(int i=0;i<8;i++)\n    {\n        for(int j=0;j<8;j++)\n        {   \n           printf(\"%c i= %d ; j =%d \\n \",i,j,board[i][j]);\n           \n        }\n    }\n        int result = waysToGiveACheck(board);\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}\n\n\n","offset":382,"fileType":"c","requestStartTime":1517992142896}}
{"body": {"column":9,"line":16,"wordToComplete":"","code":"\n#include <stdio.h>\nint main() {\n/* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    int x,y,z,i=0;\n    scanf(\"%d%d%d\",&x,&y,&z);\n    //if((x-z)>0 && (x-z)==y )\n    //{\n      //  printf(\"%d\",x);\n    //}\n    //else\n    //{\nwhile(1)\n{\nif(x!=y)\n{\n    if(y>)\n    if((y-x)==(z-i))\n        break;\n    i++;\n}\nelse\n{\n    if((x+i-y)==y)\n       break;\n    i++;\n}\n}\n      \n    printf(\"%d\",x+i-1);\n    \n    //}\nreturn 0;\n}\n\n","offset":280,"fileType":"c","requestStartTime":1517991851259}}
{"body": {"column":20,"line":17,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    int n; \n    scanf(\"%d\",&n);\n    int *arr = malloc(sizeof(int) * n);\n    for(int arr_i = 0; arr_i < n; arr_i++){\n       scanf(\"%d\",&arr[arr_i]);\n    }\n    \n    for(int i=n-1;i>)\n    \n    return 0;\n}\n\n\n","offset":332,"fileType":"c","requestStartTime":1517992921279}}
{"body": {"column":46,"line":28,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid countApplesAndOranges(int s, int t, int a, int b, int apples_size, int* apples, int oranges_size, int* oranges) {\n    // Complete this function\n}\n\nint main() {\n    int s; \n    int t; \n    scanf(\"%i %i\", &s, &t);\n    int a; \n    int b; \n    scanf(\"%i %i\", &a, &b);\n    int m; \n    int n; \n    scanf(\"%i %i\", &m, &n);\n    int *apple = malloc(sizeof(int) * m);\n    \n    int cnt1=0;\n    for (int apple_i = 0; apple_i < m; apple_i++) {\n       scanf(\"%i\",&apple[apple_i]);\n     if(apple[apple_i]>=0 && a+apple[apple_i]>)\n    }\n    \n    \n    \n    int *orange = malloc(sizeof(int) * n);\n    for (int orange_i = 0; orange_i < n; orange_i++) {\n       scanf(\"%i\",&orange[orange_i]);\n    }\n    countApplesAndOranges(s, t, a, b, apple, orange);\n    return 0;\n}\n\n\n","offset":659,"fileType":"c","requestStartTime":1517993215416}}
{"body": {"column":78,"line":36,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid countApplesAndOranges(int s, int t, int a, int b, int apples_size, int* apples, int oranges_size, int* oranges) {\n    // Complete this function\n}\n\nint main() {\n    int s; \n    int t; \n    scanf(\"%i %i\", &s, &t);\n    int a; \n    int b; \n    scanf(\"%i %i\", &a, &b);\n    int m; \n    int n; \n    scanf(\"%i %i\", &m, &n);\n    int *apple = malloc(sizeof(int) * m);\n    \n    int cnt1=0;\n    for (int apple_i = 0; apple_i < m; apple_i++) {\n       scanf(\"%i\",&apple[apple_i]);\n     if(apple[apple_i]>=0 && a+apple[apple_i]>=s && a+apple[apple_i]<=t)cnt1++;\n    }\n    \n    \n    \n    int *orange = malloc(sizeof(int) * n);\n    for (int orange_i = 0; orange_i < n; orange_i++) {\n       scanf(\"%i\",&orange[orange_i]);\n       if(orange[orange_i]<0 && b+(orange[orange_i])<=t && b+orange[orange_i]>)cnt1++; \n    }\n    countApplesAndOranges(s, t, a, b, apple, orange);\n    return 0;\n}\n\n\n","offset":928,"fileType":"c","requestStartTime":1517993365733}}
{"body": {"column":37,"line":32,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\ntypedef struct job{\n    int start;\n    int finish;\n};\n\nvoid sort(struct job *j,int l,int u){\n    if(l<u){\n        int m=(l+u)/2;\n        sort(j,l,m);\n        sort(j,m+1,u);\n        int sx=m-l+1;\n        int sy=u-m;\n        struct job *x=(struct job*)malloc(sx*sizeof(struct job));\n        struct job *y=(struct job*)malloc(sy*sizeof(struct job));\n        int i,n,k;\n        for(i=0;i<sx;i++){\n            x[i]=j[i+l];\n        }\n        for(n=0;n<sy;n++){\n            y[n]=j[n+m+1];\n        }\n        i=0;n=0;k=l;\n        while(i<sx && n<sy){\n            if((x[i]->finish)<(y[n]->)\n        }\n    }\n}\n\nvoid maxCompatibleJobs(struct job *j,int n){\n    \n}\n\nint main() {\n    int n,i;\n    scanf(\"%d\",&n);\n    struct job *jobs=(job *)malloc(n*sizeof(struct job));\n    for(i=0;i<n;i++){\n        scanf(\"%d %d\",&(jobs[i]->start),&(jobs[i]->finish));\n    }\n    sort(jobs,0,n-1);\n    return 0;\n}\n\n\n","offset":720,"fileType":"c","requestStartTime":1517994039246}}
{"body": {"column":33,"line":69,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\ntypedef struct job{\n    int start;\n    int finish;\n};\n\nvoid sort(struct job *j,int l,int u){\n    if(l<u){\n        int m=(l+u)/2;\n        sort(j,l,m);\n        sort(j,m+1,u);\n        int sx=m-l+1;\n        int sy=u-m;\n        struct job *x=(struct job*)malloc(sx*sizeof(struct job));\n        struct job *y=(struct job*)malloc(sy*sizeof(struct job));\n        int i,n,k;\n        for(i=0;i<sx;i++){\n            x[i]=j[i+l];\n        }\n        for(n=0;n<sy;n++){\n            y[n]=j[n+m+1];\n        }\n        i=0;n=0;k=l;\n        while(i<sx && n<sy){\n            if((x[i]->finish)<(y[n]->finish)){\n                j[k]=x[i];\n                k=k+1;\n                i=i+1;\n            }\n            else{\n                j[k]=y[n];\n                k=k+1;\n                n=n+1;\n            }\n        }\n        while(i<sx){\n           j[k]=x[i];\n           k=k+1;\n           i=i+1; \n        }\n        while(n<sy){\n            j[k]=y[n];\n            k=k+1;\n            n=n+1;\n        }\n    }\n}\n\nvoid maxCompatibleJobs(struct job *j,int n){\n    \n}\n\nint main() {\n    int n,i;\n    scanf(\"%d\",&n);\n    struct job *jobs=(job *)malloc(n*sizeof(struct job));\n    for(i=0;i<n;i++){\n        scanf(\"%d %d\",&(jobs[i]->start),&(jobs[i]->finish));\n    }\n    sort(jobs,0,n-1);\n    for(i=0;i<n;i++){\n        printf(\"%d \\n\",(jobs[i]->)\n    }\n    return 0;\n}\n\n\n","offset":1446,"fileType":"c","requestStartTime":1517994244136}}
{"body": {"column":32,"line":65,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct job{\n    int start;\n    int finish;\n};\n\nvoid sort(struct job *j,int l,int u){\n    if(l<u){\n        int m=(l+u)/2;\n        sort(j,l,m);\n        sort(j,m+1,u);\n        int sx=m-l+1;\n        int sy=u-m;\n        struct job *x=(struct job*)malloc(sx*sizeof(struct job));\n        struct job *y=(struct job*)malloc(sy*sizeof(struct job));\n        int i,n,k;\n        for(i=0;i<sx;i++){\n            x[i]=j[i+l];\n        }\n        for(n=0;n<sy;n++){\n            y[n]=j[n+m+1];\n        }\n        i=0;n=0;k=l;\n        while(i<sx && n<sy){\n            if((x[i]->finish)<(y[n]->finish)){\n                j[k]=x[i];\n                k=k+1;\n                i=i+1;\n            }\n            else{\n                j[k]=y[n];\n                k=k+1;\n                n=n+1;\n            }\n        }\n        while(i<sx){\n           j[k]=x[i];\n           k=k+1;\n           i=i+1; \n        }\n        while(n<sy){\n            j[k]=y[n];\n            k=k+1;\n            n=n+1;\n        }\n    }\n}\n\nvoid maxCompatibleJobs(struct job *j,int n){\n    \n}\n\nint main() {\n    int n,i;\n    scanf(\"%d\",&n);\n    struct job *jobs=(struct job*)malloc(n*sizeof(struct job));\n    for(i=0;i<n;i++){\n        scanf(\"%d %d\",&(jobs[i].start),&(jobs[i]->finish));\n    }\n    sort(jobs,0,n-1);\n    for(i=0;i<n;i++){\n        printf(\"%d \\n\",(jobs[i]->finish));\n    }\n    return 0;\n}\n\n\n","offset":1332,"fileType":"c","requestStartTime":1517994449279}}
{"body": {"column":49,"line":65,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct job{\n    int start;\n    int finish;\n};\n\nvoid sort(struct job *j,int l,int u){\n    if(l<u){\n        int m=(l+u)/2;\n        sort(j,l,m);\n        sort(j,m+1,u);\n        int sx=m-l+1;\n        int sy=u-m;\n        struct job *x=(struct job*)malloc(sx*sizeof(struct job));\n        struct job *y=(struct job*)malloc(sy*sizeof(struct job));\n        int i,n,k;\n        for(i=0;i<sx;i++){\n            x[i]=j[i+l];\n        }\n        for(n=0;n<sy;n++){\n            y[n]=j[n+m+1];\n        }\n        i=0;n=0;k=l;\n        while(i<sx && n<sy){\n            if((x[i]->finish)<(y[n]->finish)){\n                j[k]=x[i];\n                k=k+1;\n                i=i+1;\n            }\n            else{\n                j[k]=y[n];\n                k=k+1;\n                n=n+1;\n            }\n        }\n        while(i<sx){\n           j[k]=x[i];\n           k=k+1;\n           i=i+1; \n        }\n        while(n<sy){\n            j[k]=y[n];\n            k=k+1;\n            n=n+1;\n        }\n    }\n}\n\nvoid maxCompatibleJobs(struct job *j,int n){\n    \n}\n\nint main() {\n    int n,i;\n    scanf(\"%d\",&n);\n    struct job *jobs=(struct job*)malloc(n*sizeof(struct job));\n    for(i=0;i<n;i++){\n        scanf(\"%d %d\",&(jobs[i].start),&(jobs[i].finish));\n    }\n    sort(jobs,0,n-1);\n    for(i=0;i<n;i++){\n        printf(\"%d \\n\",(jobs[i]->finish));\n    }\n    return 0;\n}\n\n\n","offset":1349,"fileType":"c","requestStartTime":1517994452782}}
{"body": {"column":32,"line":69,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct job{\n    int start;\n    int finish;\n};\n\nvoid sort(struct job *j,int l,int u){\n    if(l<u){\n        int m=(l+u)/2;\n        sort(j,l,m);\n        sort(j,m+1,u);\n        int sx=m-l+1;\n        int sy=u-m;\n        struct job *x=(struct job*)malloc(sx*sizeof(struct job));\n        struct job *y=(struct job*)malloc(sy*sizeof(struct job));\n        int i,n,k;\n        for(i=0;i<sx;i++){\n            x[i]=j[i+l];\n        }\n        for(n=0;n<sy;n++){\n            y[n]=j[n+m+1];\n        }\n        i=0;n=0;k=l;\n        while(i<sx && n<sy){\n            if((x[i]->finish)<(y[n]->finish)){\n                j[k]=x[i];\n                k=k+1;\n                i=i+1;\n            }\n            else{\n                j[k]=y[n];\n                k=k+1;\n                n=n+1;\n            }\n        }\n        while(i<sx){\n           j[k]=x[i];\n           k=k+1;\n           i=i+1; \n        }\n        while(n<sy){\n            j[k]=y[n];\n            k=k+1;\n            n=n+1;\n        }\n    }\n}\n\nvoid maxCompatibleJobs(struct job *j,int n){\n    \n}\n\nint main() {\n    int n,i;\n    scanf(\"%d\",&n);\n    struct job *jobs=(struct job*)malloc(n*sizeof(struct job));\n    for(i=0;i<n;i++){\n        scanf(\"%d %d\",&(jobs[i].start),&(jobs[i].finish));\n    }\n    sort(jobs,0,n-1);\n    for(i=0;i<n;i++){\n        printf(\"%d \\n\",(jobs[i].finish));\n    }\n    return 0;\n}\n\n\n","offset":1441,"fileType":"c","requestStartTime":1517994457215}}
{"body": {"column":21,"line":32,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct job{\n    int start;\n    int finish;\n};\n\nvoid sort(struct job *j,int l,int u){\n    if(l<u){\n        int m=(l+u)/2;\n        sort(j,l,m);\n        sort(j,m+1,u);\n        int sx=m-l+1;\n        int sy=u-m;\n        struct job *x=(struct job*)malloc(sx*sizeof(struct job));\n        struct job *y=(struct job*)malloc(sy*sizeof(struct job));\n        int i,n,k;\n        for(i=0;i<sx;i++){\n            x[i]=j[i+l];\n        }\n        for(n=0;n<sy;n++){\n            y[n]=j[n+m+1];\n        }\n        i=0;n=0;k=l;\n        while(i<sx && n<sy){\n            if((x[i].finish)<(y[n]->finish)){\n                j[k]=x[i];\n                k=k+1;\n                i=i+1;\n            }\n            else{\n                j[k]=y[n];\n                k=k+1;\n                n=n+1;\n            }\n        }\n        while(i<sx){\n           j[k]=x[i];\n           k=k+1;\n           i=i+1; \n        }\n        while(n<sy){\n            j[k]=y[n];\n            k=k+1;\n            n=n+1;\n        }\n    }\n}\n\nvoid maxCompatibleJobs(struct job *j,int n){\n    \n}\n\nint main() {\n    int n,i;\n    scanf(\"%d\",&n);\n    struct job *jobs=(struct job*)malloc(n*sizeof(struct job));\n    for(i=0;i<n;i++){\n        scanf(\"%d %d\",&(jobs[i].start),&(jobs[i].finish));\n    }\n    sort(jobs,0,n-1);\n    for(i=0;i<n;i++){\n        printf(\"%d \\n\",(jobs[i].finish));\n    }\n    return 0;\n}\n\n\n","offset":696,"fileType":"c","requestStartTime":1517994466791}}
{"body": {"column":35,"line":32,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct job{\n    int start;\n    int finish;\n};\n\nvoid sort(struct job *j,int l,int u){\n    if(l<u){\n        int m=(l+u)/2;\n        sort(j,l,m);\n        sort(j,m+1,u);\n        int sx=m-l+1;\n        int sy=u-m;\n        struct job *x=(struct job*)malloc(sx*sizeof(struct job));\n        struct job *y=(struct job*)malloc(sy*sizeof(struct job));\n        int i,n,k;\n        for(i=0;i<sx;i++){\n            x[i]=j[i+l];\n        }\n        for(n=0;n<sy;n++){\n            y[n]=j[n+m+1];\n        }\n        i=0;n=0;k=l;\n        while(i<sx && n<sy){\n            if((x[i].finish)<(y[n].finish)){\n                j[k]=x[i];\n                k=k+1;\n                i=i+1;\n            }\n            else{\n                j[k]=y[n];\n                k=k+1;\n                n=n+1;\n            }\n        }\n        while(i<sx){\n           j[k]=x[i];\n           k=k+1;\n           i=i+1; \n        }\n        while(n<sy){\n            j[k]=y[n];\n            k=k+1;\n            n=n+1;\n        }\n    }\n}\n\nvoid maxCompatibleJobs(struct job *j,int n){\n    \n}\n\nint main() {\n    int n,i;\n    scanf(\"%d\",&n);\n    struct job *jobs=(struct job*)malloc(n*sizeof(struct job));\n    for(i=0;i<n;i++){\n        scanf(\"%d %d\",&(jobs[i].start),&(jobs[i].finish));\n    }\n    sort(jobs,0,n-1);\n    for(i=0;i<n;i++){\n        printf(\"%d \\n\",(jobs[i].finish));\n    }\n    return 0;\n}\n\n\n","offset":710,"fileType":"c","requestStartTime":1517994470232}}
{"body": {"column":16,"line":1,"wordToComplete":"include <stdio.","code":"\n#include <stdio.\n\n","offset":18,"fileType":"c","requestStartTime":1517994547572}}
{"body": {"column":17,"line":2,"wordToComplete":"include <stdlib.","code":"\n#include <stdio.h>\n#include <stdlib.\n\n","offset":38,"fileType":"c","requestStartTime":1517994564595}}
{"body": {"column":19,"line":2,"wordToComplete":"include <stdlib.h>","code":"\n#include <stdio.h>\n#include <stdlib.h>\n\n","offset":40,"fileType":"c","requestStartTime":1517994565912}}
{"body": {"column":13,"line":21,"wordToComplete":"0.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    // Complete this function\n    int i,pos,neg,zero;\n    long div_neg=0;\n    long div_pos=0 ;\n    long div_zero=0;\n    for(i=0;i<=arr_size;i++)\n    {\n        scanf(\"%i\",&arr[i]);\n    }\n    for(i=0;i<arr_size;i++)\n    {\n        if(0.arr[i]\n        {\n            pos++;\n            printf(\"pos %d|\\n\",pos);\n        }\n        else if(arr[i]<0)\n        {\n            neg++;\n            printf(\"neg %d|\\n\",neg);\n        }\n        else if(arr[i]==0)\n        {\n            zero++;\n            printf(\"zero %d|\\n\",zero);\n        }\n    /*div_neg=neg / arr;\n    div_pos=pos / arr;\n     div_zero=zero / arr;*/\n    }\n   \n    //printf(\"%d\\n %d\\n %d\\n\",div_pos,div_neg,div_zero);\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":415,"fileType":"c","requestStartTime":1517994605029}}
{"body": {"column":20,"line":8,"wordToComplete":"include <algorithm.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <algorithm.\n\nchar* twoArrays(int k, int A_size, int* A, int B_size, int* B) {\n    // Complete this function\n}\n\nint main() {\n    int q; \n    scanf(\"%i\", &q);\n    for(int a0 = 0; a0 < q; a0++){\n        int n; \n        int k; \n        scanf(\"%i %i\", &n, &k);\n        int *A = malloc(sizeof(int) * n);\n        for (int A_i = 0; A_i < n; A_i++) {\n           scanf(\"%i\",&A[A_i]);\n        }\n        int *B = malloc(sizeof(int) * n);\n        for (int B_i = 0; B_i < n; B_i++) {\n           scanf(\"%i\",&B[B_i]);\n        }\n        int result_size;\n        char* result = twoArrays(k, n, A, n, B);\n        printf(\"%s\\n\", result);\n    }\n    return 0;\n}\n\n\n","offset":160,"fileType":"c","requestStartTime":1517994883146}}
{"body": {"column":21,"line":8,"wordToComplete":"include <algorithm.h>","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <algorithm.h>\n\nchar* twoArrays(int k, int A_size, int* A, int B_size, int* B) {\n    // Complete this function\n}\n\nint main() {\n    int q; \n    scanf(\"%i\", &q);\n    for(int a0 = 0; a0 < q; a0++){\n        int n; \n        int k; \n        scanf(\"%i %i\", &n, &k);\n        int *A = malloc(sizeof(int) * n);\n        for (int A_i = 0; A_i < n; A_i++) {\n           scanf(\"%i\",&A[A_i]);\n        }\n        sort(A, A+n);\n        int *B = malloc(sizeof(int) * n);\n        for (int B_i = 0; B_i < n; B_i++) {\n           scanf(\"%i\",&B[B_i]);\n        }\n        int result_size;\n        char* result = twoArrays(k, n, A, n, B);\n        printf(\"%s\\n\", result);\n    }\n    return 0;\n}\n\n\n","offset":161,"fileType":"c","requestStartTime":1517994933034}}
{"body": {"column":17,"line":62,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct job{\n    int start;\n    int finish;\n};\n\nvoid sort(struct job *j,int l,int u){\n    if(l<u){\n        int m=(l+u)/2;\n        sort(j,l,m);\n        sort(j,m+1,u);\n        int sx=m-l+1;\n        int sy=u-m;\n        struct job *x=(struct job*)malloc(sx*sizeof(struct job));\n        struct job *y=(struct job*)malloc(sy*sizeof(struct job));\n        int i,n,k;\n        for(i=0;i<sx;i++){\n            x[i]=j[i+l];\n        }\n        for(n=0;n<sy;n++){\n            y[n]=j[n+m+1];\n        }\n        i=0;n=0;k=l;\n        while(i<sx && n<sy){\n            if((x[i].finish)<(y[n].finish)){\n                j[k]=x[i];\n                k=k+1;\n                i=i+1;\n            }\n            else{\n                j[k]=y[n];\n                k=k+1;\n                n=n+1;\n            }\n        }\n        while(i<sx){\n           j[k]=x[i];\n           k=k+1;\n           i=i+1; \n        }\n        while(n<sy){\n            j[k]=y[n];\n            k=k+1;\n            n=n+1;\n        }\n    }\n}\n\nint maxCompatibleJobs(struct job *j,int n){\n    int i,c=0;\n    struct job *a=(struct job*)malloc(n*sizeof(struct job));\n    a[0]=j[0];\n    c=1;\n    for(i=1;i<n;i++){\n        if((a[i].))\n    }\n}\n\nint main() {\n    int n,i;\n    scanf(\"%d\",&n);\n    struct job *jobs=(struct job*)malloc(n*sizeof(struct job));\n    for(i=0;i<n;i++){\n        scanf(\"%d %d\",&(jobs[i].start),&(jobs[i].finish));\n    }\n    sort(jobs,0,n-1);\n    int x=maxCompatibleJobs(jobs,n);\n    printf(\"%d\",x);\n    return 0;\n}\n\n\n","offset":1296,"fileType":"c","requestStartTime":1517994937810}}
{"body": {"column":34,"line":62,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct job{\n    int start;\n    int finish;\n};\n\nvoid sort(struct job *j,int l,int u){\n    if(l<u){\n        int m=(l+u)/2;\n        sort(j,l,m);\n        sort(j,m+1,u);\n        int sx=m-l+1;\n        int sy=u-m;\n        struct job *x=(struct job*)malloc(sx*sizeof(struct job));\n        struct job *y=(struct job*)malloc(sy*sizeof(struct job));\n        int i,n,k;\n        for(i=0;i<sx;i++){\n            x[i]=j[i+l];\n        }\n        for(n=0;n<sy;n++){\n            y[n]=j[n+m+1];\n        }\n        i=0;n=0;k=l;\n        while(i<sx && n<sy){\n            if((x[i].finish)<(y[n].finish)){\n                j[k]=x[i];\n                k=k+1;\n                i=i+1;\n            }\n            else{\n                j[k]=y[n];\n                k=k+1;\n                n=n+1;\n            }\n        }\n        while(i<sx){\n           j[k]=x[i];\n           k=k+1;\n           i=i+1; \n        }\n        while(n<sy){\n            j[k]=y[n];\n            k=k+1;\n            n=n+1;\n        }\n    }\n}\n\nint maxCompatibleJobs(struct job *j,int n){\n    int i,c=0;\n    struct job *a=(struct job*)malloc(n*sizeof(struct job));\n    a[0]=j[0];\n    c=1;\n    for(i=1;i<n;i++){\n        if((a[c-1].finish)<=(j[i].))\n    }\n}\n\nint main() {\n    int n,i;\n    scanf(\"%d\",&n);\n    struct job *jobs=(struct job*)malloc(n*sizeof(struct job));\n    for(i=0;i<n;i++){\n        scanf(\"%d %d\",&(jobs[i].start),&(jobs[i].finish));\n    }\n    sort(jobs,0,n-1);\n    int x=maxCompatibleJobs(jobs,n);\n    printf(\"%d\",x);\n    return 0;\n}\n\n\n","offset":1313,"fileType":"c","requestStartTime":1517994970746}}
{"body": {"column":37,"line":18,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node {\n    struct node ** children;\n} node;\n\nnode * newNode() {\n    node ** children = malloc(sizeof(node*) * 26);\n    node * n = malloc(sizeof(node));\n    n->children = children;\n    return n;\n}\n\nvoid addNode(node * n, char * s) {\n    if (s[0] == '\\0') return;\n\n    if (!n->children[s[0] - 'a']) n->[s[0] - 'a'] = newNode();\n    addNode(n[s[0] - 'a'], s[1]);\n}\n\nint main() {\n    return 0;\n}\n\n","offset":357,"fileType":"c","requestStartTime":1517995388189}}
{"body": {"column":15,"line":19,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node {\n    struct node ** children;\n} node;\n\nnode * newNode() {\n    node ** children = malloc(sizeof(node*) * 26);\n    node * n = malloc(sizeof(node));\n    n->children = children;\n    return n;\n}\n\nvoid addNode(node * n, char * s) {\n    if (s[0] == '\\0') return;\n\n    if (!n->children[s[0] - 'a']) n->children[s[0] - 'a'] = newNode();\n    addNode(n->[s[0] - 'a'], s[1]);\n}\n\nint main() {\n    return 0;\n}\n\n","offset":406,"fileType":"c","requestStartTime":1517995400942}}
{"body": {"column":14,"line":38,"wordToComplete":"f\\n %f\\n %f\\n\"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nvoid plusMinus(int arr_size, int* arr) {\n    // Complete this function\n    int i,pos=0,neg=0,zero=0;\n    float div_neg=0;\n    float div_pos=0;\n    float div_zero=0;\n    for(i=0;i<=arr_size;i++)//-4 3 -9 0 4 1\n    {\n        scanf(\"%i\",&arr[i]);\n    }\n    for(i=0;i<arr_size;i++)\n    {\n        if(arr[i]==0)\n        {\n            zero++;\n        }\n        else if(arr[i]<0)\n        {\n            neg++;\n        }\n        else if(arr[i]>0)\n        {\n           pos++;\n        }\n\n    }\n    div_neg = neg / arr_size;\n    div_pos = pos / arr_size;\n    div_zero = zero / arr_size;\n    printf(\"%.f\\n %f\\n %f\\n\",div_pos,div_neg,div_zero);\n}\n\nint main() {\n    int n; \n    scanf(\"%i\", &n);\n    int *arr = malloc(sizeof(int) * n);\n    for (int arr_i = 0; arr_i < n; arr_i++) {\n       scanf(\"%i\",&arr[arr_i]);\n    }\n    plusMinus(n, arr);\n    return 0;\n}\n\n\n","offset":729,"fileType":"c","requestStartTime":1517995556624}}
{"body": {"column":14,"line":4,"wordToComplete":"include<math.>","code":"\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<math.>\nusing namespace std;\nmain(){\n\tlong long s1,s2,l=0,i,j,k=0,a=0,b=0,c=0,x,y,z,p=0;;\n\tscanf(\"%lld\",&k);\n\twhile(k!=0){\n\t\tif(k>=8 && (k%8>2 || k%8==0)){\n\t\t\tk=k-8;\n\t\t\ta++;\n\t\t}\n\t\telse{\n\t\t\tif(k>=6 && (k%6>2 || k%6==0)){\n\t\t\t\tk=k-6;\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(k>=4){\n\t\t\t\t\tk=k-4;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld %lld %lld\",c,b,a);\n\treturn 0;\n}\n\n","offset":70,"fileType":"c","requestStartTime":1517995846297}}
{"body": {"column":17,"line":3,"wordToComplete":"include<cstdlib.>","code":"\n#include<iostream>\n#include<cstdio>\n#include<cstdlib.>\n#include<math.h>\nusing namespace std;\nmain(){\n\tlong long s1,s2,l=0,i,j,k=0,a=0,b=0,c=0,x,y,z,p=0;;\n\tscanf(\"%lld\",&k);\n\twhile(k!=0){\n\t\tif(k>=8 && (k%8>2 || k%8==0)){\n\t\t\tk=k-8;\n\t\t\ta++;\n\t\t}\n\t\telse{\n\t\t\tif(k>=6 && (k%6>2 || k%6==0)){\n\t\t\t\tk=k-6;\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(k>=4){\n\t\t\t\t\tk=k-4;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld %lld %lld\",c,b,a);\n\treturn 0;\n}\n\n","offset":55,"fileType":"c","requestStartTime":1517995847911}}
{"body": {"column":16,"line":2,"wordToComplete":"include<cstdio.>","code":"\n#include<iostream>\n#include<cstdio.>\n#include<cstdlib.h>\n#include<math.h>\nusing namespace std;\nmain(){\n\tlong long s1,s2,l=0,i,j,k=0,a=0,b=0,c=0,x,y,z,p=0;;\n\tscanf(\"%lld\",&k);\n\twhile(k!=0){\n\t\tif(k>=8 && (k%8>2 || k%8==0)){\n\t\t\tk=k-8;\n\t\t\ta++;\n\t\t}\n\t\telse{\n\t\t\tif(k>=6 && (k%6>2 || k%6==0)){\n\t\t\t\tk=k-6;\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(k>=4){\n\t\t\t\t\tk=k-4;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld %lld %lld\",c,b,a);\n\treturn 0;\n}\n\n","offset":37,"fileType":"c","requestStartTime":1517995850249}}
{"body": {"column":17,"line":3,"wordToComplete":"include <string.","code":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.\n\ntypedef struct node {\n    struct node ** children;\n} node;\n\nnode * newNode() {\n    node ** children = malloc(sizeof(node*) * 26);\n    node * n = malloc(sizeof(node));\n    n->children = children;\n    return n;\n}\n\nvoid addNode(node * n, char * s) {\n    if (s[0] == '\\0') return;\n\n    if (!n->children[s[0] - 'a']) n->children[s[0] - 'a'] = newNode();\n    addNode(n->children[s[0] - 'a'], &s[1]);\n}\n\nint findNodes(node * n, char * s) {\n    int count = 0;\n    if (s[0] == '\\0') {\n        count = 1;\n        for (int i = 0; i < 26; i++) {\n            if (n->children[i]) count += findNodes(n->children[i], s);\n        }\n    } else if (n->children[s[0] - 'a']) count += findNodes(n->children[s[0] - 'a'], &s[1]);\n    \n    return count;\n}\n\nint main() {\n    int n;\n    scanf(\"%i\", &n);\n    \n    while (n-- > 0) {\n        \n    }\n    return 0;\n}\n\n","offset":58,"fileType":"c","requestStartTime":1517995852090}}
{"body": {"column":19,"line":24,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main(){\n    int arr[6][6];\n    for(int arr_i = 0; arr_i < 6; arr_i++){\n       for(int arr_j = 0; arr_j < 6; arr_j++){\n          \n          scanf(\"%d\",&arr[arr_i][arr_j]);\n       }\n    }\n    int sum=0,max_sum=0;\n    for(i=1;i<5;i++)\n    {\n        for(j=1;j<5;j++)\n        {\n            sum=0;\n            sum+=arr[i][j]+arr[i-1][j-1]+arr[i][j-1]+arr[i+1][j+1]+arr[i-1][j+1]+arr[i][j+1]+arr[i+1][j-1];\n            if(sum>)\n        }\n    }\n    return 0;\n}\n\n\n","offset":564,"fileType":"c","requestStartTime":1517995863669}}
{"body": {"column":14,"line":20,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() {\n    int n;\n    float sum=1,p=1.0;\n    scanf(\"%d\",&n);\n    if(n==0)\n        printf(\"0\");\n    else\n        for(p=2;p<=n;p++)\n        {\n            sum=sum+1/p;\n        }\n    printf(\"%.\")\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    return 0;\n}\n\n","offset":336,"fileType":"c","requestStartTime":1517996032080}}
{"body": {"column":19,"line":4,"wordToComplete":"include <stdbool.h","code":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h\n\ntypedef struct node {\n    struct node ** children;\n} node;\n\nnode * newNode() {\n    node ** children = malloc(sizeof(node*) * 26);\n    node * n = malloc(sizeof(node));\n    n->children = children;\n    return n;\n}\n\nvoid addNode(node * n, char * s) {\n    if (s[0] == '\\0') return;\n\n    if (!n->children[s[0] - 'a']) n->children[s[0] - 'a'] = newNode();\n    addNode(n->children[s[0] - 'a'], &s[1]);\n}\n\nint findNodes(node * n, char * s) {\n    int count = 0;\n    if (s[0] == '\\0') {\n        count = 1;\n        for (int i = 0; i < 26; i++) {\n            if (n->children[i]) count += findNodes(n->children[i], s);\n        }\n    } else if (n->children[s[0] - 'a']) count += findNodes(n->children[s[0] - 'a'], &s[1]);\n    \n    return count;\n}\n\nint main() {\n    int n;\n    char * op = malloc(4 * sizeof(char));\n    char * name = malloc(21 * sizeof(char));\n    node * tree = newNode();\n    scanf(\"%i\", &n);\n    \n    while (n-- > 0) {\n        scanf(\"%s %s\", op, name);\n        if (strcmp(op, \"add\") == 0) addNode(tree, name);\n        else printf(\"%i\", findNodes(tree, name));\n    }\n    \n    return 0;\n}\n\n","offset":80,"fileType":"c","requestStartTime":1517996166350}}
{"body": {"column":11,"line":20,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\ntypedef struct node {\n    struct node ** children;\n    bool eow;\n} node;\n\nnode * newNode() {\n    node ** children = malloc(sizeof(node*) * 26);\n    node * n = malloc(sizeof(node));\n    n->children = children;\n    return n;\n}\n\nvoid addNode(node * n, char * s) {\n    if (s[0] == '\\0') {\n        n->\n    }\n\n    if (!n->children[s[0] - 'a']) n->children[s[0] - 'a'] = newNode();\n    addNode(n->children[s[0] - 'a'], &s[1]);\n}\n\nint findNodes(node * n, char * s) {\n    int count = 0;\n    if (s[0] == '\\0') {\n        count = 1;\n        for (int i = 0; i < 26; i++) {\n            if (n->children[i]) count += findNodes(n->children[i], s);\n        }\n    } else if (n->children[s[0] - 'a']) count += findNodes(n->children[s[0] - 'a'], &s[1]);\n    \n    return count;\n}\n\nint main() {\n    int n;\n    char * op = malloc(4 * sizeof(char));\n    char * name = malloc(21 * sizeof(char));\n    node * tree = newNode();\n    scanf(\"%i\", &n);\n    \n    while (n-- > 0) {\n        scanf(\"%s %s\", op, name);\n        if (strcmp(op, \"add\") == 0) addNode(tree, name);\n        else printf(\"%i\", findNodes(tree, name));\n    }\n    \n    return 0;\n}\n\n","offset":379,"fileType":"c","requestStartTime":1517996203631}}
{"body": {"column":7,"line":15,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\ntypedef struct node {\n    struct node ** children;\n    bool eow;\n} node;\n\nnode * newNode() {\n    node ** children = malloc(sizeof(node*) * 26);\n    node * n = malloc(sizeof(node));\n    n->children = children;\n    n->\n    return n;\n}\n\nvoid addNode(node * n, char * s) {\n    if (s[0] == '\\0') {\n        n->eow\n    }\n\n    if (!n->children[s[0] - 'a']) n->children[s[0] - 'a'] = newNode();\n    addNode(n->children[s[0] - 'a'], &s[1]);\n}\n\nint findNodes(node * n, char * s) {\n    int count = 0;\n    if (s[0] == '\\0') {\n        count = 1;\n        for (int i = 0; i < 26; i++) {\n            if (n->children[i]) count += findNodes(n->children[i], s);\n        }\n    } else if (n->children[s[0] - 'a']) count += findNodes(n->children[s[0] - 'a'], &s[1]);\n    \n    return count;\n}\n\nint main() {\n    int n;\n    char * op = malloc(4 * sizeof(char));\n    char * name = malloc(21 * sizeof(char));\n    node * tree = newNode();\n    scanf(\"%i\", &n);\n    \n    while (n-- > 0) {\n        scanf(\"%s %s\", op, name);\n        if (strcmp(op, \"add\") == 0) addNode(tree, name);\n        else printf(\"%i\", findNodes(tree, name));\n    }\n    \n    return 0;\n}\n\n","offset":299,"fileType":"c","requestStartTime":1517996225902}}
{"body": {"column":12,"line":11,"wordToComplete":"0.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() \n{ int a,b;\n  float n=0.\n    \n    printf(\"enter the value of \")\n    return 0;\n}\n\n","offset":176,"fileType":"c","requestStartTime":1517996344920}}
{"body": {"column":20,"line":18,"wordToComplete":"1.\"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() \n{ int a,b;\n  float n=0.5;  \n  scanf(\"%d\",a);\n if(a==0)\n     printf(\"0\");\n else\n     for(b=0;b<a;b++)\n     {c=n*3\n         printf(\"%1.\")\n     }         \n    return 0;\n}\n\n","offset":286,"fileType":"c","requestStartTime":1517998151864}}
{"body": {"column":24,"line":18,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() \n{ int a,b;\n  float n=0.5;  \n  scanf(\"%d\",a);\n if(a==0)\n     printf(\"0\");\n else\n     for(b=0;b<a;b++)\n     {c=n*3\n         printf(\"%1.f \".)\n     }         \n    return 0;\n}\n\n","offset":290,"fileType":"c","requestStartTime":1517998157368}}
{"body": {"column":20,"line":19,"wordToComplete":"0.1 \"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() \n{ int a,b;\n  float n=0.5;  \n  scanf(\"%d\",a);\n if(a==0)\n {printf(\"0\");\n }\n else\n     for(b=0;b<a;b++)\n     {c=n*3\n         printf(\"%0.1 \",a);\n     }         \n    return 0;\n}\n\n","offset":286,"fileType":"c","requestStartTime":1517999139737}}
{"body": {"column":21,"line":77,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint waysToGiveACheck(int kpi,int kpj, int pi,int pj) {\n    int i,j ,ways;\n    pi = pi -1;\n    if(kpi == pi || kpj == pj) {                        //Rook & Queen i.e., either row or column\n      ways = 2;\n    } else if(kpi == 1 && (kpj - pj == 2 || pj - kpj == 2) ) {  //Knight row wise\n      ways = 1;\n    }else if(kpi == 2 && (kpj - pj ==1 || pj - kpj == 1) ) {  //Knight column wise\n      ways = 1;\n    } else {\n        for(i = pi+1, j = pj-1; i <8 && j<8;i++,j--){   //Bishop & Queen left diagonal\n        if( kpi == i && kpj == j) {\n          ways = 2;\n        }\n    }\n    \n    for(i = pi+1, j = pj+1; i <8 && j<8;i++,j++){    //Bishop & Queen right diagonal\n        if( kpi == i && kpj == j) {\n        ways = 2;\n        }\n    }\n    }\n    \n    return ways;\n \n}\n\nint main() {\n    int t; \n    int kpi,kpj,Pi,Pj,Qi=9,Qj=9,Bi=9,Bj=9,Ni=9,Nj=9,Ri=9,Rj = 9;\n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[9][9];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 9; board_j++) {\n      \n              scanf(\"%c\",&board[board_i][board_j]);\n               if(board[board_i][board_j] == '#') continue;\n              if(board[board_i][board_j] == 'k') {\n                  kpi = board_i;\n                  kpj = board_j;\n              }\n              if(board[board_i][board_j] == 'P') {\n                  Pi = board_i;\n                  Pj = board_j;\n              }\n              if(board[board_i][board_j] == 'Q') {\n                  Qi = board_i;\n                  Qj = board_j;\n              }\n              if(board[board_i][board_j] == 'R') {\n                  Ri = board_i;\n                  Rj = board_j;\n              }\n              if(board[board_i][board_j] == 'B') {\n                  Bi = board_i;\n                  Bj = board_j;\n              }\n              if(board[board_i][board_j] == 'N') {\n                  Ni = board_i;\n                  Nj = board_j;\n              }\n           }\n        }\n        \n      int count = waysToGiveACheck(kpi,kpj,Pi,Pj);\n         if(kpi == Qi || kpi == Ri) {\n             count++;\n         }else if(Bi>{\n              for(i = pi+1, j = pj-1; i <8 && j<8;i++,j--){   //Bishop & Queen left diagonal\n                if( kpi == i && kpj == j) {\n                 count++;\n                }\n               }\n            for(i = pi+1, j = pj+1; i <8 && j<8;i++,j++){    //Bishop & Queen right diagonal\n                if( kpi == i && kpj == j) {\n                    count++;\n                }\n            }\n         }\n       printf(\"%d\\n\",count);\n    }\n    return 0;\n}\n\n\n","offset":2265,"fileType":"c","requestStartTime":1517999430428}}
{"body": {"column":40,"line":77,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint waysToGiveACheck(int kpi,int kpj, int pi,int pj) {\n    int i,j ,ways;\n    pi = pi -1;\n    if(kpi == pi || kpj == pj) {                        //Rook & Queen i.e., either row or column\n      ways = 2;\n    } else if(kpi == 1 && (kpj - pj == 2 || pj - kpj == 2) ) {  //Knight row wise\n      ways = 1;\n    }else if(kpi == 2 && (kpj - pj ==1 || pj - kpj == 1) ) {  //Knight column wise\n      ways = 1;\n    } else {\n        for(i = pi+1, j = pj-1; i <8 && j<8;i++,j--){   //Bishop & Queen left diagonal\n        if( kpi == i && kpj == j) {\n          ways = 2;\n        }\n    }\n    \n    for(i = pi+1, j = pj+1; i <8 && j<8;i++,j++){    //Bishop & Queen right diagonal\n        if( kpi == i && kpj == j) {\n        ways = 2;\n        }\n    }\n    }\n    \n    return ways;\n \n}\n\nint main() {\n    int t; \n    int kpi,kpj,Pi,Pj,Qi=9,Qj=9,Bi=9,Bj=9,Ni=9,Nj=9,Ri=9,Rj = 9;\n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[9][9];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 9; board_j++) {\n      \n              scanf(\"%c\",&board[board_i][board_j]);\n               if(board[board_i][board_j] == '#') continue;\n              if(board[board_i][board_j] == 'k') {\n                  kpi = board_i;\n                  kpj = board_j;\n              }\n              if(board[board_i][board_j] == 'P') {\n                  Pi = board_i;\n                  Pj = board_j;\n              }\n              if(board[board_i][board_j] == 'Q') {\n                  Qi = board_i;\n                  Qj = board_j;\n              }\n              if(board[board_i][board_j] == 'R') {\n                  Ri = board_i;\n                  Rj = board_j;\n              }\n              if(board[board_i][board_j] == 'B') {\n                  Bi = board_i;\n                  Bj = board_j;\n              }\n              if(board[board_i][board_j] == 'N') {\n                  Ni = board_i;\n                  Nj = board_j;\n              }\n           }\n        }\n        \n      int count = waysToGiveACheck(kpi,kpj,Pi,Pj);\n         if(kpi == Qi || kpi == Ri) {\n             count++;\n         }else if(Bi>=0 && Bi <9 && Bj >{\n              for(i = pi+1, j = pj-1; i <8 && j<8;i++,j--){   //Bishop & Queen left diagonal\n                if( kpi == i && kpj == j) {\n                 count++;\n                }\n               }\n            for(i = pi+1, j = pj+1; i <8 && j<8;i++,j++){    //Bishop & Queen right diagonal\n                if( kpi == i && kpj == j) {\n                    count++;\n                }\n            }\n         }\n       printf(\"%d\\n\",count);\n    }\n    return 0;\n}\n\n\n","offset":2284,"fileType":"c","requestStartTime":1517999447548}}
{"body": {"column":22,"line":88,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint waysToGiveACheck(int kpi,int kpj, int pi,int pj) {\n    int i,j ,ways;\n    pi = pi -1;\n    if(kpi == pi || kpj == pj) {                        //Rook & Queen i.e., either row or column\n      ways = 2;\n    } else if(kpi == 1 && (kpj - pj == 2 || pj - kpj == 2) ) {  //Knight row wise\n      ways = 1;\n    }else if(kpi == 2 && (kpj - pj ==1 || pj - kpj == 1) ) {  //Knight column wise\n      ways = 1;\n    } else {\n        for(i = pi+1, j = pj-1; i <8 && j<8;i++,j--){   //Bishop & Queen left diagonal\n        if( kpi == i && kpj == j) {\n          ways = 2;\n        }\n    }\n    \n    for(i = pi+1, j = pj+1; i <8 && j<8;i++,j++){    //Bishop & Queen right diagonal\n        if( kpi == i && kpj == j) {\n        ways = 2;\n        }\n    }\n    }\n    \n    return ways;\n \n}\n\nint main() {\n    int t; \n    int kpi,kpj,Pi,Pj,Qi=9,Qj=9,Bi=9,Bj=9,Ni=9,Nj=9,Ri=9,Rj = 9;\n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[9][9];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 9; board_j++) {\n      \n              scanf(\"%c\",&board[board_i][board_j]);\n               if(board[board_i][board_j] == '#') continue;\n              if(board[board_i][board_j] == 'k') {\n                  kpi = board_i;\n                  kpj = board_j;\n              }\n              if(board[board_i][board_j] == 'P') {\n                  Pi = board_i;\n                  Pj = board_j;\n              }\n              if(board[board_i][board_j] == 'Q') {\n                  Qi = board_i;\n                  Qj = board_j;\n              }\n              if(board[board_i][board_j] == 'R') {\n                  Ri = board_i;\n                  Rj = board_j;\n              }\n              if(board[board_i][board_j] == 'B') {\n                  Bi = board_i;\n                  Bj = board_j;\n              }\n              if(board[board_i][board_j] == 'N') {\n                  Ni = board_i;\n                  Nj = board_j;\n              }\n           }\n        }\n        \n      int count = waysToGiveACheck(kpi,kpj,Pi,Pj);\n         if(kpi == Qi || kpi == Ri) {\n             count++;\n         }else if(Bi>=0 && Bi <9 && Bj >=0 && Bj <9){\n              for(i = Bi+1, j = Bj-1; i <8 && j<8;i++,j--){   //Bishop & Queen left diagonal\n                if( kpi == i && kpj == j) {\n                 count++;\n                }\n               }\n            for(i = Bi+1, j = Bj+1; i <8 && j<8;i++,j++){    //Bishop & Queen right diagonal\n                if( kpi == i && kpj == j) {\n                    count++;\n                }\n            }\n       } else if (Qi >)\n       printf(\"%d\\n\",count);\n    }\n    return 0;\n}\n\n\n","offset":2716,"fileType":"c","requestStartTime":1517999527485}}
{"body": {"column":41,"line":88,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint waysToGiveACheck(int kpi,int kpj, int pi,int pj) {\n    int i,j ,ways;\n    pi = pi -1;\n    if(kpi == pi || kpj == pj) {                        //Rook & Queen i.e., either row or column\n      ways = 2;\n    } else if(kpi == 1 && (kpj - pj == 2 || pj - kpj == 2) ) {  //Knight row wise\n      ways = 1;\n    }else if(kpi == 2 && (kpj - pj ==1 || pj - kpj == 1) ) {  //Knight column wise\n      ways = 1;\n    } else {\n        for(i = pi+1, j = pj-1; i <8 && j<8;i++,j--){   //Bishop & Queen left diagonal\n        if( kpi == i && kpj == j) {\n          ways = 2;\n        }\n    }\n    \n    for(i = pi+1, j = pj+1; i <8 && j<8;i++,j++){    //Bishop & Queen right diagonal\n        if( kpi == i && kpj == j) {\n        ways = 2;\n        }\n    }\n    }\n    \n    return ways;\n \n}\n\nint main() {\n    int t; \n    int kpi,kpj,Pi,Pj,Qi=9,Qj=9,Bi=9,Bj=9,Ni=9,Nj=9,Ri=9,Rj = 9;\n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[9][9];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 9; board_j++) {\n      \n              scanf(\"%c\",&board[board_i][board_j]);\n               if(board[board_i][board_j] == '#') continue;\n              if(board[board_i][board_j] == 'k') {\n                  kpi = board_i;\n                  kpj = board_j;\n              }\n              if(board[board_i][board_j] == 'P') {\n                  Pi = board_i;\n                  Pj = board_j;\n              }\n              if(board[board_i][board_j] == 'Q') {\n                  Qi = board_i;\n                  Qj = board_j;\n              }\n              if(board[board_i][board_j] == 'R') {\n                  Ri = board_i;\n                  Rj = board_j;\n              }\n              if(board[board_i][board_j] == 'B') {\n                  Bi = board_i;\n                  Bj = board_j;\n              }\n              if(board[board_i][board_j] == 'N') {\n                  Ni = board_i;\n                  Nj = board_j;\n              }\n           }\n        }\n        \n      int count = waysToGiveACheck(kpi,kpj,Pi,Pj);\n         if(kpi == Qi || kpi == Ri) {\n             count++;\n         }else if(Bi>=0 && Bi <9 && Bj >=0 && Bj <9){\n              for(i = Bi+1, j = Bj-1; i <8 && j<8;i++,j--){   //Bishop & Queen left diagonal\n                if( kpi == i && kpj == j) {\n                 count++;\n                }\n               }\n            for(i = Bi+1, j = Bj+1; i <8 && j<8;i++,j++){    //Bishop & Queen right diagonal\n                if( kpi == i && kpj == j) {\n                    count++;\n                }\n            }\n       } else if (Qi >=0 && Qi <9 && Qj >)\n       printf(\"%d\\n\",count);\n    }\n    return 0;\n}\n\n\n","offset":2735,"fileType":"c","requestStartTime":1517999542136}}
{"body": {"column":36,"line":12,"wordToComplete":"","code":"\n#include <stdlib.h>\n\nint main() {\n  \n     // Complete the code.\n    int i;long l;char c;float f;double d;\n    scanf(\"%d\",&i);\n    scanf(\"%ld\",&l);\n    scanf(\" %c\",&c);\n    scanf(\"%f\",&f);\n    scanf(\"%lf\",&d);\n    printf(\"%d\\n%ld\\n%c\\n%f\\n%lf\",i.)\n\n    return 0;\n}\n\n\n","offset":247,"fileType":"c","requestStartTime":1518000544180}}
{"body": {"column":38,"line":12,"wordToComplete":"","code":"\n#include <stdlib.h>\n\nint main() {\n  \n     // Complete the code.\n    int i;long l;char c;float f;double d;\n    scanf(\"%d\",&i);\n    scanf(\"%ld\",&l);\n    scanf(\" %c\",&c);\n    scanf(\"%f\",&f);\n    scanf(\"%lf\",&d);\n    printf(\"%d\\n%ld\\n%c\\n%f\\n%lf\",i.l.)\n\n    return 0;\n}\n\n\n","offset":249,"fileType":"c","requestStartTime":1518000545763}}
{"body": {"column":13,"line":14,"wordToComplete":"input_string\"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    // Declare a variable named 'input_string' to hold our input.\n    char input_string[105]; \n    \n    // Read a full line of input from stdin and save it to our variable, input_string.\n    scanf(\"%[^\\n]\", input_string); \n    \n    // Print a string literal saying \"Hello, World.\" to stdout using printf.\n    printf(\"Hello, World.\\n\");\n    printf(\".input_string\");\n    \n    // TODO: Write a line of code here that prints the contents of input_string to stdout.\n    \n    return 0;\n}\n\n","offset":441,"fileType":"c","requestStartTime":1518000823768}}
{"body": {"column":16,"line":14,"wordToComplete":"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    // Declare a variable named 'input_string' to hold our input.\n    char input_string[105]; \n    \n    // Read a full line of input from stdin and save it to our variable, input_string.\n    scanf(\"%[^\\n]\", input_string); \n    \n    // Print a string literal saying \"Hello, World.\" to stdout using printf.\n    printf(\"Hello, World.\\n\");\n    printf(\"%s\".input_string);\n    \n    // TODO: Write a line of code here that prints the contents of input_string to stdout.\n    \n    return 0;\n}\n\n","offset":444,"fileType":"c","requestStartTime":1518000964871}}
{"body": {"code":"\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n\nchar * get_date()\n{\n    char buf[80] = malloc...;\n    time_t now = time(0); // time() returns the current time as a time_t\n    strcpy(buf, ctime(&now)); // ctime() converts a time_t into a string (e.g. \"Wed Feb 13 16:06:10 2013\")\n    return buf;\n}\n\nint main(int argc, char *argv[])\n{\n    char *date = get_date();\n    printf(\"date=%s\\n\", date);\n    f\n    return 0;\n}\n","fileType":"c","line":17,"column":5,"wordToComplete":"f","offset":409}}
{"body": {"column":37,"line":7,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid findShortest(const int n, bool * grid, bool * marked, int * distances, int pos, int curDistance, int goal) {\n    if (distances[pos] > 0 && curDistance > distances[pos]) return;\n    distances[pos] = distances[pos] > curDistance;\n    if (pos == goal) return;\n    \n    int idx;\n    int * adjacents = malloc(2 * n * sizeof(int));\n    \n    for (int i = pos % n; i < n * n; i += n) {\n        if (!marked[i]) {\n            adjacents[idx++] = i;\n            marked[i] = true;\n        }\n    }\n    \n    for (int i = pos / n; i < (n + 1) * i; i++) {\n        if (!marked[i]) {\n            adjacents[idx++] = i;\n            marked[i] = true;\n        }\n    }\n    \n    for (int i = 0; i < idx; i++) marked[adjacents[i]] = false;\n    free(adjacents);\n}\n\nint main() {\n    int n, x1, x2, y1, y2;\n    char c;\n    scanf(\"%i\", &n);\n    bool * grid = malloc(n * n * sizeof(bool));\n    bool * marked = calloc(n * n, sizeof(bool));\n    int * distances = calloc( n * n, sizeof(int));\n    int * queue = malloc (n * n * sizeof(int));\n    int head = 0;\n    int tail = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%c\", &c);\n            grid[i * n + j] = c == '.';\n        }\n    }\n    \n    scanf(\"%i %i %i %i\", &x1, &y1, &x2, &y2);\n    return 0;\n}\n\n","offset":282,"fileType":"c","requestStartTime":1518004185812}}
{"body": {"column":17,"line":38,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint main() {\n    int t; \n    int v=0,c=0\n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[8][8];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 8; board_j++) {\n      \n              scanf(\"%c\",&board[board_i][board_j]);\n               if(board[board_i][board_j]=='k')\n                   c=i;h=j;\n               \n               if(board[board_i][board_j]=='K')\n                   v++;\n           }\n        }\n        for(int i=7;i>=0;i++)\n        {\n            for(int j=0;j<8;j++)\n            {\n                                 \n                //bishop\n                if(a[i-1][j+1]=='k')\n                    c+=2;\n                else if(a[i-1][j-1]=='k')\n                    c+=2;\n            }\n            if(c>)\n                \n               //elephant\n                if(a[i][j-1]=='k')\n                    c+=2;\n                else if(a[i-1][j]=='k')\n                    c+=2;\n                \n                //horse\n                if(a[i-1][j-1]=='k')||a[i-1][j+2]=='k'||a[i-2][j-1]=='k'||a[i-2][j+1]=='k'\n                    c++;\n            }\n        }\n        \n        if(v==0);\n        {\n          for(int i=7;i>=0;i--)\n          {\n              for(int j=0;j<8;j++)\n              {\n                  //king\n                if(a[i][j-1]=='k')||a[i][j+1]=='k'||a[i-1][j-1]=='k'||a[i-1][j]=='k'||a[i-1][j+1]=='k'\n                    c++;\n                \n              }\n              \n          \n        }\n                  \n                \n                 \n                \n            \n            \n        \n       \n                \n                \n                \n            \n    return 0;\n}\n\n\n","offset":934,"fileType":"c","requestStartTime":1518005336221}}
{"body": {"column":29,"line":47,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid findShortest(const int n, bool * grid, bool * marked, int * distances, const int pos, const int curDistance, const int goal) {\n    if (distances[pos] > 0 && curDistance > distances[pos]) return;\n    distances[pos] = distances[pos] > curDistance ? curDistance : distances[pos];\n    if (pos == goal) return;\n    \n    int idx = 0;\n    int * adjacents = malloc(2 * n * sizeof(int));\n    \n    // south\n    for (int i = pos + n; i < n * n && grid[i]; i += n) {\n        printf(\"%i\\n\", i);\n        /*\n        if (!marked[i]) {\n            adjacents[idx++] = i;\n            marked[i] = true;\n        }\n        */\n    }\n    \n    // north\n    for (int i = pos - n; i >= 0 && grid[i]; i -= n) {\n        printf(\"%i\\n\", i);\n        /*\n        if (!marked[i]) {\n            adjacents[idx++] = i;\n            marked[i] = true;\n        }\n        */\n    }\n    \n    //east\n    for (int i = pos + 1; i < n * (i + 1) && grid[i]; i++) {\n        printf(\"%i\\n\", i);\n        /*\n        if (!marked[i]) {\n            adjacents[idx++] = i;\n            marked[i] = true;\n        }\n        */\n    }\n    \n    // west\n    for (int i = pos + 1; i > n * (i + 1) && grid[i]; i++) {\n        printf(\"%i\\n\", i);\n        /*\n        if (!marked[i]) {\n            adjacents[idx++] = i;\n            marked[i] = true;\n        }\n        */\n    }\n    \n    \n//    for (int i = 0; i < idx; i++) findShortest(n, grid, marked, distances, adjacents[i], curDistance + 1, goal);\n    \n//    for (int i = 0; i < idx; i++) marked[adjacents[i]] = false;\n    free(adjacents);\n}\n\nint main() {\n    int n, x1, x2, y1, y2;\n    char * l = malloc(sizeof(char) * n);\n    scanf(\"%i\", &n);\n    bool * grid = malloc(n * n * sizeof(bool));\n    bool * marked = calloc(n * n, sizeof(bool));\n    int * distances = calloc( n * n, sizeof(int));\n    int * queue = malloc (n * n * sizeof(int));\n    int head = 0;\n    int tail = 0;\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", l);\n        for (int j = 0; j < n; j++) grid[i * n + j] = l[j] == '.';\n    }\n    \n    scanf(\"%i %i %i %i\", &x1, &y1, &x2, &y2);\n    printf(\"%i %i %i %i\\n\", x1, y1, x2, y2);\n    marked[x1 * n + y1] = true;\n    findShortest(n, grid, marked, distances, x1 * n + y1, 0, x2 * n + y2);\n    \n    return 0;\n}\n\n","offset":1184,"fileType":"c","requestStartTime":1518005687720}}
{"body": {"column":22,"line":29,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\nint main() {\n    int t; \n    int v=0,c=0\n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[8][8];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 8; board_j++) {\n      \n              scanf(\"%c\",&board[board_i][board_j]);\n               if(board[board_i][board_j]=='k')\n                   c=i;h=j;\n               \n               if(board[board_i][board_j]=='K')\n                   v++;\n           }\n        }\n        for(int i=7;i>0;i--)\n        {\n            for(int j>;j<8;j++)\n            {\n                                 \n                //bishop\n                if(a[i-1][j+1]=='k')\n                    c+=2;\n                else if(a[i-1][j-1]=='k')\n                    c+=2;\n            }\n           \n                break;\n        }\n        \n         for(int i=0;i>=0;i++)\n        {\n            for(int j=0;j<8;j++)\n            {        \n               //elephant\n                if(a[i][j-1]=='k')\n                    c+=2;\n                else if(a[i-1][j]=='k')\n                    c+=2;\n                \n                //horse\n                if(a[i-1][j-1]=='k')||a[i-1][j+2]=='k'||a[i-2][j-1]=='k'||a[i-2][j+1]=='k'\n                    c++;\n            }\n        }\n        \n        if(v==0);\n        {\n          for(int i=7;i>=0;i--)\n          {\n              for(int j=0;j<8;j++)\n              {\n                  //king\n                if(a[i][j-1]=='k')||a[i][j+1]=='k'||a[i-1][j-1]=='k'||a[i-1][j]=='k'||a[i-1][j+1]=='k'\n                    c++;\n                \n              }\n              \n          \n        }\n                  \n                \n                 \n                \n            \n            \n        \n       \n                \n                \n                \n            \n    return 0;\n}\n\n\n","offset":687,"fileType":"c","requestStartTime":1518005749254}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nv\n\nint main()\n{\n    addRate(\"Bank1\", \"EU\");\n}","fileType":"c","line":28,"column":1,"wordToComplete":"v","offset":685}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvo\n\nint main()\n{\n    addRate(\"Bank1\", \"EU\");\n}","fileType":"c","line":28,"column":2,"wordToComplete":"vo","offset":686}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoi\n\nint main()\n{\n    addRate(\"Bank1\", \"EU\");\n}","fileType":"c","line":28,"column":3,"wordToComplete":"voi","offset":687}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid\n\nint main()\n{\n    addRate(\"Bank1\", \"EUR\");\n}","fileType":"c","line":28,"column":4,"wordToComplete":"void","offset":688}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid a\n\nint main()\n{\n    addRate(\"Bank1\", \"EUR\");\n}","fileType":"c","line":28,"column":6,"wordToComplete":"a","offset":690}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid ag\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\");\n}","fileType":"c","line":28,"column":7,"wordToComplete":"ag","offset":691}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid agg\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\");\n}","fileType":"c","line":28,"column":8,"wordToComplete":"agg","offset":692}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggr\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\");\n}","fileType":"c","line":28,"column":9,"wordToComplete":"aggr","offset":693}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggri\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\");\n}","fileType":"c","line":28,"column":10,"wordToComplete":"aggri","offset":694}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggrig\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", );\n}","fileType":"c","line":28,"column":11,"wordToComplete":"aggrig","offset":695}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggriga\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n}","fileType":"c","line":28,"column":12,"wordToComplete":"aggriga","offset":696}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggrigag\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n}","fileType":"c","line":28,"column":13,"wordToComplete":"aggrigag","offset":697}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggre\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    \n}","fileType":"c","line":28,"column":10,"wordToComplete":"aggre","offset":694}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggre\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    \n}","fileType":"c","line":28,"column":10,"wordToComplete":"aggre","offset":694}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggreg\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    \n}","fileType":"c","line":28,"column":11,"wordToComplete":"aggreg","offset":695}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggrega\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    \n}","fileType":"c","line":28,"column":12,"wordToComplete":"aggrega","offset":696}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggregat\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    \n}","fileType":"c","line":28,"column":13,"wordToComplete":"aggregat","offset":697}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n\n\nvoid addRate(char* bank, char* currPair, double value){\n\n}\n\nvoid aggregate\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    \n}","fileType":"c","line":28,"column":14,"wordToComplete":"aggregate","offset":698}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\ns\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":1,"wordToComplete":"s","offset":623}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nsturc\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":5,"wordToComplete":"sturc","offset":627}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nsturct\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":6,"wordToComplete":"sturct","offset":628}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstuc\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":4,"wordToComplete":"stuc","offset":626}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstuct\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":5,"wordToComplete":"stuct","offset":627}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstucr\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":5,"wordToComplete":"stucr","offset":627}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstucrt\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":6,"wordToComplete":"stucrt","offset":628}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstur\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":4,"wordToComplete":"stur","offset":626}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstr\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":3,"wordToComplete":"str","offset":625}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstru\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":4,"wordToComplete":"stru","offset":626}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruc\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":5,"wordToComplete":"struc","offset":627}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":6,"wordToComplete":"struct","offset":628}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct L\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":8,"wordToComplete":"L","offset":630}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct Li\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":9,"wordToComplete":"Li","offset":631}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct Lis\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":10,"wordToComplete":"Lis","offset":632}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct List\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":11,"wordToComplete":"List","offset":633}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct CList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":8,"wordToComplete":"CList","offset":630}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct COList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":9,"wordToComplete":"COList","offset":631}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct COnList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":10,"wordToComplete":"COnList","offset":632}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct COntList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":11,"wordToComplete":"COntList","offset":633}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct CList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":8,"wordToComplete":"CList","offset":630}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct CoList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":9,"wordToComplete":"CoList","offset":631}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ConList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":10,"wordToComplete":"ConList","offset":632}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":11,"wordToComplete":"ContList","offset":633}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContrList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":12,"wordToComplete":"ContrList","offset":634}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContriList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":13,"wordToComplete":"ContriList","offset":635}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContribList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":14,"wordToComplete":"ContribList","offset":636}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContribuList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":15,"wordToComplete":"ContribuList","offset":637}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":16,"wordToComplete":"ContributList","offset":638}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributoList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":17,"wordToComplete":"ContributoList","offset":639}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":22,"column":18,"wordToComplete":"ContributorList","offset":640}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    c\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":5,"wordToComplete":"c","offset":652}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    ch\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":6,"wordToComplete":"ch","offset":653}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    cha\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":7,"wordToComplete":"cha","offset":654}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* c\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":11,"wordToComplete":"c","offset":658}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* co\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":12,"wordToComplete":"co","offset":659}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* co\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":12,"wordToComplete":"co","offset":659}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* con\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":13,"wordToComplete":"con","offset":660}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* cont\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":14,"wordToComplete":"cont","offset":661}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contri\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":16,"wordToComplete":"contri","offset":663}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contri\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":16,"wordToComplete":"contri","offset":663}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":23,"column":17,"wordToComplete":"contrib","offset":664}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    c\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":24,"column":5,"wordToComplete":"c","offset":671}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    s\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":24,"column":5,"wordToComplete":"s","offset":671}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    st\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":24,"column":6,"wordToComplete":"st","offset":672}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    str\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":24,"column":7,"wordToComplete":"str","offset":673}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    stru\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":24,"column":8,"wordToComplete":"stru","offset":674}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struc\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":24,"column":9,"wordToComplete":"struc","offset":675}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":24,"column":10,"wordToComplete":"struct","offset":676}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct c\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":24,"column":12,"wordToComplete":"c","offset":678}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct co\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n}","fileType":"c","line":24,"column":13,"wordToComplete":"co","offset":679}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct C\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    \n}","fileType":"c","line":24,"column":12,"wordToComplete":"C","offset":678}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct Co\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    \n}","fileType":"c","line":24,"column":13,"wordToComplete":"Co","offset":679}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct Co\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    \n}","fileType":"c","line":24,"column":13,"wordToComplete":"Co","offset":679}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct Con\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    \n}","fileType":"c","line":24,"column":14,"wordToComplete":"Con","offset":680}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct Conr\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    prit\n}","fileType":"c","line":24,"column":15,"wordToComplete":"Conr","offset":681}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct Conri\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    prit\n}","fileType":"c","line":24,"column":16,"wordToComplete":"Conri","offset":682}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct Cont\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    print\n}","fileType":"c","line":24,"column":15,"wordToComplete":"Cont","offset":681}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct Contrivu\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates)_\n}","fileType":"c","line":24,"column":19,"wordToComplete":"Contrivu","offset":685}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct Contrib\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates\n}","fileType":"c","line":24,"column":18,"wordToComplete":"Contrib","offset":684}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* n\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":24,"column":29,"wordToComplete":"n","offset":695}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* ne\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":24,"column":30,"wordToComplete":"ne","offset":696}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* nex\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":24,"column":31,"wordToComplete":"nex","offset":697}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next\n}\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":24,"column":32,"wordToComplete":"next","offset":698}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nh\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":1,"wordToComplete":"h","offset":704}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\ns\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":1,"wordToComplete":"s","offset":704}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nst\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":2,"wordToComplete":"st","offset":705}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstr\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":3,"wordToComplete":"str","offset":706}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstru\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":4,"wordToComplete":"stru","offset":707}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruc\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":5,"wordToComplete":"struc","offset":708}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":6,"wordToComplete":"struct","offset":709}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct C\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":8,"wordToComplete":"C","offset":711}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorC\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":19,"wordToComplete":"ContributorC","offset":722}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCu\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":20,"wordToComplete":"ContributorCu","offset":723}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCur\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":21,"wordToComplete":"ContributorCur","offset":724}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCurr\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":22,"wordToComplete":"ContributorCurr","offset":725}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCurre\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":23,"wordToComplete":"ContributorCurre","offset":726}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCurren\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":24,"wordToComplete":"ContributorCurren","offset":727}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCurrenc\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":25,"wordToComplete":"ContributorCurrenc","offset":728}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCurrency\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":26,"wordToComplete":"ContributorCurrency","offset":729}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCurrencyH\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":27,"wordToComplete":"ContributorCurrencyH","offset":730}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCurrencyHa\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":28,"wordToComplete":"ContributorCurrencyHa","offset":731}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCurrencyHas\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":29,"wordToComplete":"ContributorCurrencyHas","offset":732}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nstruct ContributorCurrencyHash\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":30,"wordToComplete":"ContributorCurrencyHash","offset":733}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\n// CCH: {[conrib, curr]: rate}}\n\n\nstruct ContributorCurrencyHash {\n\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    /C\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":36,"column":6,"wordToComplete":"C","offset":837}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\n// CCH: {[conrib, curr]: rate}}\n\n\nstruct ContributorCurrencyHash {\n\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    /CC\n}\n\nvoid printRates()\n{\n    \n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":36,"column":7,"wordToComplete":"CC","offset":838}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    c\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":31,"column":5,"wordToComplete":"c","offset":775}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    ch\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":31,"column":6,"wordToComplete":"ch","offset":776}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\na\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":1,"wordToComplete":"a","offset":704}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nap\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":2,"wordToComplete":"ap","offset":705}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nv\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":1,"wordToComplete":"v","offset":704}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nvo\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":2,"wordToComplete":"vo","offset":705}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nvoid a\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":6,"wordToComplete":"a","offset":709}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nvoid ap\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":7,"wordToComplete":"ap","offset":710}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#i\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nv\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":22,"column":2,"wordToComplete":"i","offset":624}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nb\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":1,"wordToComplete":"b","offset":725}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbo\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":2,"wordToComplete":"bo","offset":726}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nboo\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":3,"wordToComplete":"boo","offset":727}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":4,"wordToComplete":"bool","offset":728}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool a\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":6,"wordToComplete":"a","offset":730}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool ad\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":7,"wordToComplete":"ad","offset":731}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool add\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":8,"wordToComplete":"add","offset":732}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool ap\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":7,"wordToComplete":"ap","offset":731}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool app\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":8,"wordToComplete":"app","offset":732}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool appe\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":9,"wordToComplete":"appe","offset":733}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool appen\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":10,"wordToComplete":"appen","offset":734}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":29,"column":11,"wordToComplete":"append","offset":735}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\n.\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":1,"wordToComplete":".","offset":775}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\n..\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":2,"wordToComplete":"..","offset":776}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\n...\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":3,"wordToComplete":"...","offset":777}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\nd\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":1,"wordToComplete":"d","offset":775}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\nde\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":2,"wordToComplete":"de","offset":776}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\nde\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":2,"wordToComplete":"de","offset":776}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndel\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":3,"wordToComplete":"del","offset":777}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndele\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":4,"wordToComplete":"dele","offset":778}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelea\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":5,"wordToComplete":"delea","offset":779}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndeleat\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":6,"wordToComplete":"deleat","offset":780}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelet\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":5,"wordToComplete":"delet","offset":779}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":6,"wordToComplete":"delete","offset":780}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nd\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":31,"column":1,"wordToComplete":"d","offset":782}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\ndi\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":31,"column":2,"wordToComplete":"di","offset":783}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\ndin\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":31,"column":3,"wordToComplete":"din","offset":784}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\ni\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":31,"column":1,"wordToComplete":"i","offset":782}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    \n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":31,"column":5,"wordToComplete":"index","offset":786}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    //char* => char*\n}\n\ns\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":40,"column":1,"wordToComplete":"s","offset":880}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    //char* => char*\n}\n\nstruct S\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":40,"column":8,"wordToComplete":"S","offset":887}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\n\nstruct ContributorCurrencyHash {\n    //char* => char*\n}\n\nstruct C\n\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":40,"column":8,"wordToComplete":"C","offset":887}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\ns\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":1,"wordToComplete":"s","offset":822}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nst\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":2,"wordToComplete":"st","offset":823}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstru\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":4,"wordToComplete":"stru","offset":825}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruc\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":5,"wordToComplete":"struc","offset":826}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruc\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":5,"wordToComplete":"struc","offset":826}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":6,"wordToComplete":"struct","offset":827}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct S\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":8,"wordToComplete":"S","offset":829}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct C\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":8,"wordToComplete":"C","offset":829}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct Co\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":9,"wordToComplete":"Co","offset":830}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct Co\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":9,"wordToComplete":"Co","offset":830}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct Con\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":10,"wordToComplete":"Con","offset":831}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct Cont\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":11,"wordToComplete":"Cont","offset":832}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct Contr\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":12,"wordToComplete":"Contr","offset":833}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct Contr\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":12,"wordToComplete":"Contr","offset":833}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct Contri\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":13,"wordToComplete":"Contri","offset":834}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct Contrib\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":35,"column":14,"wordToComplete":"Contrib","offset":835}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    c\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":26,"column":5,"wordToComplete":"c","offset":670}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    cha\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":26,"column":7,"wordToComplete":"cha","offset":672}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* n\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":26,"column":11,"wordToComplete":"n","offset":676}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* na\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":26,"column":12,"wordToComplete":"na","offset":677}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* nam\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":26,"column":13,"wordToComplete":"nam","offset":678}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":26,"column":14,"wordToComplete":"name","offset":679}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    d\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":5,"wordToComplete":"d","offset":686}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double v\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":12,"wordToComplete":"v","offset":693}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double va\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":13,"wordToComplete":"va","offset":694}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double val\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":14,"wordToComplete":"val","offset":695}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double vale\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":15,"wordToComplete":"vale","offset":696}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double valu\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":15,"wordToComplete":"valu","offset":696}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    char* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, char* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => char*\n}\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":27,"column":16,"wordToComplete":"value","offset":697}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nv\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":1,"wordToComplete":"v","offset":957}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nc\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":1,"wordToComplete":"c","offset":957}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nch\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":2,"wordToComplete":"ch","offset":958}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\ncha\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":3,"wordToComplete":"cha","offset":959}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":4,"wordToComplete":"char","offset":960}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** c\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":8,"wordToComplete":"c","offset":964}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** cu\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":9,"wordToComplete":"cu","offset":965}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** cur\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":10,"wordToComplete":"cur","offset":966}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** curr\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":11,"wordToComplete":"curr","offset":967}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** curre\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":12,"wordToComplete":"curre","offset":968}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** curren\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":13,"wordToComplete":"curren","offset":969}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** currenc\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":14,"wordToComplete":"currenc","offset":970}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** currenct\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":15,"wordToComplete":"currenct","offset":971}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** currency\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":15,"wordToComplete":"currency","offset":971}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** currencys\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":16,"wordToComplete":"currencys","offset":972}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** currenci\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":15,"wordToComplete":"currenci","offset":971}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** currencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":17,"wordToComplete":"currencies","offset":973}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** gcurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":8,"wordToComplete":"gcurrencies","offset":964}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** gecurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":9,"wordToComplete":"gecurrencies","offset":965}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** getcurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":10,"wordToComplete":"getcurrencies","offset":966}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":11,"wordToComplete":"getGurrencies","offset":967}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\ni\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":1,"wordToComplete":"i","offset":957}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nin\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":2,"wordToComplete":"in","offset":958}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint g\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":5,"wordToComplete":"g","offset":961}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint ge\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":6,"wordToComplete":"ge","offset":962}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint get\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":7,"wordToComplete":"get","offset":963}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getC\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":8,"wordToComplete":"getC","offset":964}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCu\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":9,"wordToComplete":"getCu","offset":965}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCur\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":10,"wordToComplete":"getCur","offset":966}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurr\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":11,"wordToComplete":"getCurr","offset":967}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurre\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":12,"wordToComplete":"getCurre","offset":968}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurren\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":13,"wordToComplete":"getCurren","offset":969}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrenc\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":14,"wordToComplete":"getCurrenc","offset":970}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrency\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":15,"wordToComplete":"getCurrency","offset":971}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyC\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":16,"wordToComplete":"getCurrencyC","offset":972}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCo\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":17,"wordToComplete":"getCurrencyCo","offset":973}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCon\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":18,"wordToComplete":"getCurrencyCon","offset":974}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCou\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":18,"wordToComplete":"getCurrencyCou","offset":974}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCoun\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":19,"wordToComplete":"getCurrencyCoun","offset":975}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount\nchar** getGurrencies\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":46,"column":20,"wordToComplete":"getCurrencyCount","offset":976}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\ni\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":1,"wordToComplete":"i","offset":1006}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\ni\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":1,"wordToComplete":"i","offset":1006}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint g\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":5,"wordToComplete":"g","offset":1010}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint ge\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":6,"wordToComplete":"ge","offset":1011}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint get\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":7,"wordToComplete":"get","offset":1012}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint getC\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":8,"wordToComplete":"getC","offset":1013}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint getCO\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":9,"wordToComplete":"getCO","offset":1014}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint getCOn\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":10,"wordToComplete":"getCOn","offset":1015}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint getCo\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":9,"wordToComplete":"getCo","offset":1014}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint getCon\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":10,"wordToComplete":"getCon","offset":1015}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint getCont\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":11,"wordToComplete":"getCont","offset":1016}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCurrencyCount();\nchar** getGurrencies();\n\nint getContr\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":12,"wordToComplete":"getContr","offset":1017}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getGurrencies();\n\nc\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":1,"wordToComplete":"c","offset":998}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getGurrencies();\n\nch\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":2,"wordToComplete":"ch","offset":999}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getGurrencies();\n\ncha\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":3,"wordToComplete":"cha","offset":1000}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getGurrencies();\n\nchar** g\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":8,"wordToComplete":"g","offset":1005}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getGurrencies();\n\nchar** ge\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":9,"wordToComplete":"ge","offset":1006}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getGurrencies();\n\nchar** get\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":10,"wordToComplete":"get","offset":1007}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getC\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":11,"wordToComplete":"getC","offset":1008}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getCo\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":12,"wordToComplete":"getCo","offset":1009}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getCon\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":13,"wordToComplete":"getCon","offset":1010}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getCont\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":14,"wordToComplete":"getCont","offset":1011}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContr\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":15,"wordToComplete":"getContr","offset":1012}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContri\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":16,"wordToComplete":"getContri","offset":1013}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContrib\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":17,"wordToComplete":"getContrib","offset":1014}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContribu\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":18,"wordToComplete":"getContribu","offset":1015}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContribut\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":19,"wordToComplete":"getContribut","offset":1016}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContributo\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":20,"wordToComplete":"getContributo","offset":1017}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContributor\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":21,"wordToComplete":"getContributor","offset":1018}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContributorC\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":22,"wordToComplete":"getContributorC","offset":1019}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContributorCo\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":23,"wordToComplete":"getContributorCo","offset":1020}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContributorCou\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":24,"wordToComplete":"getContributorCou","offset":1021}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContributorCoun\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":25,"wordToComplete":"getContributorCoun","offset":1022}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nchar** getContributorCount\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":49,"column":26,"wordToComplete":"getContributorCount","offset":1023}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nv\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":1,"wordToComplete":"v","offset":1032}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvo\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":2,"wordToComplete":"vo","offset":1033}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid a\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":6,"wordToComplete":"a","offset":1037}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid ad\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":7,"wordToComplete":"ad","offset":1038}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid add\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":8,"wordToComplete":"add","offset":1039}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addC\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":9,"wordToComplete":"addC","offset":1040}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addCo\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":10,"wordToComplete":"addCo","offset":1041}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addCon\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":11,"wordToComplete":"addCon","offset":1042}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addCont\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":12,"wordToComplete":"addCont","offset":1043}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContr\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":13,"wordToComplete":"addContr","offset":1044}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContri\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":14,"wordToComplete":"addContri","offset":1045}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":51,"column":15,"wordToComplete":"addContrib","offset":1046}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nC\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":1,"wordToComplete":"C","offset":702}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nCo\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":2,"wordToComplete":"Co","offset":703}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nCon\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":3,"wordToComplete":"Con","offset":704}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nCont\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":4,"wordToComplete":"Cont","offset":705}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContr\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":5,"wordToComplete":"Contr","offset":706}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContri\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":6,"wordToComplete":"Contri","offset":707}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContrib\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":7,"wordToComplete":"Contrib","offset":708}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContribu\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":8,"wordToComplete":"Contribu","offset":709}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContribur\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":9,"wordToComplete":"Contribur","offset":710}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContribut\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":9,"wordToComplete":"Contribut","offset":710}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributo\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":10,"wordToComplete":"Contributo","offset":711}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":11,"wordToComplete":"Contributor","offset":712}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* n\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":14,"wordToComplete":"n","offset":715}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(char* bank, char* currPair, double value)\n{\n    // add()\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":30,"column":16,"wordToComplete":"new","offset":717}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nint getCount();\nchar** getCurrencies();\n\nContributor** getContributors();\n\nvoid addContrib(char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    a\n}\n\nvoid printRates()\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":56,"column":5,"wordToComplete":"a","offset":1213}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nC\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc();\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":1,"wordToComplete":"C","offset":990}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCu\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc();\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":2,"wordToComplete":"Cu","offset":991}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCur\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(s);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":3,"wordToComplete":"Cur","offset":992}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurr\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(si);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":4,"wordToComplete":"Curr","offset":993}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurre\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(si);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":5,"wordToComplete":"Curre","offset":994}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurren\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(siz);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":6,"wordToComplete":"Curren","offset":995}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrenc\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(siz);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":7,"wordToComplete":"Currenc","offset":996}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrenct\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(size);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":8,"wordToComplete":"Currenct","offset":997}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrency\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeo);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":8,"wordToComplete":"Currency","offset":997}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyC\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(siz);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":9,"wordToComplete":"CurrencyC","offset":998}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyCo\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(siz);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":10,"wordToComplete":"CurrencyCo","offset":999}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyCon\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(s);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":11,"wordToComplete":"CurrencyCon","offset":1000}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyCont\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(s);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":12,"wordToComplete":"CurrencyCont","offset":1001}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContr\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(s);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":13,"wordToComplete":"CurrencyContr","offset":1002}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContru\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(s);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":14,"wordToComplete":"CurrencyContru","offset":1003}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContrub\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc();\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":15,"wordToComplete":"CurrencyContrub","offset":1004}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContri\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc();\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":14,"wordToComplete":"CurrencyContri","offset":1003}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContrib\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc();\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":15,"wordToComplete":"CurrencyContrib","offset":1004}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribH\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(s);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":16,"wordToComplete":"CurrencyContribH","offset":1005}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHa\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(se);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":17,"wordToComplete":"CurrencyContribHa","offset":1006}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHas\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(se);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":18,"wordToComplete":"CurrencyContribHas","offset":1007}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(se);\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":19,"wordToComplete":"CurrencyContribHash","offset":1008}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHa\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof());\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":17,"wordToComplete":"CurrencyContribHa","offset":1006}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHas\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof());\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":18,"wordToComplete":"CurrencyContribHas","offset":1007}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof());\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":19,"wordToComplete":"CurrencyContribHash","offset":1008}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* n\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof());\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":22,"wordToComplete":"n","offset":1011}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* ne\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof());\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":23,"wordToComplete":"ne","offset":1012}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* new\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof());\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":24,"wordToComplete":"new","offset":1013}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newC\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":25,"wordToComplete":"newC","offset":1014}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCC\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":26,"wordToComplete":"newCC","offset":1015}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib()\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    // curr\n    // contrib\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(\"Bank1\", \"EURUSD\", 1.1);\n    addRate(\"Bank2\", \"EURUSD\", 1.2599);\n    addRate(\"Bank2\", \"GBPEUR\", 1.15);\n    addRate(\"Bank2\", \"EURUSD\", 1.3);\n    printRates();\n}","fileType":"c","line":47,"column":27,"wordToComplete":"newCCH","offset":1016}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    f\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":5,"wordToComplete":"f","offset":1447}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    fo\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":6,"wordToComplete":"fo","offset":1448}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    c\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":5,"wordToComplete":"c","offset":1447}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    ch\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":6,"wordToComplete":"ch","offset":1448}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    cha\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":7,"wordToComplete":"cha","offset":1449}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":8,"wordToComplete":"char","offset":1450}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    charr\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":9,"wordToComplete":"charr","offset":1451}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** c\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":12,"wordToComplete":"c","offset":1454}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** cur\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":14,"wordToComplete":"cur","offset":1456}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** curr\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":15,"wordToComplete":"curr","offset":1457}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = g\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":20,"wordToComplete":"g","offset":1462}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = ge\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":21,"wordToComplete":"ge","offset":1463}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = get\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":22,"wordToComplete":"get","offset":1464}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    C\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":5,"wordToComplete":"C","offset":1491}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Co\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":6,"wordToComplete":"Co","offset":1492}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Con\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":7,"wordToComplete":"Con","offset":1493}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Cont\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":8,"wordToComplete":"Cont","offset":1494}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contr\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":9,"wordToComplete":"Contr","offset":1495}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contri\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":10,"wordToComplete":"Contri","offset":1496}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contrib\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":11,"wordToComplete":"Contrib","offset":1497}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contribu\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":12,"wordToComplete":"Contribu","offset":1498}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contribut\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":13,"wordToComplete":"Contribut","offset":1499}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributo\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":14,"wordToComplete":"Contributo","offset":1500}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":15,"wordToComplete":"Contributor","offset":1501}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** c\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":19,"wordToComplete":"c","offset":1505}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** co\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":20,"wordToComplete":"co","offset":1506}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** co\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":20,"wordToComplete":"co","offset":1506}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** con\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":21,"wordToComplete":"con","offset":1507}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** con\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":21,"wordToComplete":"con","offset":1507}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** cont\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":22,"wordToComplete":"cont","offset":1508}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contri\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":24,"wordToComplete":"contri","offset":1510}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contrib\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":25,"wordToComplete":"contrib","offset":1511}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":26,"wordToComplete":"contribs","offset":1512}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = .\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":30,"wordToComplete":".","offset":1516}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = ..\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":31,"wordToComplete":"..","offset":1517}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = ...\n    for (int i = 0; i < getCount(exchange); i++) {\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":32,"wordToComplete":"...","offset":1518}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        c\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":66,"column":9,"wordToComplete":"c","offset":1602}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        ch\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":66,"column":10,"wordToComplete":"ch","offset":1603}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* c\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":66,"column":15,"wordToComplete":"c","offset":1608}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* cu\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":66,"column":16,"wordToComplete":"cu","offset":1609}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* cur\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":66,"column":17,"wordToComplete":"cur","offset":1610}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorList {\n    Contributor* contrib;\n    struct ContributorList* next;\n}\n\nbool append(ContributorList* lst, Contrib...* contrib);\ndelete\nindex\n\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => Contributor\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":66,"column":18,"wordToComplete":"curr","offset":1611}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nb\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":1,"wordToComplete":"b","offset":801}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nbo\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":2,"wordToComplete":"bo","offset":802}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nboo\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":3,"wordToComplete":"boo","offset":803}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nbool\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":4,"wordToComplete":"bool","offset":804}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nv\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":1,"wordToComplete":"v","offset":801}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvo\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":2,"wordToComplete":"vo","offset":802}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoi\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":3,"wordToComplete":"voi","offset":803}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":4,"wordToComplete":"void","offset":804}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid a\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":6,"wordToComplete":"a","offset":806}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid ad\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":7,"wordToComplete":"ad","offset":807}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid add\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":8,"wordToComplete":"add","offset":808}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid addC\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":9,"wordToComplete":"addC","offset":809}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid addCu\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":10,"wordToComplete":"addCu","offset":810}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid addCur\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":11,"wordToComplete":"addCur","offset":811}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid addCurr\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":12,"wordToComplete":"addCurr","offset":812}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid addCurre\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":13,"wordToComplete":"addCurre","offset":813}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid addCurren\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":14,"wordToComplete":"addCurren","offset":814}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid addCurrenc\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":15,"wordToComplete":"addCurrenc","offset":815}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid addCurrenct\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":16,"wordToComplete":"addCurrenct","offset":816}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\nstruct Contributor {\n    char* name,\n    double value\n}\n\nContributor* new(char*, double);\n\nstruct ContributorCurrencyMap {\n    // Contributor* => double\n}\n\nvoid addCurrency\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyHash\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":36,"column":16,"wordToComplete":"addCurrency","offset":816}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n.\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => \n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":32,"column":1,"wordToComplete":".","offset":724}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => \n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":32,"column":2,"wordToComplete":"..","offset":725}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n.\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => \n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":33,"column":1,"wordToComplete":".","offset":727}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => \n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributor** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, Contributor* contrib);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    Contributor** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":33,"column":2,"wordToComplete":"..","offset":728}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        c\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":9,"wordToComplete":"c","offset":1443}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        ch\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":10,"wordToComplete":"ch","offset":1444}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        cha\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":11,"wordToComplete":"cha","offset":1445}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":12,"wordToComplete":"char","offset":1446}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* c\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":15,"wordToComplete":"c","offset":1449}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* cu\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":16,"wordToComplete":"cu","offset":1450}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* cur\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":17,"wordToComplete":"cur","offset":1451}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":18,"wordToComplete":"curr","offset":1452}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = c\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":22,"wordToComplete":"c","offset":1456}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = cu\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":23,"wordToComplete":"cu","offset":1457}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = cur\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":24,"wordToComplete":"cur","offset":1458}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = curr\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":25,"wordToComplete":"curr","offset":1459}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = curr\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":59,"column":25,"wordToComplete":"curr","offset":1459}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        c\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":9,"wordToComplete":"c","offset":1474}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ch\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":10,"wordToComplete":"ch","offset":1475}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        cha\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":11,"wordToComplete":"cha","offset":1476}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":12,"wordToComplete":"char","offset":1477}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* c\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":15,"wordToComplete":"c","offset":1480}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* co\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":16,"wordToComplete":"co","offset":1481}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* co\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":16,"wordToComplete":"co","offset":1481}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* contri\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":20,"wordToComplete":"contri","offset":1485}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* contrib\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":21,"wordToComplete":"contrib","offset":1486}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* contribs\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":22,"wordToComplete":"contribs","offset":1487}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* contribs = c\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":26,"wordToComplete":"c","offset":1491}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* contribs = cu\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":27,"wordToComplete":"cu","offset":1492}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* contribs = cur\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":28,"wordToComplete":"cur","offset":1493}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nchar** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    char** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        char* contribs = curr\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":60,"column":29,"wordToComplete":"curr","offset":1494}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        \n        g\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":9,"wordToComplete":"g","offset":1574}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        \n        go\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":10,"wordToComplete":"go","offset":1575}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        \n        got\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":11,"wordToComplete":"got","offset":1576}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        \n        got\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":11,"wordToComplete":"got","offset":1576}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        \n        f\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":9,"wordToComplete":"f","offset":1574}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        \n        fo\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":10,"wordToComplete":"fo","offset":1575}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        \n        for (int y = 0; i < getValueCount(contrib); i++) {\n            p\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":13,"wordToComplete":"p","offset":1637}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        \n        for (int y = 0; i < getValueCount(contrib); i++) {\n            p\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":13,"wordToComplete":"p","offset":1637}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        d\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":9,"wordToComplete":"d","offset":1565}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        do\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":10,"wordToComplete":"do","offset":1566}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        dou\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":11,"wordToComplete":"dou","offset":1567}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        doub\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":12,"wordToComplete":"doub","offset":1568}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double a\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":16,"wordToComplete":"a","offset":1572}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double ac\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":17,"wordToComplete":"ac","offset":1573}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double acc\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":18,"wordToComplete":"acc","offset":1574}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accu\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":19,"wordToComplete":"accu","offset":1575}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accum\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":20,"wordToComplete":"accum","offset":1576}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumu\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":21,"wordToComplete":"accumu","offset":1577}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumul\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":22,"wordToComplete":"accumul","offset":1578}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumula\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":23,"wordToComplete":"accumula","offset":1579}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulat\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":24,"wordToComplete":"accumulat","offset":1580}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulato\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":25,"wordToComplete":"accumulato","offset":1581}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            printf(\"%f\")\n        }\n        \n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":61,"column":26,"wordToComplete":"accumulator","offset":1582}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            a\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":13,"wordToComplete":"a","offset":1660}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            ac\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":14,"wordToComplete":"ac","offset":1661}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            acc\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":15,"wordToComplete":"acc","offset":1662}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = c\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":27,"wordToComplete":"c","offset":1674}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = co\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":28,"wordToComplete":"co","offset":1675}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = co\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":28,"wordToComplete":"co","offset":1675}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":29,"wordToComplete":"con","offset":1676}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":29,"wordToComplete":"con","offset":1676}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        i\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":9,"wordToComplete":"i","offset":1597}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int c\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":13,"wordToComplete":"c","offset":1601}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int co\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":14,"wordToComplete":"co","offset":1602}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int co\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":14,"wordToComplete":"co","offset":1602}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int cou\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":15,"wordToComplete":"cou","offset":1603}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int coun\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":16,"wordToComplete":"coun","offset":1604}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int count\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":17,"wordToComplete":"count","offset":1605}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int countr\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":18,"wordToComplete":"countr","offset":1606}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int countru\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":19,"wordToComplete":"countru","offset":1607}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int countrub\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":20,"wordToComplete":"countrub","offset":1608}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int v\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":13,"wordToComplete":"v","offset":1601}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int va\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":14,"wordToComplete":"va","offset":1602}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int val\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":15,"wordToComplete":"val","offset":1603}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valu\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":16,"wordToComplete":"valu","offset":1604}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int value\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":17,"wordToComplete":"value","offset":1605}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueC\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":18,"wordToComplete":"valueC","offset":1606}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCo\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":19,"wordToComplete":"valueCo","offset":1607}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCou\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":20,"wordToComplete":"valueCou","offset":1608}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCoun\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":21,"wordToComplete":"valueCoun","offset":1609}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount\n        for (int y = 0; i < getValueCount(contrib); i++) {\n            accumulator = con\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":62,"column":22,"wordToComplete":"valueCount","offset":1610}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator = v\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":27,"wordToComplete":"v","offset":1711}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator = va\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":28,"wordToComplete":"va","offset":1712}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator = val\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":29,"wordToComplete":"val","offset":1713}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator = valu\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":30,"wordToComplete":"valu","offset":1714}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator = valu\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":30,"wordToComplete":"valu","offset":1714}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator = g\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":27,"wordToComplete":"g","offset":1711}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator = ge\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":28,"wordToComplete":"ge","offset":1712}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator = get\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":29,"wordToComplete":"get","offset":1713}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            c\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":13,"wordToComplete":"c","offset":1697}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":16,"wordToComplete":"char","offset":1700}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* v\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":19,"wordToComplete":"v","offset":1703}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* va\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":20,"wordToComplete":"va","offset":1704}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* val\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":21,"wordToComplete":"val","offset":1705}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* valu\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":22,"wordToComplete":"valu","offset":1706}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* value\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":23,"wordToComplete":"value","offset":1707}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* c\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":19,"wordToComplete":"c","offset":1703}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* co\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":20,"wordToComplete":"co","offset":1704}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* co\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":20,"wordToComplete":"co","offset":1704}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* con\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":21,"wordToComplete":"con","offset":1705}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* cont\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":22,"wordToComplete":"cont","offset":1706}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* contri\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":24,"wordToComplete":"contri","offset":1708}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":25,"wordToComplete":"contrib","offset":1709}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = g\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":29,"wordToComplete":"g","offset":1713}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = ge\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":30,"wordToComplete":"ge","offset":1714}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = get\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":31,"wordToComplete":"get","offset":1715}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = get\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":31,"wordToComplete":"get","offset":1715}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = get\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":31,"wordToComplete":"get","offset":1715}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        c\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":9,"wordToComplete":"c","offset":1646}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** c\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":16,"wordToComplete":"c","offset":1653}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** con\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":18,"wordToComplete":"con","offset":1655}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** cont\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":19,"wordToComplete":"cont","offset":1656}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contr\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":20,"wordToComplete":"contr","offset":1657}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contri\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":21,"wordToComplete":"contri","offset":1658}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contrib\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":22,"wordToComplete":"contrib","offset":1659}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribN\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":23,"wordToComplete":"contribN","offset":1660}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNa\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":24,"wordToComplete":"contribNa","offset":1661}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNam\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":25,"wordToComplete":"contribNam","offset":1662}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribName\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":26,"wordToComplete":"contribName","offset":1663}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":27,"wordToComplete":"contribNames","offset":1664}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = g\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":31,"wordToComplete":"g","offset":1668}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = get\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":33,"wordToComplete":"get","offset":1670}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = get\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":33,"wordToComplete":"get","offset":1670}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getCo\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":63,"column":35,"wordToComplete":"getCo","offset":1672}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        d\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":9,"wordToComplete":"d","offset":1706}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        do\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":10,"wordToComplete":"do","offset":1707}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        dou\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":11,"wordToComplete":"dou","offset":1708}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        doub\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":12,"wordToComplete":"doub","offset":1709}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        doubl\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":13,"wordToComplete":"doubl","offset":1710}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":14,"wordToComplete":"double","offset":1711}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* v\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":17,"wordToComplete":"v","offset":1714}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* val\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":19,"wordToComplete":"val","offset":1716}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* val\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":19,"wordToComplete":"val","offset":1716}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* valu\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":20,"wordToComplete":"valu","offset":1717}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* value\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":21,"wordToComplete":"value","offset":1718}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* values\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":22,"wordToComplete":"values","offset":1719}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* values = g\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":26,"wordToComplete":"g","offset":1723}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* values = ge\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":27,"wordToComplete":"ge","offset":1724}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* values = get\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib = \n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":64,"column":28,"wordToComplete":"get","offset":1725}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* contri\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":66,"column":24,"wordToComplete":"contri","offset":1813}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        char** contribNames = getContributorNames(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            char* contrib\n            accumulator = getValue(contrib, )\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":66,"column":25,"wordToComplete":"contrib","offset":1814}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator += v\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":28,"wordToComplete":"v","offset":1757}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator += va\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":29,"wordToComplete":"va","offset":1758}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; i < valueCount; i++) {\n            accumulator += val\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":30,"wordToComplete":"val","offset":1759}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / v\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":40,"wordToComplete":"v","offset":1769}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / va\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":41,"wordToComplete":"va","offset":1770}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / val\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":42,"wordToComplete":"val","offset":1771}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / valu\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":43,"wordToComplete":"valu","offset":1772}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / value\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":44,"wordToComplete":"value","offset":1773}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / values\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":45,"wordToComplete":"values","offset":1774}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / valueC\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":45,"wordToComplete":"valueC","offset":1774}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / valueCo\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":46,"wordToComplete":"valueCo","offset":1775}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / valueCo\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":46,"wordToComplete":"valueCo","offset":1775}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / valueCou\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":47,"wordToComplete":"valueCou","offset":1776}}
{"body": {"code":"/*\n\nDesign and implement simple Foreign Exchange market functionality. \nThe module should be able to publish Composite Rates for all available currency pairs. \n\nThere are multiple contributors for each rate, and Composite Rate is calculated as an average of the latest quotes from each contributor.\n\nWrite a pair of functions where you can add quotes (identified by Contributor, CurrencyPair and Rate) and also print current composite rates for all CurrencyPairs.\n\n\nSample input sequence:\n * Bank1 EURUSD 1.1\n * Bank2 EURUSD 1.2599\n * Bank2 GBPEUR 1.15\n * Bank2 EURUSD 1.3\n\nExpected output:\nEURUSD: 1.2\nGBPEUR: 1.15\n\n*/\n\n#include<stdbool.h>\n\n\n\n\nstruct ContributorCurrencyMap {\n    // char* => double\n}\n\nvoid addCurrency()\n..\n..\n// CCH: {curr: {contrib: rate}}\n\nstruct CurrencyContributorHash {\n    //char* => ContributorCurrencyMap*\n}\n\nCurrencyContribHash* newCCH();\n\nint getCount();\nchar** getCurrencies(CurrencyContributorHash* exchange);\n\nContributorCurrencyMap** getContributors(CurrencyContributorHash* exchange);\n\nvoid addContrib(CurrencyContributorHash* exchange, char* curr, char* contrib, double value);\n\nvoid addRate(CurrencyContributorHash* exchange, char* bank, char* currPair, double value)\n{\n    addContrib(exchange, curr, bank, value);\n}\n\nvoid printRates(CurrencyContributorHash* exchange)\n{\n    char** currs = getCurrencies(exchange);\n    ContributorCurrencyMap** contribs = getContributors(exchange);\n    for (int i = 0; i < getCount(exchange); i++) {\n        char* curr = currs[i];\n        ContributorCurrencyMap* contrib = contribs[i];\n        double accumulator = 0;\n        int valueCount = getValueCount(contrib);\n        double* values = getValues(contrib);\n        for (int y = 0; y < valueCount; y++) {\n            accumulator += values[y] / valueCoun\n        }\n        printf(\"%f\", accumulator);\n    }\n}\n\nint main()\n{\n    CurrencyContributorHash* exchange = malloc(sizeof(CurrencyContributorHash));\n    addRate(exchange, \"Bank1\", \"EURUSD\", 1.1);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.2599);\n    addRate(exchange, \"Bank2\", \"GBPEUR\", 1.15);\n    addRate(exchange, \"Bank2\", \"EURUSD\", 1.3);\n    printRates(exchange);\n    free(exchange);\n}","fileType":"c","line":65,"column":48,"wordToComplete":"valueCoun","offset":1777}}
{"body": {"column":13,"line":12,"wordToComplete":"arri","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    sort(arri)    \n\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":296,"fileType":"c","requestStartTime":1518011560530}}
{"body": {"column":27,"line":12,"wordToComplete":"arr","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    sort(arrivals_size, arr)    \n\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":310,"fileType":"c","requestStartTime":1518011569313}}
{"body": {"column":19,"line":14,"wordToComplete":"arri","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    sort(arrivals_size, arrivals_size + flights)\n    for (i = 0; i < flights; i++){\n        printf(arri)\n    }\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":386,"fileType":"c","requestStartTime":1518011619789}}
{"body": {"column":36,"line":12,"wordToComplete":"sort(arrivals, arrivals + Arri);","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    //sort(arrivals, arrivals + Arri);\n    for (int i = 0; i < flights; i++){\n        printf(arrivals[i]);\n    }\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":319,"fileType":"c","requestStartTime":1518011747010}}
{"body": {"column":33,"line":12,"wordToComplete":"sort(arrivals, arrivals + arri);","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    //sort(arrivals, arrivals + arri);\n    for (int i = 0; i < flights; i++){\n        printf(arrivals[i]);\n    }\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":316,"fileType":"c","requestStartTime":1518011750002}}
{"body": {"column":36,"line":12,"wordToComplete":"sort(arrivals, arrivals + arri);","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    //sort(arrivals, arrivals + arri);\n    for (int i = 0; i < flights; i++){\n        printf(arrivals[i]);\n    }\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":319,"fileType":"c","requestStartTime":1518011751980}}
{"body": {"column":36,"line":12,"wordToComplete":"sort(arrivals, arrivals + arri);","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    //sort(arrivals, arrivals + arri);\n    for (int i = 0; i < flights; i++){\n        printf(arrivals[i]);\n    }\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":319,"fileType":"c","requestStartTime":1518011753140}}
{"body": {"column":13,"line":13,"wordToComplete":"depa","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    sort(arrivals, arrivals + arrivals_size);\n    sort(depa)\n    for (int i = 1; i < flights; i++){\n      printf(\"%d\",arrivals[i]);\n    }\n    \n    /* int gate = 1;\n    int maxGate = 0;\n \n\tint j = 0;\n\tint count = 0;\n    for(int i=1; i<flights; i++){\n        while(j < i){\n \n            if(arrivals[i] > departures[j]){\n                   gate = gate - 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n                    count++;\n               }\n            else if(arrivals[i] <= departures[j]){\n                    gate = gate + 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n            }\n            j++;\n        }\n        j = count;\n        count = 0;\n    }\n \n    return maxGate;\n    */\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":342,"fileType":"c","requestStartTime":1518012074346}}
{"body": {"column":24,"line":13,"wordToComplete":"dep","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    sort(arrivals, arrivals + arrivals_size);\n    sort(departures, dep)\n    for (int i = 1; i < flights; i++){\n      printf(\"%d\",arrivals[i]);\n    }\n    \n    /* int gate = 1;\n    int maxGate = 0;\n \n\tint j = 0;\n\tint count = 0;\n    for(int i=1; i<flights; i++){\n        while(j < i){\n \n            if(arrivals[i] > departures[j]){\n                   gate = gate - 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n                    count++;\n               }\n            else if(arrivals[i] <= departures[j]){\n                    gate = gate + 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n            }\n            j++;\n        }\n        j = count;\n        count = 0;\n    }\n \n    return maxGate;\n    */\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":353,"fileType":"c","requestStartTime":1518012079956}}
{"body": {"column":37,"line":13,"wordToComplete":"dep","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    sort(arrivals, arrivals + arrivals_size);\n    sort(departures, departures + dep)\n    for (int i = 1; i < flights; i++){\n      printf(\"%d\",arrivals[i]);\n    }\n    \n    /* int gate = 1;\n    int maxGate = 0;\n \n\tint j = 0;\n\tint count = 0;\n    for(int i=1; i<flights; i++){\n        while(j < i){\n \n            if(arrivals[i] > departures[j]){\n                   gate = gate - 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n                    count++;\n               }\n            else if(arrivals[i] <= departures[j]){\n                    gate = gate + 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n            }\n            j++;\n        }\n        j = count;\n        count = 0;\n    }\n \n    return maxGate;\n    */\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":366,"fileType":"c","requestStartTime":1518012084160}}
{"body": {"column":16,"line":18,"wordToComplete":"arri","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    sort(arrivals, arrivals + arrivals_size);\n    sort(departures, departures + departures_size);\n    int gate = 1;\n    int final = 0;\n    int i = 1, j = 0;\n    while(i < flights && j < flights){\n        if (arri)\n    }\n    for (int i = 1; i < flights; i++){\n      printf(\"%d\",arrivals[i]);\n    }\n    \n    /* int gate = 1;\n    int maxGate = 0;\n \n\tint j = 0;\n\tint count = 0;\n    for(int i=1; i<flights; i++){\n        while(j < i){\n \n            if(arrivals[i] > departures[j]){\n                   gate = gate - 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n                    count++;\n               }\n            else if(arrivals[i] <= departures[j]){\n                    gate = gate + 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n            }\n            j++;\n        }\n        j = count;\n        count = 0;\n    }\n \n    return maxGate;\n    */\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":495,"fileType":"c","requestStartTime":1518012171950}}
{"body": {"column":29,"line":18,"wordToComplete":"dep","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    sort(arrivals, arrivals + arrivals_size);\n    sort(departures, departures + departures_size);\n    int gate = 1;\n    int final = 0;\n    int i = 1, j = 0;\n    while(i < flights && j < flights){\n        if (arrivals[i] < dep)\n    }\n    for (int i = 1; i < flights; i++){\n      printf(\"%d\",arrivals[i]);\n    }\n    \n    /* int gate = 1;\n    int maxGate = 0;\n \n\tint j = 0;\n\tint count = 0;\n    for(int i=1; i<flights; i++){\n        while(j < i){\n \n            if(arrivals[i] > departures[j]){\n                   gate = gate - 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n                    count++;\n               }\n            else if(arrivals[i] <= departures[j]){\n                    gate = gate + 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n            }\n            j++;\n        }\n        j = count;\n        count = 0;\n    }\n \n    return maxGate;\n    */\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":508,"fileType":"c","requestStartTime":1518012177407}}
{"body": {"column":22,"line":21,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint findMinGates(int arrivals_size, int* arrivals, int departures_size, int* departures, int flights) {\n    sort(arrivals, arrivals + arrivals_size);\n    sort(departures, departures + departures_size);\n    int gate = 1;\n    int final = 0;\n    int i = 1, j = 0;\n    while(i < flights && j < flights){\n        if (arrivals[i] < departures[j]) {\n            gate += 1;\n            i += 1;\n            if (gate >)\n        }\n    }\n    for (int i = 1; i < flights; i++){\n      printf(\"%d\",arrivals[i]);\n    }\n    \n    /* int gate = 1;\n    int maxGate = 0;\n \n\tint j = 0;\n\tint count = 0;\n    for(int i=1; i<flights; i++){\n        while(j < i){\n \n            if(arrivals[i] > departures[j]){\n                   gate = gate - 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n                    count++;\n               }\n            else if(arrivals[i] <= departures[j]){\n                    gate = gate + 1;\n                    if(maxGate < gate){\n                        maxGate = gate;\n                    }\n            }\n            j++;\n        }\n        j = count;\n        count = 0;\n    }\n \n    return maxGate;\n    */\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res;\n    \n    int _arrivals_size = 0;\n    int _arrivals_i;\n    scanf(\"%d\\n\", &_arrivals_size);\n    int _arrivals[_arrivals_size];\n    for(_arrivals_i = 0; _arrivals_i < _arrivals_size; _arrivals_i++) {\n        int _arrivals_item;\n        scanf(\"%d\", &_arrivals_item);\n        \n        _arrivals[_arrivals_i] = _arrivals_item;\n    }\n    \n    \n    int _departures_size = 0;\n    int _departures_i;\n    scanf(\"%d\\n\", &_departures_size);\n    int _departures[_departures_size];\n    for(_departures_i = 0; _departures_i < _departures_size; _departures_i++) {\n        int _departures_item;\n        scanf(\"%d\", &_departures_item);\n        \n        _departures[_departures_i] = _departures_item;\n    }\n    \n    int _flights;\n    scanf(\"%d\", &_flights);\n    \n    res = findMinGates(_arrivals_size, _arrivals, _departures_size, _departures, _flights);\n    fprintf(f, \"%d\\n\", res);\n    \n    fclose(f);\n    return 0;\n}\n\n","offset":587,"fileType":"c","requestStartTime":1518012222175}}
{"body": {"column":12,"line":12,"wordToComplete":"0.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() {\n   int r=3,gp=0.5,n,i;\n    scanf(\"%d\",&n);\n    for(i=0.;i<=n;i++)\n    {\n        gp=gp*pow(r,i);\n    \n    printf(\"%d\",gp);\n    }\n      \n    return 0;\n}\n\n","offset":209,"fileType":"c","requestStartTime":1518013955346}}
{"body": {"column":22,"line":10,"wordToComplete":"0.","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() {\n   int r=3,gp,n,i,a=0.;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        ;\n    \n    printf(\"%d\",gp);\n    }\n      \n    return 0;\n}\n\n","offset":176,"fileType":"c","requestStartTime":1518014037697}}
{"body": {"column":40,"line":11,"wordToComplete":"Welcome to 30 Days of Code!.\"","code":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    char input_string[105]; \n   \n    scanf(\"%[^\\n]\", input_string); \n  \n    printf(\"Hello, World.\\n\");\n    printf(\"Welcome to 30 Days of Code!.\");\n\n    \n    return 0;\n}\n\n","offset":235,"fileType":"c","requestStartTime":1518015628070}}
{"body": {"column":25,"line":32,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct Piece {\n   char name;\n   int r;\n   int c;\n};\n\nstruct Pieces {\n   Piece[8] piece;\n   int size;\n};\n\nbool discoverCheckToWhite(char board[8][8], int c) {\n    int cDreta = c+1;\n    char pDreta = \n    while (cDreta < 8)\n}\n\nint waysToGiveACheck(char board[8][8]) {\n    // Complete this function\n    struct Pieces pieces;\n    for (int i = 0; i < 8; ++i) {\n        for (int j = 0; j < 8; ++j) {\n            if(board[i][j] != '#') {\n                ++pieces.\n            }\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint main() {\n    int t; \n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[8][8];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 8; board_j++) {\n                scanf(\"%c\",&board[board_i][board_j]);\n                if (board[board_i][board_j] == '\\n') scanf(\"%c\",&board[board_i][board_j]);\n           }\n        }\n        int result = waysToGiveACheck(board);\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}\n\n\n","offset":597,"fileType":"c","requestStartTime":1518016278212}}
{"body": {"column":14,"line":32,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\nint main() {\n    int y,a[]={31,28,31,30,31,30,31,31,30,31,30,31},i,sum=0,k; \n    scanf(\"%d\", &y);\n   if(y<1918)\n   {\n       if(y%4==0)\n        a[1]=29;\n       for(i=0;i<12;i++)\n       {\n           if(sum<256)\n           {\n               sum=sum+a[i];\n           }\n           else\n           {\n               sum=sum-a[i-1];\n               k=i;\n               break;\n           }\n       }\n       sum=sum-256;\n       sum=sum*-1;\n       printf(\"%d.0%d.%d\",sum,i,y);\n   }\n    else if(y>1918)\n   {\n       if(y%4==0)\n        a[1]=29;\n       for(i=0;i<12;i++)\n       {\n           if(sum<256)\n           {\n               sum=sum+a[i];\n           }\n           else\n           {\n               sum=sum-a[i-1];\n               k=i;\n               break;\n           }\n       }\n       sum=sum-256;\n       sum=sum*-1;\n       printf(\"%d.0%d.%d\",sum,i,y);\n   }\n    else\n    {\n       a[1]=15;\n       for(i=0;i<12;i++)\n       {\n           if(sum<256)\n           {\n               sum=sum+a[i];\n           }\n           else\n           {\n               sum=sum-a[i-1];\n               k=i;\n               break;\n           }\n       }\n       sum=sum-256;\n       sum=sum*-1;\n       printf(\"%d.0%d.%d\",sum,i,y);\n    }\n    return 0;\n}\n\n\n","offset":622,"fileType":"c","requestStartTime":1518016439870}}
{"body": {"column":14,"line":21,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M;\n    scanf(\"%d\",&M);\n    \n    struct Node *node = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        node = (struct Node*)malloc(struct Node);\n        node->\n    }\n\n    return 0;\n}\n\n\n","offset":398,"fileType":"c","requestStartTime":1518016922931}}
{"body": {"column":16,"line":12,"wordToComplete":"0.","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n/*\n * Complete the function below.\n */\nint* findMax(int N, int numbers_size, int* numbers, int* result_size) {\n    for(int i=0.)\n\n\n}\n\nint main() {\n    FILE *f = fopen(getenv(\"OUTPUT_PATH\"), \"w\");\n    int res_size;\n    int* res;\n    int _N;\n    scanf(\"%d\", &_N);\n    \n    \n    int _numbres_size = 0;\n    int _numbres_i;\n    scanf(\"%d\\n\", &_numbres_size);\n    int _numbres[_numbres_size];\n    for(_numbres_i = 0; _numbres_i < _numbres_size; _numbres_i++) {\n        int _numbres_item;\n        scanf(\"%d\", &_numbres_item);\n        \n        _numbres[_numbres_i] = _numbres_item;\n    }\n    \n    res = findMax(_N, _numbres_size, _numbres, &res_size);\n    int res_i;\n    for(res_i=0; res_i < res_size; res_i++) {\n    \n        fprintf(f, \"%d\\n\", res[res_i]);\n        \n    }\n    \n    \n    fclose(f);\n    return 0;\n}\n\n","offset":267,"fileType":"c","requestStartTime":1518016997531}}
{"body": {"column":35,"line":14,"wordToComplete":"","code":"#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\n\n/*\n * Complete the function below.\n */\nchar* electionWinner(int votes_size, char** votes) {\n    \n    for (int i = 0; i < votes_size.)\n\n}\n\nint main()\n{\n    FILE *f = stdout;\n    char *output_path = getenv(\"OUTPUT_PATH\");\n    if (output_path) {\n        f = fopen(output_path, \"w\");\n    }\n\n    char* res;\n    int votes_size = 0;\n    scanf(\"%d\\n\", &votes_size);\n\n    char* votes[votes_size];\n    for(int i = 0; i < votes_size; i++) {\n        char* votes_item;\n        votes_item = (char *)malloc(512000 * sizeof(char));\n        scanf(\"\\n%[^\\n]\",votes_item);\n        votes[i] = votes_item;\n    }\n\n    res = electionWinner(votes_size, votes);\n    fprintf(f, \"%s\\n\", res);\n\n    fclose(f);\n    return 0;\n}\n\n","offset":273,"fileType":"c","requestStartTime":1518017051953}}
{"body": {"column":10,"line":13,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int value){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        \n    }\n\n    return 0;\n}\n\n\n","offset":252,"fileType":"c","requestStartTime":1518017207025}}
{"body": {"column":10,"line":14,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int val){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->value = val;\n    node->\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        \n    }\n\n    return 0;\n}\n\n\n","offset":273,"fileType":"c","requestStartTime":1518017222180}}
{"body": {"column":16,"line":30,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int val){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->value = val;\n    node->next = head;\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M, length;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        length++;\n    }\n    \n    while(head->)\n\n    return 0;\n}\n\n\n","offset":563,"fileType":"c","requestStartTime":1518017409293}}
{"body": {"column":19,"line":33,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int val){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->value = val;\n    node->next = head;\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M, length;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        length++;\n    }\n    \n    for(i=0; i<M; i++){\n        if(head == NULL)\n            return;\n        head=head->\n    }\n\n    return 0;\n}\n\n\n","offset":635,"fileType":"c","requestStartTime":1518017539525}}
{"body": {"column":38,"line":32,"wordToComplete":"we can promote this piece....","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint max ( int a, int b ) { if (a>b) { return(a); } return(b); }\n\nint waysToGiveACheck ( int board_size_rows, int board_size_cols, char** board ) {\n  int temp_rv,rv;\n  long r,c,row,col,blocked,found;\n  long black_k_row,black_k_col;\n  \n  // piece to put into check is 'k'\n  for (row=0;row<8;row++) {\n    for (col=0;col<8;col++) {\n      if (board[row][col]=='k') {\n        black_k_row = row; black_k_col = col;\n      }\n    }\n  }\n//printf(\"Black King at %ld,%ld\\n\",black_k_row,black_k_col); fflush(stdout);\n  \n  // piece to promote comes from row 1 and is 'P'\n  rv = 0;\n  for (col=0;col<8;col++) {\n    temp_rv = 0;\n    if ((board[1][col]=='P')&&(board[0][col]=='#')) {\n//printf(\"  Pawn at col %ld\\n\",col); fflush(stdout);\n      // we can promote this piece....\n\n      // look for discovered check\n      found = 0;\n      // move the current pawn under consideration\n      board[1][col] = '#';\n      // look all around the king for check from queen, bishop, or rook\n      //   the knight and pawn can not be a discovered check because black would already\n      //   have had to move their king to get out of that check before it is the next white move\n      \n      // look right\n      found = 0;\n      blocked = 0;\n      for (r=black_k_row,c=(black_k_col+1);((r<8)&&(c<8));c++) {\n        if ((board[r][c]=='Q')||(board[r][c]=='R')) {\n          found = 1; break;\n        } else if (board[r][c]!='#') {\n          blocked = 1; break;\n        }\n      }\n      if (found==0) {\n        // look left\n        found = 0;\n        blocked = 0;\n        for (r=black_k_row,c=(black_k_col-1);((r<8)&&(c>=0));c--) {\n          if ((board[r][c]=='Q')||(board[r][c]=='R')) {\n            found = 1; break;\n          } else if (board[r][c]!='#') {\n            blocked = 1; break;\n          }\n        }\n      }\n      if (found==0) {\n        // look up\n        found = 0;\n        blocked = 0;\n        for (r=(black_k_row-1),c=(black_k_col);((r>=0)&&(c<8));r--) {\n          if ((board[r][c]=='Q')||(board[r][c]=='R')) {\n            found = 1; break;\n          } else if (board[r][c]!='#') {\n            blocked = 1; break;\n          }\n        }\n      }\n      if (found==0) {\n        // look down\n        found = 0;\n        blocked = 0;\n        for (r=(black_k_row+1),c=(black_k_col);((r<8)&&(c<8));r++) {\n          if ((board[r][c]=='Q')||(board[r][c]=='R')) {\n            found = 1; break;\n          } else if (board[r][c]!='#') {\n            blocked = 1; break;\n          }\n        }\n      }\n      if (found==0) {\n        // look diagonal up left\n        found = 0;\n        blocked = 0;\n        for (r=(black_k_row-1),c=(black_k_col+1);((r>=0)&&(c>=0));r--,c--) {\n          if ((board[r][c]=='Q')||(board[r][c]=='B')) {\n            found = 1; break;\n          } else if (board[r][c]!='#') {\n            blocked = 1; break;\n          }\n        }\n      }\n      if (found==0) {\n        // look diagonal up right\n        found = 0;\n        blocked = 0;\n        for (r=(black_k_row-1),c=(black_k_col+1);((r>=0)&&(c<8));r--,c++) {\n          if ((board[r][c]=='Q')||(board[r][c]=='B')) {\n            found = 1; break;\n          } else if (board[r][c]!='#') {\n            blocked = 1; break;\n          }\n        }\n      }\n      if (found==0) {\n        // look diagonal down left\n        found = 0;\n        blocked = 0;\n        for (r=(black_k_row+1),c=(black_k_col-1);((r<8)&&(c>=0));r++,c--) {\n          if ((board[r][c]=='Q')||(board[r][c]=='B')) {\n            found = 1; break;\n          } else if (board[r][c]!='#') {\n            blocked = 1; break;\n          }\n        }\n      }\n      if (found==0) {\n        // look diagonal down right\n        found = 0;\n        blocked = 0;\n        for (r=(black_k_row+1),c=(black_k_col-1);((r<8)&&(c<8));r++,c++) {\n          if ((board[r][c]=='Q')||(board[r][c]=='B')) {\n            found = 1; break;\n          } else if (board[r][c]!='#') {\n            blocked = 1; break;\n          }\n        }\n      }\n      \n      if ((found==1)&&(blocked==0)) {\n        temp_rv = 4;\n      }\n      \n      if (found==0) {\n        \n        if (black_k_row==0) {\n          // same row\n//printf(\"    Black King in same row as promoted pawn\\n\"); fflush(stdout);\n          if (black_k_col<col) {\n            // see if there is a piece in the way to the left\n            found = 0;\n            blocked = 0;\n            for (c=(col-1);c>=0;c--) {\n              if (board[0][c]=='k') {\n                found = 1;\n                break;\n              } else if (board[0][c]!='#') {\n                blocked = 1;\n                break;\n              }\n            }\n          } else {\n            // see if there is a piece in the way to the right\n            found = 0;\n            blocked = 0;\n            for (c=(col+1);c<8;c++) {\n              if (board[0][c]=='k') {\n                found = 1;\n                break;\n              } else if (board[0][c]!='#') {\n                blocked = 1;\n                break;\n              }\n            }\n          }\n          if ((found==1)&&(blocked==0)) {\n            temp_rv = 2; // queen and rook across the row\n          }\n        } else if (black_k_col==col) {\n//printf(\"    Black King in same col as promoted pawn\\n\"); fflush(stdout);\n          // same col\n          found = 0;\n          blocked = 0;\n          for (r=2;r<8;r++) {\n            if (board[r][col]=='k') {\n              found = 1;\n              break;\n            } else if (board[r][col]!='#') {\n              blocked = 1;\n              break;\n            }          \n          }\n          if ((found==1)&&(blocked==0)) {\n            temp_rv = 2; // queen and rook down the column\n          }        \n        } else {\n          // stepped (knight) or diagonal (bishop and queen)\n//printf(\"    Black King not in promoted row or col - check knight locations\\n\"); fflush(stdout);\n          found = 0;\n          if (col>0) {\n            if (board[2][col-1]=='k') {\n              found = 1;\n              temp_rv = 1;\n            }\n          }\n          if (col>1) {\n            if (board[1][col-2]=='k') {\n              found = 1;\n              temp_rv = 1;\n            }\n          }\n          if (col<7) {\n            if (board[2][col+1]=='k') {\n              found = 1;\n              temp_rv = 1;\n            }\n          }\n          if (col<6) {\n            if (board[1][col+2]=='k') {\n              found = 1;\n              temp_rv = 1;\n            }\n          }\n        \n          if (found==0) {\n//printf(\"    Black King can now only be on a diagonal - check\\n\"); fflush(stdout);\n            // check the diagonals\n            found = 0;\n            blocked = 0;\n            for (r=1,c=(col-1);((r<8)&&(c>=0));r++,c--) {\n              if (board[r][c]=='k') {\n                found = 1;\n                break;\n              } else if (board[r][c]!='#') {\n                blocked = 1;\n                break;\n              }\n            }\n            if ((found==1)&&(blocked==0)) {\n              temp_rv = 2; // queen and bishop\n            }\n          \n            found = 0;\n            blocked = 0;\n            for (r=1,c=(col+1);((r<8)&&(c<8));r++,c++) {\n              if (board[r][c]=='k') {\n                found = 1;\n                break;\n              } else if (board[r][c]!='#') {\n                blocked = 1;\n                break;\n              }\n            }\n            if ((found==1)&&(blocked==0)) {\n              temp_rv = 2; // queen and bishop\n            }\n          }\n        \n        }\n      }\n\n      // put the piece back where it was...\n      board[1][col] = 'P';\n      \n    }\n    rv = max(rv,temp_rv);\n  }\n  \n  return(rv);\n}\n\nint main() {\n  int x,t,test,result;\n  char *s,**board;\n  int board_i,board_j;\n  \n  s = (char *)malloc(64*sizeof(char));\n  board = (char **)malloc(8*sizeof(char *));\n  for (x=0;x<8;x++) {\n    board[x] = (char *)malloc(8*sizeof(char));\n  }\n  \n  scanf(\"%i\", &t);\n  for (test=0;test<t;test++) {\n    for (board_i=0;board_i<8;board_i++) {\n      scanf(\"%s\",s);\n      for (board_j=0;board_j<8;board_j++) {\n        board[board_i][board_j] = s[board_j];\n      }\n    }\n    result = waysToGiveACheck((int)8,(int)8,board);\n    printf(\"%d\\n\", result);\n  }\n  \n  return 0;\n}\n\n\n","offset":897,"fileType":"c","requestStartTime":1518017664142}}
{"body": {"column":16,"line":36,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int val){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->value = val;\n    node->next = head;\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M, length;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        length++;\n    }\n    \n    for(i=0; i<M; i++){\n        if(head == NULL)\n            return nil;\n        head=head->next;\n    }\n    \n    while(head->)\n\n    return 0;\n}\n\n\n","offset":672,"fileType":"c","requestStartTime":1518017774803}}
{"body": {"column":26,"line":43,"wordToComplete":"","code":"\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n#include <stdbool.h>\n\nstruct Piece {\n   char name;\n   int r;\n   int c;\n};\n\nstruct Pieces {\n   struct Piece piece[8];\n   int size;\n};\n\nbool discoverCheckToWhite(char board[8][8], int c) {\n    int cDreta = c+1;\n    return false;\n}\n\nint waysToGiveACheck(char board[8][8]) {\n    // Complete this function\n    struct Pieces allPieces;\n    allPieces.size = 0;\n    struct Piece wKing;\n    struct Piece bKing;\n    for (int i = 0; i < 8; ++i) {\n        for (int j = 0; j < 8; ++j) {\n            if(board[i][j] != '#') {\n                struct Piece newPiece;\n                newPiece.name = board[i][j];\n                newPiece.r = i;\n                newPiece.c = j;\n                allPieces.piece[allPieces.size] = newPiece;\n                ++allPieces.size;\n                if (newPiece.name == 'K') {\n                    printf(\"%d\\n\", newPiece.name);\n                    wKing = newPiece;\n                    wKing. = newPiece;\n                    printf(\"%d\\n\", newPiece.name);\n                }\n                else if (newPiece.name == 'k') bKing = newPiece;\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int t; \n    scanf(\"%i\", &t);\n    for(int a0 = 0; a0 < t; a0++){\n        char board[8][8];\n        for (int board_i = 0; board_i < 8; board_i++) {\n           for (int board_j = 0; board_j < 8; board_j++) {\n                scanf(\"%c\",&board[board_i][board_j]);\n                if (board[board_i][board_j] == '\\n') scanf(\"%c\",&board[board_i][board_j]);\n           }\n        }\n        int result = waysToGiveACheck(board);\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}\n\n\n","offset":1031,"fileType":"c","requestStartTime":1518017826248}}
{"body": {"column":19,"line":39,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int val){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->value = val;\n    node->next = head;\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M, length;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        length++;\n    }\n    struct Node *temp;\n    temp = head;\n    \n    for(i=0; i<M-1; i++){\n        if(head == NULL)\n            return nil;\n        head=head->next;\n    }\n    \n    while(head->next != NULL){\n        temp=temp->\n    }\n\n    return 0;\n}\n\n\n","offset":748,"fileType":"c","requestStartTime":1518017904080}}
{"body": {"column":17,"line":42,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int val){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->value = val;\n    node->next = head;\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M, length;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        length++;\n    }\n    struct Node *temp;\n    temp = head;\n    \n    for(i=0; i<M-1; i++){\n        if(head == NULL)\n            return nil;\n        head=head->next;\n    }\n    \n    while(head->next != NULL){\n        temp=temp->next;\n    }\n    \n    printf(temp->)\n\n    return 0;\n}\n\n\n","offset":782,"fileType":"c","requestStartTime":1518017914206}}
{"body": {"column":21,"line":19,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int val){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->value = val;\n    node->next = head;\n}\n\nvoid printList(struct Node *head){\n    while(head != NULL){\n        printf(head->)\n    }\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M, length, i;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        length++;\n    }\n    \n    printList(head);\n    \n    struct Node *temp;\n    temp = head;\n    \n    for(i=0; i<M-1; i++){\n        if(head == NULL)\n            return 0;\n        head=head->next;\n    }\n    \n    while(head->next != NULL){\n        temp=temp->next;\n    }\n    \n    printf(\"%d\\n\",temp->value);\n\n    return 0;\n}\n\n\n","offset":370,"fileType":"c","requestStartTime":1518018071926}}
{"body": {"column":22,"line":19,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int val){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->value = val;\n    node->next = head;\n}\n\nvoid printList(struct Node *head){\n    while(head != NULL){\n        printf(\"%d\\n\".head->value)\n    }\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M, length, i;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        length++;\n    }\n    \n    printList(head);\n    \n    struct Node *temp;\n    temp = head;\n    \n    for(i=0; i<M-1; i++){\n        if(head == NULL)\n            return 0;\n        head=head->next;\n    }\n    \n    while(head->next != NULL){\n        temp=temp->next;\n    }\n    \n    printf(\"%d\\n\",temp->value);\n\n    return 0;\n}\n\n\n","offset":371,"fileType":"c","requestStartTime":1518018080226}}
{"body": {"column":21,"line":20,"wordToComplete":"","code":"\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct Node{\n    int value;\n    struct Node *next;\n};\n\nvoid push(struct Node *head,int val){\n    struct Node *node = (struct Node*)malloc(sizeof(struct Node));\n    node->value = val;\n    node->next = head;\n}\n\nvoid printList(struct Node *head){\n    while(head != NULL){\n        printf(\"%d\\n\",head->value);\n        head = head->\n    }\n}\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    int M, length, i;\n    scanf(\"%d\",&M);\n    \n    struct Node *head = NULL;\n    \n    while(scanf(\"%d\",&i) == 1){\n        push(head,i);\n        length++;\n    }\n    \n    printList(head);\n    \n    struct Node *temp;\n    temp = head;\n    \n    for(i=0; i<M-1; i++){\n        if(head == NULL)\n            return 0;\n        head=head->next;\n    }\n    \n    while(head->next != NULL){\n        temp=temp->next;\n    }\n    \n    printf(\"%d\\n\",temp->value);\n\n    return 0;\n}\n\n\n","offset":406,"fileType":"c","requestStartTime":1518018089727}}
