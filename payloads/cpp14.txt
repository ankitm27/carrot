{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\ns","fileType":"cpp14","line":12,"column":1,"wordToComplete":"s","offset":323}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nst","fileType":"cpp14","line":12,"column":2,"wordToComplete":"st","offset":324}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nst","fileType":"cpp14","line":12,"column":2,"wordToComplete":"st","offset":324}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstr","fileType":"cpp14","line":12,"column":3,"wordToComplete":"str","offset":325}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstr","fileType":"cpp14","line":12,"column":3,"wordToComplete":"str","offset":325}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstru","fileType":"cpp14","line":12,"column":4,"wordToComplete":"stru","offset":326}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstruc","fileType":"cpp14","line":12,"column":5,"wordToComplete":"struc","offset":327}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstruc","fileType":"cpp14","line":12,"column":5,"wordToComplete":"struc","offset":327}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstruc","fileType":"cpp14","line":12,"column":5,"wordToComplete":"struc","offset":327}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstruct","fileType":"cpp14","line":12,"column":6,"wordToComplete":"struct","offset":328}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstruct c","fileType":"cpp14","line":12,"column":8,"wordToComplete":"c","offset":330}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstruct ca","fileType":"cpp14","line":12,"column":9,"wordToComplete":"ca","offset":331}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstruct car","fileType":"cpp14","line":12,"column":10,"wordToComplete":"car","offset":332}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstruct cart","fileType":"cpp14","line":12,"column":11,"wordToComplete":"cart","offset":333}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nstruct card","fileType":"cpp14","line":12,"column":11,"wordToComplete":"card","offset":333}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\ne\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":1,"wordToComplete":"e","offset":323}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nc\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":1,"wordToComplete":"c","offset":323}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\ne\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":1,"wordToComplete":"e","offset":323}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum c\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":6,"wordToComplete":"c","offset":328}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum cl\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":7,"wordToComplete":"cl","offset":329}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum cla\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":8,"wordToComplete":"cla","offset":330}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum clas\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":9,"wordToComplete":"clas","offset":331}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":10,"wordToComplete":"class","offset":332}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class s\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":12,"wordToComplete":"s","offset":334}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit\nstruct card {\n    \n}","fileType":"cpp14","line":12,"column":15,"wordToComplete":"suit","offset":337}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    S\n}\nstruct card {\n    \n}","fileType":"cpp14","line":13,"column":5,"wordToComplete":"S","offset":345}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SP\n}\nstruct card {\n    \n}","fileType":"cpp14","line":13,"column":6,"wordToComplete":"SP","offset":346}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPA\n}\nstruct card {\n    \n}","fileType":"cpp14","line":13,"column":7,"wordToComplete":"SPA","offset":347}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPAD\n}\nstruct card {\n    \n}","fileType":"cpp14","line":13,"column":8,"wordToComplete":"SPAD","offset":348}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADE\n}\nstruct card {\n    \n}","fileType":"cpp14","line":13,"column":9,"wordToComplete":"SPADE","offset":349}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES\n}\nstruct card {\n    \n}","fileType":"cpp14","line":13,"column":10,"wordToComplete":"SPADES","offset":350}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    H\n}\nstruct card {\n    \n}","fileType":"cpp14","line":14,"column":5,"wordToComplete":"H","offset":357}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HE\n}\nstruct card {\n    \n}","fileType":"cpp14","line":14,"column":6,"wordToComplete":"HE","offset":358}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEA\n}\nstruct card {\n    \n}","fileType":"cpp14","line":14,"column":7,"wordToComplete":"HEA","offset":359}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEAR\n}\nstruct card {\n    \n}","fileType":"cpp14","line":14,"column":8,"wordToComplete":"HEAR","offset":360}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEART\n}\nstruct card {\n    \n}","fileType":"cpp14","line":14,"column":9,"wordToComplete":"HEART","offset":361}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    D\n}\nstruct card {\n    \n}","fileType":"cpp14","line":15,"column":5,"wordToComplete":"D","offset":369}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DI\n}\nstruct card {\n    \n}","fileType":"cpp14","line":15,"column":6,"wordToComplete":"DI","offset":370}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIA\n}\nstruct card {\n    \n}","fileType":"cpp14","line":15,"column":7,"wordToComplete":"DIA","offset":371}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAM\n}\nstruct card {\n    \n}","fileType":"cpp14","line":15,"column":8,"wordToComplete":"DIAM","offset":372}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAMO\n}\nstruct card {\n    \n}","fileType":"cpp14","line":15,"column":9,"wordToComplete":"DIAMO","offset":373}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAMON\n}\nstruct card {\n    \n}","fileType":"cpp14","line":15,"column":10,"wordToComplete":"DIAMON","offset":374}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAMOND\n}\nstruct card {\n    \n}","fileType":"cpp14","line":15,"column":11,"wordToComplete":"DIAMOND","offset":375}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS\n}\nstruct card {\n    \n}","fileType":"cpp14","line":15,"column":12,"wordToComplete":"DIAMONDS","offset":376}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    C\n}\nstruct card {\n    \n}","fileType":"cpp14","line":16,"column":5,"wordToComplete":"C","offset":383}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CL\n}\nstruct card {\n    \n}","fileType":"cpp14","line":16,"column":6,"wordToComplete":"CL","offset":384}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLU\n}\nstruct card {\n    \n}","fileType":"cpp14","line":16,"column":7,"wordToComplete":"CLU","offset":385}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUB\n}\nstruct card {\n    \n}","fileType":"cpp14","line":16,"column":8,"wordToComplete":"CLUB","offset":386}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS\n}\nstruct card {\n    \n}","fileType":"cpp14","line":16,"column":9,"wordToComplete":"CLUBS","offset":387}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit s\n}","fileType":"cpp14","line":21,"column":10,"wordToComplete":"s","offset":418}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit su\n}","fileType":"cpp14","line":21,"column":11,"wordToComplete":"su","offset":419}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit sui\n}","fileType":"cpp14","line":21,"column":12,"wordToComplete":"sui","offset":420}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit\n}","fileType":"cpp14","line":21,"column":13,"wordToComplete":"suit","offset":421}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    u\n}","fileType":"cpp14","line":22,"column":5,"wordToComplete":"u","offset":428}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned i\n}","fileType":"cpp14","line":22,"column":14,"wordToComplete":"i","offset":437}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned in\n}","fileType":"cpp14","line":22,"column":15,"wordToComplete":"in","offset":438}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int\n}","fileType":"cpp14","line":22,"column":16,"wordToComplete":"int","offset":439}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int r\n}","fileType":"cpp14","line":22,"column":18,"wordToComplete":"r","offset":441}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int ra\n}","fileType":"cpp14","line":22,"column":19,"wordToComplete":"ra","offset":442}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank\n}","fileType":"cpp14","line":22,"column":21,"wordToComplete":"rank","offset":444}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nc","fileType":"cpp14","line":25,"column":1,"wordToComplete":"c","offset":450}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\ncl","fileType":"cpp14","line":25,"column":2,"wordToComplete":"cl","offset":451}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\ncla","fileType":"cpp14","line":25,"column":3,"wordToComplete":"cla","offset":452}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass D","fileType":"cpp14","line":25,"column":7,"wordToComplete":"D","offset":456}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass De","fileType":"cpp14","line":25,"column":8,"wordToComplete":"De","offset":457}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Dec","fileType":"cpp14","line":25,"column":9,"wordToComplete":"Dec","offset":458}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass D","fileType":"cpp14","line":25,"column":7,"wordToComplete":"D","offset":456}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass De","fileType":"cpp14","line":25,"column":8,"wordToComplete":"De","offset":457}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Dec","fileType":"cpp14","line":25,"column":9,"wordToComplete":"Dec","offset":458}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck","fileType":"cpp14","line":25,"column":10,"wordToComplete":"Deck","offset":459}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    D\n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":5,"wordToComplete":"D","offset":467}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    p\n    Deck() {}\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":5,"wordToComplete":"p","offset":467}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    pub\n    Deck() {}\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":7,"wordToComplete":"pub","offset":469}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    pub\n    Deck() {}\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":7,"wordToComplete":"pub","offset":469}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    publ\n    Deck() {}\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":8,"wordToComplete":"publ","offset":470}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    publi\n    Deck() {}\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":9,"wordToComplete":"publi","offset":471}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public\n    Deck() {}\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":10,"wordToComplete":"public","offset":472}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        r\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":28,"column":9,"wordToComplete":"r","offset":496}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        re\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":28,"column":10,"wordToComplete":"re","offset":497}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        res\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":28,"column":11,"wordToComplete":"res","offset":498}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        rese\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":28,"column":12,"wordToComplete":"rese","offset":499}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":28,"column":13,"wordToComplete":"reset","offset":500}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    r\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":5,"wordToComplete":"r","offset":520}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    re\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":6,"wordToComplete":"re","offset":521}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    rese\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":8,"wordToComplete":"rese","offset":523}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    reset\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":9,"wordToComplete":"reset","offset":524}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    v\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":5,"wordToComplete":"v","offset":520}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    vo\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":6,"wordToComplete":"vo","offset":521}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void r\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":10,"wordToComplete":"r","offset":525}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void re\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":11,"wordToComplete":"re","offset":526}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void res\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":12,"wordToComplete":"res","offset":527}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void rese\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":13,"wordToComplete":"rese","offset":528}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":31,"column":14,"wordToComplete":"reset","offset":529}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        d\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":32,"column":9,"wordToComplete":"d","offset":543}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":32,"column":12,"wordToComplete":"deck","offset":546}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":32,"column":13,"wordToComplete":".","offset":547}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.c\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":32,"column":14,"wordToComplete":"c","offset":548}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.cl\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":32,"column":15,"wordToComplete":"cl","offset":549}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.cle\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":32,"column":16,"wordToComplete":"cle","offset":550}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clea\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":32,"column":17,"wordToComplete":"clea","offset":551}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":32,"column":18,"wordToComplete":"clear","offset":552}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        f\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":33,"column":9,"wordToComplete":"f","offset":565}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        fo\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":33,"column":10,"wordToComplete":"fo","offset":566}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            f\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":34,"column":13,"wordToComplete":"f","offset":585}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            fo\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":34,"column":14,"wordToComplete":"fo","offset":586}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                d\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":37,"column":17,"wordToComplete":"d","offset":651}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                deck\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":37,"column":20,"wordToComplete":"deck","offset":654}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                C\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":37,"column":17,"wordToComplete":"C","offset":651}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card c\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":37,"column":22,"wordToComplete":"c","offset":656}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card ca\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":37,"column":23,"wordToComplete":"ca","offset":657}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card car\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":37,"column":24,"wordToComplete":"car","offset":658}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card card\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":37,"column":25,"wordToComplete":"card","offset":659}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card card = {};\n                d\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":38,"column":17,"wordToComplete":"d","offset":683}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card card = {};\n                deck\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":38,"column":20,"wordToComplete":"deck","offset":686}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card card = {};\n                deck.\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":38,"column":21,"wordToComplete":".","offset":687}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card card = {};\n                deck.p\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":38,"column":22,"wordToComplete":"p","offset":688}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card card = {};\n                deck.pu\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":38,"column":23,"wordToComplete":"pu","offset":689}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card card = {};\n                deck.pus\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":38,"column":24,"wordToComplete":"pus","offset":690}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for() {\n                //rank\n                Card card = {};\n                deck.push\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":38,"column":25,"wordToComplete":"push","offset":691}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\ns\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":1,"wordToComplete":"s","offset":450}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nst\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":2,"wordToComplete":"st","offset":451}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nsta\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":3,"wordToComplete":"sta","offset":452}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstat\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":4,"wordToComplete":"stat","offset":453}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstati\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":5,"wordToComplete":"stati","offset":454}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic c\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":8,"wordToComplete":"c","offset":457}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic co\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":9,"wordToComplete":"co","offset":458}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic con\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":10,"wordToComplete":"con","offset":459}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic con\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":10,"wordToComplete":"con","offset":459}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic cons\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":11,"wordToComplete":"cons","offset":460}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic const\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":12,"wordToComplete":"const","offset":461}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic conste\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":13,"wordToComplete":"conste","offset":462}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constep\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":14,"wordToComplete":"constep","offset":463}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constex\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":14,"wordToComplete":"constex","offset":463}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexp\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":15,"wordToComplete":"constexp","offset":464}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":16,"wordToComplete":"constexpr","offset":465}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr u\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":18,"wordToComplete":"u","offset":467}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned i\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":27,"wordToComplete":"i","offset":476}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned in\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":28,"wordToComplete":"in","offset":477}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":29,"wordToComplete":"int","offset":478}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int M\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":31,"wordToComplete":"M","offset":480}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MA\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":32,"wordToComplete":"MA","offset":481}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for() {\n            //suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":25,"column":33,"wordToComplete":"MAX","offset":482}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            S\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":13,"wordToComplete":"S","offset":667}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit s\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":18,"wordToComplete":"s","offset":672}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit su\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":19,"wordToComplete":"su","offset":673}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit sui\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":20,"wordToComplete":"sui","offset":674}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suie\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":21,"wordToComplete":"suie","offset":675}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":21,"wordToComplete":"suit","offset":675}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = s\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":25,"wordToComplete":"s","offset":679}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<s\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":37,"wordToComplete":"s","offset":691}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":40,"wordToComplete":"suit","offset":694}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<sS\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":38,"wordToComplete":"sS","offset":692}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<s\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":37,"wordToComplete":"s","offset":691}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<sS\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":38,"wordToComplete":"sS","offset":692}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<S\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":37,"wordToComplete":"S","offset":691}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<STui\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":40,"wordToComplete":"STui","offset":694}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<Su\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":38,"wordToComplete":"Su","offset":692}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<Sui\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":39,"wordToComplete":"Sui","offset":693}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int = 0; i < MAX_CLASS; i++) {\n            Suit suit = static_cast<Suit\n            for(unsigned int i = 0; i < MAX_RANK; I++;) {\n                //rank\n                Card card = {};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":36,"column":40,"wordToComplete":"Suit","offset":694}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\ns\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":1,"wordToComplete":"s","offset":495}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nst\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":2,"wordToComplete":"st","offset":496}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nsta\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":3,"wordToComplete":"sta","offset":497}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstat\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":4,"wordToComplete":"stat","offset":498}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstati\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":5,"wordToComplete":"stati","offset":499}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstatic\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":6,"wordToComplete":"static","offset":500}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstatic c\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":8,"wordToComplete":"c","offset":502}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstatic co\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":9,"wordToComplete":"co","offset":503}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstatic con\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":10,"wordToComplete":"con","offset":504}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstatic cons\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":11,"wordToComplete":"cons","offset":505}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstatic conste\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":13,"wordToComplete":"conste","offset":507}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstatic constex\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":14,"wordToComplete":"constex","offset":508}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstatic constexp\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":15,"wordToComplete":"constexp","offset":509}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nstatic constexpr unsigned int MAX_RANK = 13;\nstatic constexpr\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":16,"wordToComplete":"constexpr","offset":510}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr u\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":11,"wordToComplete":"u","offset":498}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr usngie\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":16,"wordToComplete":"usngie","offset":503}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr usngied\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":17,"wordToComplete":"usngied","offset":504}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr un\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":12,"wordToComplete":"un","offset":499}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr unsigned i\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":20,"wordToComplete":"i","offset":507}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr unsigned in\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":21,"wordToComplete":"in","offset":508}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr unsigned in\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":21,"wordToComplete":"in","offset":508}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr unsigned int M\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":24,"wordToComplete":"M","offset":511}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr unsigned int MA\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":25,"wordToComplete":"MA","offset":512}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr unsigned int MAX\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":26,"wordToComplete":"MAX","offset":513}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int MAX_RANK = 13;\nconstexpr unsigned int MAX_SUIT = 4.\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < MAX_SUIT; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < MAX_RANK; rank++;) {\n                Card card = {suit, rank};\n                deck.push_back(card);\n            }\n        }\n    }\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":26,"column":36,"wordToComplete":".","offset":523}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    v\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":44,"column":5,"wordToComplete":"v","offset":902}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    vo\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":44,"column":6,"wordToComplete":"vo","offset":903}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    voi\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":44,"column":7,"wordToComplete":"voi","offset":904}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    void\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":44,"column":8,"wordToComplete":"void","offset":905}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    void\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":44,"column":8,"wordToComplete":"void","offset":905}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    void d\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":44,"column":10,"wordToComplete":"d","offset":907}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    void de\n    \n    vector<Card> deck;   \n}","fileType":"cpp14","line":44,"column":11,"wordToComplete":"de","offset":908}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    v\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":5,"wordToComplete":"v","offset":902}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    voi\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":7,"wordToComplete":"voi","offset":904}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    c\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":5,"wordToComplete":"c","offset":902}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    c\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":5,"wordToComplete":"c","offset":902}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    ca\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":6,"wordToComplete":"ca","offset":903}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    car\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":7,"wordToComplete":"car","offset":904}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    card\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":8,"wordToComplete":"card","offset":905}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    C\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":5,"wordToComplete":"C","offset":902}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    C\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":5,"wordToComplete":"C","offset":902}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card d\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":10,"wordToComplete":"d","offset":907}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card de\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":11,"wordToComplete":"de","offset":908}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card dea\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":12,"wordToComplete":"dea","offset":909}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":44,"column":13,"wordToComplete":"deal","offset":910}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        d\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":9,"wordToComplete":"d","offset":924}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        deck\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":12,"wordToComplete":"deck","offset":927}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        deck.\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":13,"wordToComplete":".","offset":928}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        deck.p\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":14,"wordToComplete":"p","offset":929}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        deck.po\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":15,"wordToComplete":"po","offset":930}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        deck.pop\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":16,"wordToComplete":"pop","offset":931}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        p\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":9,"wordToComplete":"p","offset":924}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        C\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":9,"wordToComplete":"C","offset":924}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card c\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":14,"wordToComplete":"c","offset":929}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card ca\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":15,"wordToComplete":"ca","offset":930}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card car\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":16,"wordToComplete":"car","offset":931}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":17,"wordToComplete":"card","offset":932}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = c\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":21,"wordToComplete":"c","offset":936}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = d\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":21,"wordToComplete":"d","offset":936}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":24,"wordToComplete":"deck","offset":939}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":25,"wordToComplete":".","offset":940}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.b\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":26,"wordToComplete":"b","offset":941}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.ba\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":27,"wordToComplete":"ba","offset":942}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.bac\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":28,"wordToComplete":"bac","offset":943}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back\n        return deck.pop_back();\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":45,"column":29,"wordToComplete":"back","offset":944}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        r\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":9,"wordToComplete":"r","offset":982}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        re\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":10,"wordToComplete":"re","offset":983}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        re\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":10,"wordToComplete":"re","offset":983}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        ret\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":11,"wordToComplete":"ret","offset":984}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        retu\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":12,"wordToComplete":"retu","offset":985}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        retur\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":13,"wordToComplete":"retur","offset":986}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        return\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":14,"wordToComplete":"return","offset":987}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        return c\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":16,"wordToComplete":"c","offset":989}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        return ca\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":17,"wordToComplete":"ca","offset":990}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        return car\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":18,"wordToComplete":"car","offset":991}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        Card card = deck.back();\n        deck.pop_back();\n        return card\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":47,"column":19,"wordToComplete":"card","offset":992}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    v\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":5,"wordToComplete":"v","offset":1078}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    vo\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":6,"wordToComplete":"vo","offset":1079}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    voi\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":7,"wordToComplete":"voi","offset":1080}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":8,"wordToComplete":"void","offset":1081}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void s\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":10,"wordToComplete":"s","offset":1083}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void sh\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":11,"wordToComplete":"sh","offset":1084}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shu\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":12,"wordToComplete":"shu","offset":1085}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuf\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":13,"wordToComplete":"shuf","offset":1086}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuff\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":14,"wordToComplete":"shuff","offset":1087}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffl\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":15,"wordToComplete":"shuffl","offset":1088}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":51,"column":16,"wordToComplete":"shuffle","offset":1089}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        f\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":53,"column":9,"wordToComplete":"f","offset":1148}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        fo\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":53,"column":10,"wordToComplete":"fo","offset":1149}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":53,"column":11,"wordToComplete":"for","offset":1150}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        foo\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":53,"column":11,"wordToComplete":"foo","offset":1150}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        foor\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":53,"column":12,"wordToComplete":"foor","offset":1151}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":53,"column":11,"wordToComplete":"for","offset":1150}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        f\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":53,"column":9,"wordToComplete":"f","offset":1148}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            i\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":13,"wordToComplete":"i","offset":1200}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            in\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":14,"wordToComplete":"in","offset":1201}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            in\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":14,"wordToComplete":"in","offset":1201}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            int\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":15,"wordToComplete":"int","offset":1202}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            int r\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":17,"wordToComplete":"r","offset":1204}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            int ra\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":18,"wordToComplete":"ra","offset":1205}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            int ran\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":19,"wordToComplete":"ran","offset":1206}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            int rand\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":20,"wordToComplete":"rand","offset":1207}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            int randi\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":21,"wordToComplete":"randi","offset":1208}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            int i\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":17,"wordToComplete":"i","offset":1204}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            int id\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":18,"wordToComplete":"id","offset":1205}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(int i = 0; i << deck.size(); i++) {\n            int idx\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":19,"wordToComplete":"idx","offset":1206}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        f\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":53,"column":9,"wordToComplete":"f","offset":1148}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            f\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":13,"wordToComplete":"f","offset":1185}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            i\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":13,"wordToComplete":"i","offset":1185}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            in\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":14,"wordToComplete":"in","offset":1186}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int i\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":17,"wordToComplete":"i","offset":1189}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int id\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":18,"wordToComplete":"id","offset":1190}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":54,"column":19,"wordToComplete":"idx","offset":1191}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            C\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":55,"column":13,"wordToComplete":"C","offset":1239}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& t\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":55,"column":19,"wordToComplete":"t","offset":1245}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":55,"column":20,"wordToComplete":"to","offset":1246}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":55,"column":20,"wordToComplete":"to","offset":1246}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = d\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":55,"column":29,"wordToComplete":"d","offset":1255}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":55,"column":32,"wordToComplete":"deck","offset":1258}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":55,"column":33,"wordToComplete":".","offset":1259}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.a\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":55,"column":34,"wordToComplete":"a","offset":1260}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":55,"column":35,"wordToComplete":"at","offset":1261}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            d\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":56,"column":13,"wordToComplete":"d","offset":1281}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            s\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":56,"column":13,"wordToComplete":"s","offset":1281}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap\n        }\n        \n        /*\n        for(int i = 0; i << deck.size(); i++) {\n            int idx = //random from i to deck.size();\n            \n        }*/\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":56,"column":16,"wordToComplete":"swap","offset":1284}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? \n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        f\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":61,"column":9,"wordToComplete":"f","offset":1360}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? \n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        fo\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":61,"column":10,"wordToComplete":"fo","offset":1361}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            i\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":13,"wordToComplete":"i","offset":1628}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            in\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":14,"wordToComplete":"in","offset":1629}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            in\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":14,"wordToComplete":"in","offset":1629}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":15,"wordToComplete":"int","offset":1630}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int t\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":17,"wordToComplete":"t","offset":1632}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":18,"wordToComplete":"to","offset":1633}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            C\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":13,"wordToComplete":"C","offset":1663}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& c\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":19,"wordToComplete":"c","offset":1669}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":23,"wordToComplete":"cardA","offset":1673}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = d\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":27,"wordToComplete":"d","offset":1677}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":30,"wordToComplete":"deck","offset":1680}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":31,"wordToComplete":".","offset":1681}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.a\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":32,"wordToComplete":"a","offset":1682}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":33,"wordToComplete":"at","offset":1683}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.a\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":32,"wordToComplete":"a","offset":1682}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":72,"column":33,"wordToComplete":"at","offset":1683}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            c\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":13,"wordToComplete":"c","offset":1701}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            ca\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":14,"wordToComplete":"ca","offset":1702}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            car\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":15,"wordToComplete":"car","offset":1703}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            card\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":16,"wordToComplete":"card","offset":1704}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            C\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":13,"wordToComplete":"C","offset":1701}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& c\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":19,"wordToComplete":"c","offset":1707}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& ca\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":20,"wordToComplete":"ca","offset":1708}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& car\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":21,"wordToComplete":"car","offset":1709}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& card\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":22,"wordToComplete":"card","offset":1710}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& cardB\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":23,"wordToComplete":"cardB","offset":1711}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& cardB = d\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":27,"wordToComplete":"d","offset":1715}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& cardB = de\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":28,"wordToComplete":"de","offset":1716}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& cardB = deck\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":30,"wordToComplete":"deck","offset":1718}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":31,"wordToComplete":".","offset":1719}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.a\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":32,"wordToComplete":"a","offset":1720}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":73,"column":33,"wordToComplete":"at","offset":1721}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            s\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":74,"column":13,"wordToComplete":"s","offset":1745}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = //random\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":74,"column":16,"wordToComplete":"swap","offset":1748}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = r\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":27,"wordToComplete":"r","offset":1642}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = ra\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":28,"wordToComplete":"ra","offset":1643}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = ra\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":28,"wordToComplete":"ra","offset":1643}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = ran\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":29,"wordToComplete":"ran","offset":1644}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = rand\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":30,"wordToComplete":"rand","offset":1645}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = i\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":71,"column":27,"wordToComplete":"i","offset":1642}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = d\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":83,"column":27,"wordToComplete":"d","offset":1926}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = g\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":83,"column":27,"wordToComplete":"g","offset":1926}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = ge\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":83,"column":28,"wordToComplete":"ge","offset":1927}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        //shuffle(deck.begin(), deck.end());\n        for(Card& card : deck) {\n            int idx = //random from i to deck.size();\n            Card& to_swap = deck.at(idx);\n            swap(card, to_swap);\n        }\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}","fileType":"cpp14","line":83,"column":29,"wordToComplete":"get","offset":1928}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nD","fileType":"cpp14","line":87,"column":1,"wordToComplete":"D","offset":1905}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\ni","fileType":"cpp14","line":87,"column":1,"wordToComplete":"i","offset":1905}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nin","fileType":"cpp14","line":87,"column":2,"wordToComplete":"in","offset":1906}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nint t","fileType":"cpp14","line":87,"column":5,"wordToComplete":"t","offset":1909}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nint tes","fileType":"cpp14","line":87,"column":7,"wordToComplete":"tes","offset":1911}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nb","fileType":"cpp14","line":87,"column":1,"wordToComplete":"b","offset":1905}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbo","fileType":"cpp14","line":87,"column":2,"wordToComplete":"bo","offset":1906}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbo","fileType":"cpp14","line":87,"column":2,"wordToComplete":"bo","offset":1906}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nboo","fileType":"cpp14","line":87,"column":3,"wordToComplete":"boo","offset":1907}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nboo","fileType":"cpp14","line":87,"column":3,"wordToComplete":"boo","offset":1907}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool","fileType":"cpp14","line":87,"column":4,"wordToComplete":"bool","offset":1908}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool t","fileType":"cpp14","line":87,"column":6,"wordToComplete":"t","offset":1910}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool te","fileType":"cpp14","line":87,"column":7,"wordToComplete":"te","offset":1911}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool tes","fileType":"cpp14","line":87,"column":8,"wordToComplete":"tes","offset":1912}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test","fileType":"cpp14","line":87,"column":9,"wordToComplete":"test","offset":1913}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool tests","fileType":"cpp14","line":87,"column":10,"wordToComplete":"tests","offset":1914}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    D\n}\n}","fileType":"cpp14","line":88,"column":5,"wordToComplete":"D","offset":1931}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    De\n}\n}","fileType":"cpp14","line":88,"column":6,"wordToComplete":"De","offset":1932}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Dec\n}\n}","fileType":"cpp14","line":88,"column":7,"wordToComplete":"Dec","offset":1933}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck\n}\n}","fileType":"cpp14","line":88,"column":8,"wordToComplete":"Deck","offset":1934}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck e\n}\n}","fileType":"cpp14","line":88,"column":10,"wordToComplete":"e","offset":1936}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck d\n}\n}","fileType":"cpp14","line":88,"column":10,"wordToComplete":"d","offset":1936}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck de\n}\n}","fileType":"cpp14","line":88,"column":11,"wordToComplete":"de","offset":1937}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck dec\n}\n}","fileType":"cpp14","line":88,"column":12,"wordToComplete":"dec","offset":1938}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck\n}\n}","fileType":"cpp14","line":88,"column":13,"wordToComplete":"deck","offset":1939}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    D\n    \n}","fileType":"cpp14","line":89,"column":5,"wordToComplete":"D","offset":1947}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck d\n    \n}","fileType":"cpp14","line":89,"column":10,"wordToComplete":"d","offset":1952}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck de\n    \n}","fileType":"cpp14","line":89,"column":11,"wordToComplete":"de","offset":1953}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck dec\n    \n}","fileType":"cpp14","line":89,"column":12,"wordToComplete":"dec","offset":1954}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck\n    \n}","fileType":"cpp14","line":89,"column":13,"wordToComplete":"deck","offset":1955}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    d\n}","fileType":"cpp14","line":90,"column":5,"wordToComplete":"d","offset":1963}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck.\n}","fileType":"cpp14","line":90,"column":9,"wordToComplete":".","offset":1967}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.\n}","fileType":"cpp14","line":90,"column":10,"wordToComplete":".","offset":1968}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.s\n}","fileType":"cpp14","line":90,"column":11,"wordToComplete":"s","offset":1969}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.sh\n}","fileType":"cpp14","line":90,"column":12,"wordToComplete":"sh","offset":1970}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.sh\n}","fileType":"cpp14","line":90,"column":12,"wordToComplete":"sh","offset":1970}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shu\n}","fileType":"cpp14","line":90,"column":13,"wordToComplete":"shu","offset":1971}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shu\n}","fileType":"cpp14","line":90,"column":13,"wordToComplete":"shu","offset":1971}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuf\n}","fileType":"cpp14","line":90,"column":14,"wordToComplete":"shuf","offset":1972}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuf\n}","fileType":"cpp14","line":90,"column":14,"wordToComplete":"shuf","offset":1972}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuff\n}","fileType":"cpp14","line":90,"column":15,"wordToComplete":"shuff","offset":1973}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuffl\n}","fileType":"cpp14","line":90,"column":16,"wordToComplete":"shuffl","offset":1974}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuffl\n}","fileType":"cpp14","line":90,"column":16,"wordToComplete":"shuffl","offset":1974}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuffle();\n    a\n}","fileType":"cpp14","line":91,"column":5,"wordToComplete":"a","offset":1984}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuffle();\n    as\n}","fileType":"cpp14","line":91,"column":6,"wordToComplete":"as","offset":1985}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuffle();\n    ass\n}","fileType":"cpp14","line":91,"column":7,"wordToComplete":"ass","offset":1986}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuffle();\n    asser\n}","fileType":"cpp14","line":91,"column":9,"wordToComplete":"asser","offset":1988}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\n// 52 total cards\n// 4 suits: spades, hearts, diamonds, clubs\n// 13 ranks: ace(1) - 10, jack, queen, king\n\n// create (or maybe reset) the deck to have all cards\n// deal a card\n// shuffle the deck\n\n\n// how many permutations of n cards? n!\n// each shuffle - produce 1/ n!\n\n// select from all indices\n// first iteration - what probability of any one card in index 0? 1/n\n// second iteration - \"\" index 1? 1/n\n// nth iteration\n// joint probability? 1/n^n\n\n\n\n\nenum class Suit {\n    SPADES,\n    HEARTS,\n    DIAMONDS,\n    CLUBS,\n};\n\n\nstruct Card {\n    Suit suit;\n    unsigned int rank;\n}\n\nconstexpr unsigned int NUM_RANKS = 13;\nconstexpr unsigned int NUM_SUITS = 4;\n\n\n// Gets a uniformly distributed integer between a and b inclusive\nint get_random(int a, int b)\n{\n  static std::random_device random_device;\n  static std::mt19937 generator(random_device());\n\n  std::uniform_int_distribution<> distribution(a, b);\n\n  return distribution(generator);\n}\n\nclass Deck {\n    public:\n    Deck() {\n        reset();\n    }\n    \n    void reset() {\n        deck.clear();\n        for(unsigned int suit= 0; suit < NUM_SUITS; suit++) {\n            Suit suit = static_cast<Suit>(suit);\n            for(unsigned int rank = 0; rank < NUM_RANKS; rank++;) {\n                deck.emplace_back({suit, rank});\n            }\n        }\n    }\n    \n    Card deal() {\n        //Have to handle case where there are no cards left in deck\n        Card card = deck.back();\n        deck.pop_back();\n        return card;\n    }\n    \n    void shuffle() {\n        for(int i = 0; i < deck.size(); i++) {\n            int to_swap = get_random(i, deck.size());\n            Card& cardA = deck.at(i);\n            Card& cardB = deck.at(to_swap);\n            swap(cardA, cardB);\n        }\n    }\n    \n    vector<Card> deck(52);   \n}\n\nbool test_shuffle() {\n    Deck deck1;\n    Deck deck2;\n    deck1.shuffle();\n    assert\n}","fileType":"cpp14","line":91,"column":10,"wordToComplete":"assert","offset":1989}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  S\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":3,"wordToComplete":"S","offset":2169}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  s\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":3,"wordToComplete":"s","offset":2169}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  st\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":4,"wordToComplete":"st","offset":2170}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  st\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":4,"wordToComplete":"st","offset":2170}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  str\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":5,"wordToComplete":"str","offset":2171}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  str\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":5,"wordToComplete":"str","offset":2171}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  stru\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":6,"wordToComplete":"stru","offset":2172}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struc\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":7,"wordToComplete":"struc","offset":2173}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struc\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":7,"wordToComplete":"struc","offset":2173}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struc\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":7,"wordToComplete":"struc","offset":2173}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":8,"wordToComplete":"struct","offset":2174}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct R\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":10,"wordToComplete":"R","offset":2176}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r\n  Send(, , destination, )\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":18,"wordToComplete":"r","offset":2184}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  c\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":3,"wordToComplete":"c","offset":2189}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  charc\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":7,"wordToComplete":"charc","offset":2193}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char c\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":8,"wordToComplete":"c","offset":2194}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char co\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":9,"wordToComplete":"co","offset":2195}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char con\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":10,"wordToComplete":"con","offset":2196}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char cons\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":11,"wordToComplete":"cons","offset":2197}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* m\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":15,"wordToComplete":"m","offset":2201}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* me\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":16,"wordToComplete":"me","offset":2202}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* ms\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":16,"wordToComplete":"ms","offset":2202}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* msg\n  Send(, , destination, &r);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":72,"column":17,"wordToComplete":"msg","offset":2203}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  R\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":74,"column":3,"wordToComplete":"R","offset":2269}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  Re\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":74,"column":4,"wordToComplete":"Re","offset":2270}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  Re\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":74,"column":4,"wordToComplete":"Re","offset":2270}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  c\n  Recv(destination, &r)\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":74,"column":3,"wordToComplete":"c","offset":2269}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  char b\n  Recv(destination, &r)\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":74,"column":8,"wordToComplete":"b","offset":2274}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  char bu\n  Recv(destination, &r)\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":74,"column":9,"wordToComplete":"bu","offset":2275}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  char buf\n  Recv(destination, &r)\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":74,"column":10,"wordToComplete":"buf","offset":2276}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  W\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":78,"column":3,"wordToComplete":"W","offset":2334}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  G\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":71,"column":3,"wordToComplete":"G","offset":2169}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  d\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":3,"wordToComplete":"d","offset":2387}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  do\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":4,"wordToComplete":"do","offset":2388}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  dou\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":5,"wordToComplete":"dou","offset":2389}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  dou\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":5,"wordToComplete":"dou","offset":2389}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  dou\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":5,"wordToComplete":"dou","offset":2389}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  doub\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":6,"wordToComplete":"doub","offset":2390}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  doubl\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":7,"wordToComplete":"doubl","offset":2391}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double e\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":10,"wordToComplete":"e","offset":2394}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double en\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":11,"wordToComplete":"en","offset":2395}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":12,"wordToComplete":"end","offset":2396}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = G\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":82,"column":16,"wordToComplete":"G","offset":2400}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  p\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":83,"column":3,"wordToComplete":"p","offset":2415}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  pr\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":83,"column":4,"wordToComplete":"pr","offset":2416}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  pri\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":83,"column":5,"wordToComplete":"pri","offset":2417}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  prin\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":83,"column":6,"wordToComplete":"prin","offset":2418}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[10];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  print\n}\n  \nvoid pong(const int destination) {\n  \n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":83,"column":7,"wordToComplete":"print","offset":2419}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconstexpr int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  \n  a\n  \n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":87,"column":3,"wordToComplete":"a","offset":2397}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconstexpr int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  u\n  abort()\n  \n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":86,"column":3,"wordToComplete":"u","offset":2394}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconstexpr int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  unsigned m\n  abort()\n  \n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":86,"column":12,"wordToComplete":"m","offset":2403}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconstexpr int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  unsigned ms\n  abort()\n  \n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":86,"column":13,"wordToComplete":"ms","offset":2404}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconstexpr int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  unsigned msg\n  abort()\n  \n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":86,"column":14,"wordToComplete":"msg","offset":2405}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconstexpr int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  unsigned msg_len = s\n  abort()\n  \n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":86,"column":22,"wordToComplete":"s","offset":2413}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconstexpr int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  char const* msg = \"from ping\";\n  unsigned msg_len = strlen\n  abort()\n  \n  Send(msg, strlen(msg) + 1, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":86,"column":27,"wordToComplete":"strlen","offset":2418}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconst int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  //char const* msg = \"from ping\";\n  ///char * msg = new char[BUFFER_SIZE];\n  \n  s\n  \n  // fill msg with data\n  unsigned msg_len = strlen(msg) + 1;\n  assert(msg_len < BUFFER_SIZE);\n  \n  Send(msg, msg_len, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n  \n  // call delete\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":88,"column":3,"wordToComplete":"s","offset":2436}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconst int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  //char const* msg = \"from ping\";\n  ///char * msg = new char[BUFFER_SIZE];\n  \n  std::s\n  \n  // fill msg with data\n  unsigned msg_len = strlen(msg) + 1;\n  assert(msg_len < BUFFER_SIZE);\n  \n  Send(msg, msg_len, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n  \n  // call delete\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":88,"column":8,"wordToComplete":"s","offset":2441}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconst int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  //char const* msg = \"from ping\";\n  ///char * msg = new char[BUFFER_SIZE];\n  \n  std::sm\n  \n  // fill msg with data\n  unsigned msg_len = strlen(msg) + 1;\n  assert(msg_len < BUFFER_SIZE);\n  \n  Send(msg, msg_len, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n  \n  // call delete\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":88,"column":9,"wordToComplete":"sm","offset":2442}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconst int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  //char const* msg = \"from ping\";\n  ///char * msg = new char[BUFFER_SIZE];\n  \n  std::s\n  \n  // fill msg with data\n  unsigned msg_len = strlen(msg) + 1;\n  assert(msg_len < BUFFER_SIZE);\n  \n  Send(msg, msg_len, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n  \n  // call delete\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":88,"column":8,"wordToComplete":"s","offset":2441}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconst int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  //char const* msg = \"from ping\";\n  ///char * msg = new char[BUFFER_SIZE];\n  \n  std::sm\n  \n  // fill msg with data\n  unsigned msg_len = strlen(msg) + 1;\n  assert(msg_len < BUFFER_SIZE);\n  \n  Send(msg, msg_len, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n  \n  // call delete\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":88,"column":9,"wordToComplete":"sm","offset":2442}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconst int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  //char const* msg = \"from ping\";\n  ///char * msg = new char[BUFFER_SIZE];\n  \n  std::sma\n  \n  // fill msg with data\n  unsigned msg_len = strlen(msg) + 1;\n  assert(msg_len < BUFFER_SIZE);\n  \n  Send(msg, msg_len, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n  \n  // call delete\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":88,"column":10,"wordToComplete":"sma","offset":2443}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconst int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  //char const* msg = \"from ping\";\n  ///char * msg = new char[BUFFER_SIZE];\n  \n  std::smar\n  \n  // fill msg with data\n  unsigned msg_len = strlen(msg) + 1;\n  assert(msg_len < BUFFER_SIZE);\n  \n  Send(msg, msg_len, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n  \n  // call delete\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":88,"column":11,"wordToComplete":"smar","offset":2444}}
{"body": {"code":"#include <stdio.h>\n#include <stdlib.h>\n/* Your task is to implement a \"ping pong\" performance measurement test case\n *\n * This test is to measure the latency of a round trip transfer of a small\n * message between two hosts on a network.  The network address of the host is\n * represented by an integer called the \"canonical rank\", which uniquely\n * identifies each host.  Latency measurements often send/recv 8 bytes to avoid\n * optimizations that can be done with 0 byte messages\n */\nstruct Request {\n  void *data;\n};\nextern char *msgError;\n/*\n Send is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Send:  Sends a message\n Input: buf:   buffer to send\n Input: size:  size of data to send\n Input: destination:  destination rank\n Output: r:  Request object pointer, stores message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Send(const void *buf, size_t size, int destination, Request *r);\n/*\n Recv is non-blocking.  That is, it\n immediately returns, but resources are\n not released(they are tracked in an opaque\n request object)\n Recv: receives a message\n Input: buf:   buffer to copy incoming message into\n Input: size:  size of buf\n Input: source:  source rank\n Output: r:  Request object pointer, for message state\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Recv(void *buf, size_t size, int source, Request *r);\n/*\nWait: waits for a request to complete\n Input: r:  array of requests\n Input: size:  number of requests to process\n return: 0 for success, non-zero for failure\n         if non-zero, error string is in an\n         MsgError;\n*/\nint Wait(Request *r, size_t size);\n/*\n GetTimeNS:  get timestamp\n return: a timestamp in nanoseconds from some\n         arbitrary time in the past\n*/\ndouble GetTimeNS();\n/*\n Rank:  canonical rank\n return:  The canonical rank of \"this process\"\n*/\nint Rank();\n/*\n Size:  number of hosts in the system\n return: number of hosts in the system\n*/\nint Size();\n\n/*\n// int Recv, Send, Wait\n\nif (Recv(...)) {\n    std::cerr << msgError << std::endl;\n    exit(-1)\n}\n*/\n\nconst int BUFFER_SIZE = 10;\n  \nvoid ping(const int destination) {\n  double begin = GetTimeNS();\n    \n  struct Request r;\n  //char const* msg = \"from ping\";\n  ///char * msg = new char[BUFFER_SIZE];\n  \n  std::smart\n  \n  // fill msg with data\n  unsigned msg_len = strlen(msg) + 1;\n  assert(msg_len < BUFFER_SIZE);\n  \n  Send(msg, msg_len, destination, &r);\n  \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  \n  Wait(&r, 1);\n  \n  double end = GetTimeNS();\n  printf(\"Time diff: %f\", end - begin);\n  \n  // call delete\n}\n  \nvoid pong(const int destination) {\n  struct Request r;\n \n  char buf[BUFFER_SIZE];\n  Recv(buf, sizeof(buf), destination, &r);\n  Wait(&r, 1);\n  \n  char const* msg = \"from pong\";\n  Send(buf, strlen(buf) + 1, destination, &r);\n}\n  \nint main(int, char *[]) {\n int size = Size();\n int rank = Rank();\n if (size < 2) {\n    fprintf(stderr, \"Fatal error:  need at least two hosts\\n\");\n  }\n  if (rank == 0) {\n    ping(1);\n  } else if (rank == 1) {\n    pong(0);\n  } else {\n    exit(0);\n  }\n    return 0;\n}","fileType":"cpp14","line":88,"column":12,"wordToComplete":"smart","offset":2445}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nv","fileType":"cpp14","line":22,"column":1,"wordToComplete":"v","offset":551}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid a","fileType":"cpp14","line":22,"column":6,"wordToComplete":"a","offset":556}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid ad","fileType":"cpp14","line":22,"column":7,"wordToComplete":"ad","offset":557}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add","fileType":"cpp14","line":22,"column":8,"wordToComplete":"add","offset":558}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    o\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":5,"wordToComplete":"o","offset":471}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    oriv\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":8,"wordToComplete":"oriv","offset":474}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    oriva\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":9,"wordToComplete":"oriva","offset":475}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    orivat\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":10,"wordToComplete":"orivat","offset":476}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    orivate\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":11,"wordToComplete":"orivate","offset":477}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    p\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":5,"wordToComplete":"p","offset":471}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    pr\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":6,"wordToComplete":"pr","offset":472}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    pri\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":7,"wordToComplete":"pri","offset":473}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    priv\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":8,"wordToComplete":"priv","offset":474}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    priva\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":9,"wordToComplete":"priva","offset":475}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    privat\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":10,"wordToComplete":"privat","offset":476}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":16,"column":11,"wordToComplete":"private","offset":477}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        q\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":9,"wordToComplete":"q","offset":488}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        qu\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":10,"wordToComplete":"qu","offset":489}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        quq\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":11,"wordToComplete":"quq","offset":490}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        qe\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":10,"wordToComplete":"qe","offset":489}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        qu\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":10,"wordToComplete":"qu","offset":489}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        que\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":11,"wordToComplete":"que","offset":490}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queu\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":12,"wordToComplete":"queu","offset":491}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":13,"wordToComplete":"queue","offset":492}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> m\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":21,"wordToComplete":"m","offset":500}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQ\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":22,"wordToComplete":"mQ","offset":501}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQu\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":23,"wordToComplete":"mQu","offset":502}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQue\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":24,"wordToComplete":"mQue","offset":503}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue\n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    \n}","fileType":"cpp14","line":17,"column":26,"wordToComplete":"mQueue","offset":505}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    m\n}","fileType":"cpp14","line":28,"column":5,"wordToComplete":"m","offset":629}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQ\n}","fileType":"cpp14","line":28,"column":6,"wordToComplete":"mQ","offset":630}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQe\n}","fileType":"cpp14","line":28,"column":7,"wordToComplete":"mQe","offset":631}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQeu\n}","fileType":"cpp14","line":28,"column":8,"wordToComplete":"mQeu","offset":632}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQeue\n}","fileType":"cpp14","line":28,"column":9,"wordToComplete":"mQeue","offset":633}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQeueu\n}","fileType":"cpp14","line":28,"column":10,"wordToComplete":"mQeueu","offset":634}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQu\n}","fileType":"cpp14","line":28,"column":7,"wordToComplete":"mQu","offset":631}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQue\n}","fileType":"cpp14","line":28,"column":8,"wordToComplete":"mQue","offset":632}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQueu\n}","fileType":"cpp14","line":28,"column":9,"wordToComplete":"mQueu","offset":633}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQueue\n}","fileType":"cpp14","line":28,"column":10,"wordToComplete":"mQueue","offset":634}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQueue.\n}","fileType":"cpp14","line":28,"column":11,"wordToComplete":".","offset":635}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQueue.p\n}","fileType":"cpp14","line":28,"column":12,"wordToComplete":"p","offset":636}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQueue.pu\n}","fileType":"cpp14","line":28,"column":13,"wordToComplete":"pu","offset":637}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQueue.pus\n}","fileType":"cpp14","line":28,"column":14,"wordToComplete":"pus","offset":638}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid add(long l)\n{\n    mQueue.push\n}","fileType":"cpp14","line":28,"column":15,"wordToComplete":"push","offset":639}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nv","fileType":"cpp14","line":32,"column":1,"wordToComplete":"v","offset":672}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\no","fileType":"cpp14","line":32,"column":1,"wordToComplete":"o","offset":672}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nouv","fileType":"cpp14","line":32,"column":3,"wordToComplete":"ouv","offset":674}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\np","fileType":"cpp14","line":32,"column":1,"wordToComplete":"p","offset":672}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npu","fileType":"cpp14","line":32,"column":2,"wordToComplete":"pu","offset":673}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npub","fileType":"cpp14","line":32,"column":3,"wordToComplete":"pub","offset":674}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npubl","fileType":"cpp14","line":32,"column":4,"wordToComplete":"publ","offset":675}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npubli","fileType":"cpp14","line":32,"column":5,"wordToComplete":"publi","offset":676}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npublic","fileType":"cpp14","line":32,"column":6,"wordToComplete":"public","offset":677}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npublic l","fileType":"cpp14","line":32,"column":8,"wordToComplete":"l","offset":679}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npublic long p","fileType":"cpp14","line":32,"column":13,"wordToComplete":"p","offset":684}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npublic long po","fileType":"cpp14","line":32,"column":14,"wordToComplete":"po","offset":685}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npublic long pol","fileType":"cpp14","line":32,"column":15,"wordToComplete":"pol","offset":686}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\npublic long poll","fileType":"cpp14","line":32,"column":16,"wordToComplete":"poll","offset":687}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.\n}","fileType":"cpp14","line":34,"column":11,"wordToComplete":".","offset":706}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.p\n}","fileType":"cpp14","line":34,"column":12,"wordToComplete":"p","offset":707}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.po\n}","fileType":"cpp14","line":34,"column":13,"wordToComplete":"po","offset":708}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop\n}","fileType":"cpp14","line":34,"column":14,"wordToComplete":"pop","offset":709}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nl","fileType":"cpp14","line":37,"column":1,"wordToComplete":"l","offset":723}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nl","fileType":"cpp14","line":37,"column":1,"wordToComplete":"l","offset":723}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::p","fileType":"cpp14","line":37,"column":14,"wordToComplete":"p","offset":736}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::po","fileType":"cpp14","line":37,"column":15,"wordToComplete":"po","offset":737}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::pol","fileType":"cpp14","line":37,"column":16,"wordToComplete":"pol","offset":738}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::poll","fileType":"cpp14","line":37,"column":17,"wordToComplete":"poll","offset":739}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::pollM","fileType":"cpp14","line":37,"column":18,"wordToComplete":"pollM","offset":740}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::pollMA","fileType":"cpp14","line":37,"column":19,"wordToComplete":"pollMA","offset":741}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::pollMAx","fileType":"cpp14","line":37,"column":20,"wordToComplete":"pollMAx","offset":742}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::polla","fileType":"cpp14","line":37,"column":18,"wordToComplete":"polla","offset":740}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::pollM","fileType":"cpp14","line":37,"column":18,"wordToComplete":"pollM","offset":740}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::pollMa","fileType":"cpp14","line":37,"column":19,"wordToComplete":"pollMa","offset":741}}
{"body": {"code":"/*\n * Provide an implementation of the following interface,\n * which describes an enhanced LILO queue structure\n * such as might be used to implement a producer/consumer queue\n * with preferred handling.\n */\npublic interface MaxQueue {\n    // Adds a Long to the queue\n    public void add(Long l);\n  \n    // Removes and returns the head of the queue\n    public Long poll();\n  \n    // Removes and returns the largest Long in the queue\n    public Long pollMax();\n    \n    private:\n        queue<long> mQueue;\n        \n        \n}\n\n// add: 1, 2, 3\n// poll: 1\n// pollMax: 3\n// at the end, the queue should only have 2\n\nvoid MaxQueue::add(long l)\n{\n    mQueue.push_back(l);\n}\n\nlong MaxQueue::poll()\n{\n    mQueue.pop_front();\n}\n\nlong mQueue::pollMax","fileType":"cpp14","line":37,"column":20,"wordToComplete":"pollMax","offset":742}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\nt\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":1,"wordToComplete":"t","offset":219}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\nte\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":2,"wordToComplete":"te","offset":220}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntem\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":3,"wordToComplete":"tem","offset":221}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemp\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":4,"wordToComplete":"temp","offset":222}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntempl\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":5,"wordToComplete":"templ","offset":223}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntempla\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":6,"wordToComplete":"templa","offset":224}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplat\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":7,"wordToComplete":"templat","offset":225}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":8,"wordToComplete":"template","offset":226}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <t\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":11,"wordToComplete":"t","offset":229}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <ty\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":12,"wordToComplete":"ty","offset":230}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <typ\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":13,"wordToComplete":"typ","offset":231}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <type\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":14,"wordToComplete":"type","offset":232}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <type\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":14,"wordToComplete":"type","offset":232}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <typen\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":15,"wordToComplete":"typen","offset":233}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <typena\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":16,"wordToComplete":"typena","offset":234}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <typenam\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":17,"wordToComplete":"typenam","offset":235}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <typename T\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":20,"wordToComplete":"T","offset":238}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\nt\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":1,"wordToComplete":"t","offset":219}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\nte\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":2,"wordToComplete":"te","offset":220}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntem\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":3,"wordToComplete":"tem","offset":221}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemp\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":4,"wordToComplete":"temp","offset":222}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntempl\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":5,"wordToComplete":"templ","offset":223}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntempla\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":6,"wordToComplete":"templa","offset":224}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplat\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":7,"wordToComplete":"templat","offset":225}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":11,"column":8,"wordToComplete":"template","offset":226}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <typename T>\ni\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":12,"column":1,"wordToComplete":"i","offset":241}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <typename T>\nin\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":12,"column":2,"wordToComplete":"in","offset":242}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <typename T>\nint\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":12,"column":3,"wordToComplete":"int","offset":243}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\n\ntemplate <typename T>\nint f\n\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":12,"column":5,"wordToComplete":"f","offset":245}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\nt\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":1,"wordToComplete":"t","offset":218}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\nte\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":2,"wordToComplete":"te","offset":219}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntem\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":3,"wordToComplete":"tem","offset":220}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntemp\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":4,"wordToComplete":"temp","offset":221}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntempl\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":5,"wordToComplete":"templ","offset":222}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntempl\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":5,"wordToComplete":"templ","offset":222}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntempla\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":6,"wordToComplete":"templa","offset":223}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntemplat\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":7,"wordToComplete":"templat","offset":224}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntemplate <t\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":11,"wordToComplete":"t","offset":228}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntemplate <typ\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":13,"wordToComplete":"typ","offset":230}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntemplate <typena\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":16,"wordToComplete":"typena","offset":233}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntemplate <typenam\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":17,"wordToComplete":"typenam","offset":234}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntemplate <typename\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":18,"wordToComplete":"typename","offset":235}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <vector>\n\n\nconstexpr int sum(int a, int b)\n{\n    return a + b;\n}\ntemplate <typename T\nint main()\n{\n    static_assert(sum(3, 4) == 7, \"assert\");\n    std::vector<int> v{1, 2, 3, 4}; \n    auto value = [&v]\n    { \n        int sum = 0;\n        for (auto x : v)\n        {\n            sum += x;\n        }\n        return sum;\n    };\n    std::cout << value();\n}","fileType":"cpp14","line":10,"column":20,"wordToComplete":"T","offset":237}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#i","fileType":"cpp14","line":2,"column":2,"wordToComplete":"i","offset":125}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#in","fileType":"cpp14","line":2,"column":3,"wordToComplete":"in","offset":126}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#inc","fileType":"cpp14","line":2,"column":4,"wordToComplete":"inc","offset":127}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#incl","fileType":"cpp14","line":2,"column":5,"wordToComplete":"incl","offset":128}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#incl","fileType":"cpp14","line":2,"column":5,"wordToComplete":"incl","offset":128}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#inclu","fileType":"cpp14","line":2,"column":6,"wordToComplete":"inclu","offset":129}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#includ","fileType":"cpp14","line":2,"column":7,"wordToComplete":"includ","offset":130}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#includ","fileType":"cpp14","line":2,"column":7,"wordToComplete":"includ","offset":130}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#i","fileType":"cpp14","line":3,"column":2,"wordToComplete":"i","offset":145}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#in","fileType":"cpp14","line":3,"column":3,"wordToComplete":"in","offset":146}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#inc","fileType":"cpp14","line":3,"column":4,"wordToComplete":"inc","offset":147}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#incl","fileType":"cpp14","line":3,"column":5,"wordToComplete":"incl","offset":148}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#inclu","fileType":"cpp14","line":3,"column":6,"wordToComplete":"inclu","offset":149}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#includ","fileType":"cpp14","line":3,"column":7,"wordToComplete":"includ","offset":150}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\ni","fileType":"cpp14","line":5,"column":1,"wordToComplete":"i","offset":163}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nin","fileType":"cpp14","line":5,"column":2,"wordToComplete":"in","offset":164}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint","fileType":"cpp14","line":5,"column":3,"wordToComplete":"int","offset":165}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint m","fileType":"cpp14","line":5,"column":5,"wordToComplete":"m","offset":167}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint mai","fileType":"cpp14","line":5,"column":7,"wordToComplete":"mai","offset":169}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main","fileType":"cpp14","line":5,"column":8,"wordToComplete":"main","offset":170}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    s\n}","fileType":"cpp14","line":7,"column":5,"wordToComplete":"s","offset":180}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    st\n}","fileType":"cpp14","line":7,"column":6,"wordToComplete":"st","offset":181}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std\n}","fileType":"cpp14","line":7,"column":7,"wordToComplete":"std","offset":182}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std\n}","fileType":"cpp14","line":7,"column":7,"wordToComplete":"std","offset":182}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::s\n}","fileType":"cpp14","line":7,"column":10,"wordToComplete":"s","offset":185}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::st\n}","fileType":"cpp14","line":7,"column":11,"wordToComplete":"st","offset":186}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::stri\n}","fileType":"cpp14","line":7,"column":13,"wordToComplete":"stri","offset":188}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s\n}","fileType":"cpp14","line":7,"column":17,"wordToComplete":"s","offset":192}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    s\n}","fileType":"cpp14","line":8,"column":5,"wordToComplete":"s","offset":199}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    st\n}","fileType":"cpp14","line":8,"column":6,"wordToComplete":"st","offset":200}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std\n}","fileType":"cpp14","line":8,"column":7,"wordToComplete":"std","offset":201}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std\n}","fileType":"cpp14","line":8,"column":7,"wordToComplete":"std","offset":201}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::c\n}","fileType":"cpp14","line":8,"column":10,"wordToComplete":"c","offset":204}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::ci\n}","fileType":"cpp14","line":8,"column":11,"wordToComplete":"ci","offset":205}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::ci\n}","fileType":"cpp14","line":8,"column":11,"wordToComplete":"ci","offset":205}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin\n}","fileType":"cpp14","line":8,"column":12,"wordToComplete":"cin","offset":206}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s\n}","fileType":"cpp14","line":8,"column":17,"wordToComplete":"s","offset":211}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    s\n}","fileType":"cpp14","line":9,"column":5,"wordToComplete":"s","offset":218}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    st\n}","fileType":"cpp14","line":9,"column":6,"wordToComplete":"st","offset":219}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std\n}","fileType":"cpp14","line":9,"column":7,"wordToComplete":"std","offset":220}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std\n}","fileType":"cpp14","line":9,"column":7,"wordToComplete":"std","offset":220}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::s\n}","fileType":"cpp14","line":9,"column":10,"wordToComplete":"s","offset":223}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::st\n}","fileType":"cpp14","line":9,"column":11,"wordToComplete":"st","offset":224}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::str\n}","fileType":"cpp14","line":9,"column":12,"wordToComplete":"str","offset":225}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::str\n}","fileType":"cpp14","line":9,"column":12,"wordToComplete":"str","offset":225}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::strin\n}","fileType":"cpp14","line":9,"column":14,"wordToComplete":"strin","offset":227}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string\n}","fileType":"cpp14","line":9,"column":15,"wordToComplete":"string","offset":228}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string n\n}","fileType":"cpp14","line":9,"column":17,"wordToComplete":"n","offset":230}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string ne\n}","fileType":"cpp14","line":9,"column":18,"wordToComplete":"ne","offset":231}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new\n}","fileType":"cpp14","line":9,"column":19,"wordToComplete":"new","offset":232}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    f\n}","fileType":"cpp14","line":10,"column":5,"wordToComplete":"f","offset":246}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    fo\n}","fileType":"cpp14","line":10,"column":6,"wordToComplete":"fo","offset":247}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for\n}","fileType":"cpp14","line":10,"column":7,"wordToComplete":"for","offset":248}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        n\n    }\n}","fileType":"cpp14","line":11,"column":9,"wordToComplete":"n","offset":300}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        ne\n    }\n}","fileType":"cpp14","line":11,"column":10,"wordToComplete":"ne","offset":301}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new\n    }\n}","fileType":"cpp14","line":11,"column":11,"wordToComplete":"new","offset":302}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new\n    }\n}","fileType":"cpp14","line":11,"column":11,"wordToComplete":"new","offset":302}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i\n    }\n}","fileType":"cpp14","line":11,"column":24,"wordToComplete":"i","offset":315}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    s\n}","fileType":"cpp14","line":13,"column":5,"wordToComplete":"s","offset":328}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    st\n}","fileType":"cpp14","line":13,"column":6,"wordToComplete":"st","offset":329}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std\n}","fileType":"cpp14","line":13,"column":7,"wordToComplete":"std","offset":330}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std\n}","fileType":"cpp14","line":13,"column":7,"wordToComplete":"std","offset":330}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::c\n}","fileType":"cpp14","line":13,"column":10,"wordToComplete":"c","offset":333}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::co\n}","fileType":"cpp14","line":13,"column":11,"wordToComplete":"co","offset":334}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cou\n}","fileType":"cpp14","line":13,"column":12,"wordToComplete":"cou","offset":335}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cou\n}","fileType":"cpp14","line":13,"column":12,"wordToComplete":"cou","offset":335}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::co\n}","fileType":"cpp14","line":13,"column":11,"wordToComplete":"co","offset":334}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::co\n}","fileType":"cpp14","line":13,"column":11,"wordToComplete":"co","offset":334}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cou\n}","fileType":"cpp14","line":13,"column":12,"wordToComplete":"cou","offset":335}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout\n}","fileType":"cpp14","line":13,"column":13,"wordToComplete":"cout","offset":336}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << n\n}","fileType":"cpp14","line":13,"column":18,"wordToComplete":"n","offset":341}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << ne\n}","fileType":"cpp14","line":13,"column":19,"wordToComplete":"ne","offset":342}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new\n}","fileType":"cpp14","line":13,"column":20,"wordToComplete":"new","offset":343}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    r\n}","fileType":"cpp14","line":14,"column":5,"wordToComplete":"r","offset":357}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    re\n}","fileType":"cpp14","line":14,"column":6,"wordToComplete":"re","offset":358}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    ret\n}","fileType":"cpp14","line":14,"column":7,"wordToComplete":"ret","offset":359}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    retu\n}","fileType":"cpp14","line":14,"column":8,"wordToComplete":"retu","offset":360}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(), i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return\n}","fileType":"cpp14","line":14,"column":10,"wordToComplete":"return","offset":362}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nd\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":1,"wordToComplete":"d","offset":163}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\ns\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":1,"wordToComplete":"s","offset":163}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nst\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":2,"wordToComplete":"st","offset":164}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":3,"wordToComplete":"std","offset":165}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::s\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":6,"wordToComplete":"s","offset":168}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::st\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":7,"wordToComplete":"st","offset":169}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::str\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":8,"wordToComplete":"str","offset":170}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::strin\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":10,"wordToComplete":"strin","offset":172}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":11,"wordToComplete":"string","offset":173}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string r\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":13,"wordToComplete":"r","offset":175}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string re\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":14,"wordToComplete":"re","offset":176}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string rev\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":15,"wordToComplete":"rev","offset":177}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reve\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":16,"wordToComplete":"reve","offset":178}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string rever\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":17,"wordToComplete":"rever","offset":179}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string revers\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":18,"wordToComplete":"revers","offset":180}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":5,"column":19,"wordToComplete":"reverse","offset":181}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\ns\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":1,"wordToComplete":"s","offset":224}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nst\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":2,"wordToComplete":"st","offset":225}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":3,"wordToComplete":"std","offset":226}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::s\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":6,"wordToComplete":"s","offset":229}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::st\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":7,"wordToComplete":"st","offset":230}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::str\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":8,"wordToComplete":"str","offset":231}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::stri\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":9,"wordToComplete":"stri","offset":232}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::stri\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":9,"wordToComplete":"stri","offset":232}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string r\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":13,"wordToComplete":"r","offset":236}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string re\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":14,"wordToComplete":"re","offset":237}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string rev\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":15,"wordToComplete":"rev","offset":238}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reve\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":16,"wordToComplete":"reve","offset":239}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string rever\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":17,"wordToComplete":"rever","offset":240}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string revers\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":18,"wordToComplete":"revers","offset":241}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse\n\nint main()\n{\n    std::string s;\n    std::cin >> s;\n    std::string new_string;\n    for (auto i = s.end(); i != s.begin(); --i) {\n        new_string += *i;\n    }\n    std::cout << new_string;\n    return 0;\n}","fileType":"cpp14","line":10,"column":19,"wordToComplete":"reverse","offset":242}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    s\n    return 0;\n}","fileType":"cpp14","line":17,"column":5,"wordToComplete":"s","offset":297}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    st\n    return 0;\n}","fileType":"cpp14","line":17,"column":6,"wordToComplete":"st","offset":298}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std\n    return 0;\n}","fileType":"cpp14","line":17,"column":7,"wordToComplete":"std","offset":299}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    s\n    return 0;\n}","fileType":"cpp14","line":17,"column":5,"wordToComplete":"s","offset":297}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    st\n    return 0;\n}","fileType":"cpp14","line":17,"column":6,"wordToComplete":"st","offset":298}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std\n    return 0;\n}","fileType":"cpp14","line":17,"column":7,"wordToComplete":"std","offset":299}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std\n    return 0;\n}","fileType":"cpp14","line":17,"column":7,"wordToComplete":"std","offset":299}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::s\n    return 0;\n}","fileType":"cpp14","line":17,"column":10,"wordToComplete":"s","offset":302}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::st\n    return 0;\n}","fileType":"cpp14","line":17,"column":11,"wordToComplete":"st","offset":303}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::str\n    return 0;\n}","fileType":"cpp14","line":17,"column":12,"wordToComplete":"str","offset":304}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string\n    return 0;\n}","fileType":"cpp14","line":17,"column":15,"wordToComplete":"string","offset":307}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string s\n    return 0;\n}","fileType":"cpp14","line":17,"column":17,"wordToComplete":"s","offset":309}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string st\n    return 0;\n}","fileType":"cpp14","line":17,"column":18,"wordToComplete":"st","offset":310}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str\n    return 0;\n}","fileType":"cpp14","line":17,"column":19,"wordToComplete":"str","offset":311}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"\"a\n    return 0;\n}","fileType":"cpp14","line":17,"column":24,"wordToComplete":"a","offset":316}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"\"as\n    return 0;\n}","fileType":"cpp14","line":17,"column":25,"wordToComplete":"as","offset":317}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"\"asd\n    return 0;\n}","fileType":"cpp14","line":17,"column":26,"wordToComplete":"asd","offset":318}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"a\n    return 0;\n}","fileType":"cpp14","line":17,"column":23,"wordToComplete":"a","offset":315}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"as\n    return 0;\n}","fileType":"cpp14","line":17,"column":24,"wordToComplete":"as","offset":316}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asd\n    return 0;\n}","fileType":"cpp14","line":17,"column":25,"wordToComplete":"asd","offset":317}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asda\n    return 0;\n}","fileType":"cpp14","line":17,"column":26,"wordToComplete":"asda","offset":318}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdas\n    return 0;\n}","fileType":"cpp14","line":17,"column":27,"wordToComplete":"asdas","offset":319}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\n    return 0;\n}","fileType":"cpp14","line":17,"column":28,"wordToComplete":"asdasd","offset":320}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    r\n    return 0;\n}","fileType":"cpp14","line":18,"column":5,"wordToComplete":"r","offset":328}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    re\n    return 0;\n}","fileType":"cpp14","line":18,"column":6,"wordToComplete":"re","offset":329}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    re\n    return 0;\n}","fileType":"cpp14","line":18,"column":6,"wordToComplete":"re","offset":329}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    r\n    return 0;\n}","fileType":"cpp14","line":18,"column":5,"wordToComplete":"r","offset":328}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    r\n    return 0;\n}","fileType":"cpp14","line":18,"column":5,"wordToComplete":"r","offset":328}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    re\n    return 0;\n}","fileType":"cpp14","line":18,"column":6,"wordToComplete":"re","offset":329}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    rev\n    return 0;\n}","fileType":"cpp14","line":18,"column":7,"wordToComplete":"rev","offset":330}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    reve\n    return 0;\n}","fileType":"cpp14","line":18,"column":8,"wordToComplete":"reve","offset":331}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    revers\n    return 0;\n}","fileType":"cpp14","line":18,"column":10,"wordToComplete":"revers","offset":333}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nstd::string reverse_string(const std::string& str)\n{\n    \n}\n\nstd::string reverse_string(std::string&& str)\n{\n    \n}\n\nint main()\n{\n    std::string str =\"asdasd\";\n    reverse\n    return 0;\n}","fileType":"cpp14","line":18,"column":11,"wordToComplete":"reverse","offset":334}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nc\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":1,"wordToComplete":"c","offset":163}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\ncl\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":2,"wordToComplete":"cl","offset":164}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\ncla\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":3,"wordToComplete":"cla","offset":165}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\ncla\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":3,"wordToComplete":"cla","offset":165}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclas\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":4,"wordToComplete":"clas","offset":166}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass S\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":7,"wordToComplete":"S","offset":169}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Si\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":8,"wordToComplete":"Si","offset":170}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Sin\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":9,"wordToComplete":"Sin","offset":171}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Sing\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":10,"wordToComplete":"Sing","offset":172}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singl\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":11,"wordToComplete":"Singl","offset":173}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Single\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":12,"wordToComplete":"Single","offset":174}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singlet\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":13,"wordToComplete":"Singlet","offset":175}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleto\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":14,"wordToComplete":"Singleto","offset":176}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":5,"column":15,"wordToComplete":"Singleton","offset":177}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    S\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":5,"wordToComplete":"S","offset":185}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    Si\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":6,"wordToComplete":"Si","offset":186}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    Sin\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":7,"wordToComplete":"Sin","offset":187}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    Sing\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":8,"wordToComplete":"Sing","offset":188}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    Sing\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":8,"wordToComplete":"Sing","offset":188}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\np\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":1,"wordToComplete":"p","offset":181}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\npu\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":2,"wordToComplete":"pu","offset":182}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\npubl\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":4,"wordToComplete":"publ","offset":184}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\npubli\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":5,"wordToComplete":"publi","offset":185}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\npublic\n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":6,"wordToComplete":"public","offset":186}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    p\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":5,"wordToComplete":"p","offset":185}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    pr\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":6,"wordToComplete":"pr","offset":186}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    pri\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":7,"wordToComplete":"pri","offset":187}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    priv\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":8,"wordToComplete":"priv","offset":188}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    priva\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":9,"wordToComplete":"priva","offset":189}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    privat\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":10,"wordToComplete":"privat","offset":190}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    S\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":5,"wordToComplete":"S","offset":194}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Si\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":6,"wordToComplete":"Si","offset":195}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Sin\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":7,"wordToComplete":"Sin","offset":196}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Sing\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":8,"wordToComplete":"Sing","offset":197}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Single\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":10,"wordToComplete":"Single","offset":199}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = d\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":19,"wordToComplete":"d","offset":208}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = de\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":20,"wordToComplete":"de","offset":209}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = def\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":21,"wordToComplete":"def","offset":210}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = defa\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":22,"wordToComplete":"defa","offset":211}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = defau\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":23,"wordToComplete":"defau","offset":212}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = defaul\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":24,"wordToComplete":"defaul","offset":213}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":25,"wordToComplete":"default","offset":214}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~S\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":6,"wordToComplete":"S","offset":222}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Si\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":7,"wordToComplete":"Si","offset":223}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Sin\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":8,"wordToComplete":"Sin","offset":224}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Sing\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":9,"wordToComplete":"Sing","offset":225}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singl\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":10,"wordToComplete":"Singl","offset":226}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Single\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":11,"wordToComplete":"Single","offset":227}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singlet\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":12,"wordToComplete":"Singlet","offset":228}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleto\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":13,"wordToComplete":"Singleto","offset":229}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":14,"wordToComplete":"Singleton","offset":230}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = d\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":20,"wordToComplete":"d","offset":236}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = de\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":21,"wordToComplete":"de","offset":237}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = def\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":22,"wordToComplete":"def","offset":238}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = defa\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":23,"wordToComplete":"defa","offset":239}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = defau\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":24,"wordToComplete":"defau","offset":240}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = defaul\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":25,"wordToComplete":"defaul","offset":241}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":26,"wordToComplete":"default","offset":242}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    S\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":5,"wordToComplete":"S","offset":254}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Si\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":6,"wordToComplete":"Si","offset":255}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Sing\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":8,"wordToComplete":"Sing","offset":257}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singe\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":9,"wordToComplete":"Singe","offset":258}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singel\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":10,"wordToComplete":"Singel","offset":259}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singl\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":9,"wordToComplete":"Singl","offset":258}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Single\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":10,"wordToComplete":"Single","offset":259}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singlet\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":11,"wordToComplete":"Singlet","offset":260}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = d\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":35,"wordToComplete":"d","offset":284}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = de\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":36,"wordToComplete":"de","offset":285}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = del\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":37,"wordToComplete":"del","offset":286}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = dele\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":38,"wordToComplete":"dele","offset":287}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delet\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":39,"wordToComplete":"delet","offset":288}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete\npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":11,"column":40,"wordToComplete":"delete","offset":289}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    S\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":5,"wordToComplete":"S","offset":338}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Si\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":6,"wordToComplete":"Si","offset":339}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    S\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":5,"wordToComplete":"S","offset":338}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    S\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":5,"wordToComplete":"S","offset":338}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Si\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":6,"wordToComplete":"Si","offset":339}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Sin\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":7,"wordToComplete":"Sin","offset":340}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Sing\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":8,"wordToComplete":"Sing","offset":341}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singl\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":9,"wordToComplete":"Singl","offset":342}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singlet\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":11,"wordToComplete":"Singlet","offset":344}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleto\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":12,"wordToComplete":"Singleto","offset":345}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& o\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":16,"wordToComplete":"o","offset":349}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& op\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":17,"wordToComplete":"op","offset":350}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& ope\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":18,"wordToComplete":"ope","offset":351}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& oper\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":19,"wordToComplete":"oper","offset":352}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& opera\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":20,"wordToComplete":"opera","offset":353}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operat\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":21,"wordToComplete":"operat","offset":354}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operato\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":22,"wordToComplete":"operato","offset":355}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":23,"wordToComplete":"operator","offset":356}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = d\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":46,"wordToComplete":"d","offset":379}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = de\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":47,"wordToComplete":"de","offset":380}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = del\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":48,"wordToComplete":"del","offset":381}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = dele\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":49,"wordToComplete":"dele","offset":382}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delet\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":50,"wordToComplete":"delet","offset":383}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":14,"column":51,"wordToComplete":"delete","offset":384}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    S\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":5,"wordToComplete":"S","offset":391}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Si\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":6,"wordToComplete":"Si","offset":392}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Sin\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":7,"wordToComplete":"Sin","offset":393}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Sing\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":8,"wordToComplete":"Sing","offset":394}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Single\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":10,"wordToComplete":"Single","offset":396}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singlet\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":11,"wordToComplete":"Singlet","offset":397}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleto\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":12,"wordToComplete":"Singleto","offset":398}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":13,"wordToComplete":"Singleton","offset":399}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& o\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":16,"wordToComplete":"o","offset":402}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& op\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":17,"wordToComplete":"op","offset":403}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& ope\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":18,"wordToComplete":"ope","offset":404}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& oper\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":19,"wordToComplete":"oper","offset":405}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& opera\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":20,"wordToComplete":"opera","offset":406}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operat\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":21,"wordToComplete":"operat","offset":407}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operato\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":22,"wordToComplete":"operato","offset":408}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":23,"wordToComplete":"operator","offset":409}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = d\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":41,"wordToComplete":"d","offset":427}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = de\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":42,"wordToComplete":"de","offset":428}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = del\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":43,"wordToComplete":"del","offset":429}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = del\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":43,"wordToComplete":"del","offset":429}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    \n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete\n    \npublic:\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":15,"column":46,"wordToComplete":"delete","offset":432}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    p\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":5,"wordToComplete":"p","offset":185}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    pr\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":6,"wordToComplete":"pr","offset":186}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    pri\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":7,"wordToComplete":"pri","offset":187}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    priv\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":8,"wordToComplete":"priv","offset":188}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    privat\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":10,"wordToComplete":"privat","offset":190}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\n    private\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":7,"column":11,"wordToComplete":"private","offset":191}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    s\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":5,"wordToComplete":"s","offset":194}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    st\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":6,"wordToComplete":"st","offset":195}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    sta\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":7,"wordToComplete":"sta","offset":196}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    stat\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":8,"wordToComplete":"stat","offset":197}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    stat\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":8,"wordToComplete":"stat","offset":197}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static s\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":12,"wordToComplete":"s","offset":201}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static S\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":12,"wordToComplete":"S","offset":201}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Si\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":13,"wordToComplete":"Si","offset":202}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Sin\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":14,"wordToComplete":"Sin","offset":203}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Sing\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":15,"wordToComplete":"Sing","offset":204}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singl\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":16,"wordToComplete":"Singl","offset":205}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Single\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":17,"wordToComplete":"Single","offset":206}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singlet\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":18,"wordToComplete":"Singlet","offset":207}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleto\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":19,"wordToComplete":"Singleto","offset":208}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s\nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":8,"column":23,"wordToComplete":"s","offset":212}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    g\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":5,"wordToComplete":"g","offset":495}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    ge\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":6,"wordToComplete":"ge","offset":496}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    S\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":5,"wordToComplete":"S","offset":495}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Si\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":6,"wordToComplete":"Si","offset":496}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Sin\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":7,"wordToComplete":"Sin","offset":497}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Sing\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":8,"wordToComplete":"Sing","offset":498}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Singl\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":9,"wordToComplete":"Singl","offset":499}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Singleto\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":12,"wordToComplete":"Singleto","offset":502}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Singleton\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":13,"wordToComplete":"Singleton","offset":503}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Singleton g\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":15,"wordToComplete":"g","offset":505}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Singleton ge\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":16,"wordToComplete":"ge","offset":506}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Singleton* g\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":16,"wordToComplete":"g","offset":506}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Singleton* ge\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":17,"wordToComplete":"ge","offset":507}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    Singleton* get\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":20,"column":18,"wordToComplete":"get","offset":508}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        i\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":22,"column":9,"wordToComplete":"i","offset":542}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":22,"column":10,"wordToComplete":"if","offset":543}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":13,"wordToComplete":"s","offset":583}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = n\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":26,"wordToComplete":"n","offset":596}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = ne\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":27,"wordToComplete":"ne","offset":597}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":28,"wordToComplete":"new","offset":598}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":28,"wordToComplete":"new","offset":598}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new S\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":30,"wordToComplete":"S","offset":600}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Si\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":31,"wordToComplete":"Si","offset":601}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Sin\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":32,"wordToComplete":"Sin","offset":602}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Sing\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":33,"wordToComplete":"Sing","offset":603}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singl\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":34,"wordToComplete":"Singl","offset":604}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Single\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":35,"wordToComplete":"Single","offset":605}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singlet\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":36,"wordToComplete":"Singlet","offset":606}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleto\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":37,"wordToComplete":"Singleto","offset":607}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton\n        }\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":38,"wordToComplete":"Singleton","offset":608}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        r\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":25,"column":9,"wordToComplete":"r","offset":631}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        re\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":25,"column":10,"wordToComplete":"re","offset":632}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        ret\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":25,"column":11,"wordToComplete":"ret","offset":633}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        retu\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":25,"column":12,"wordToComplete":"retu","offset":634}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        retur\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":25,"column":13,"wordToComplete":"retur","offset":635}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":25,"column":14,"wordToComplete":"return","offset":636}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":25,"column":16,"wordToComplete":"s","offset":638}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    s\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":5,"wordToComplete":"s","offset":228}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    st\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":6,"wordToComplete":"st","offset":229}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    sta\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":7,"wordToComplete":"sta","offset":230}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    stat\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":8,"wordToComplete":"stat","offset":231}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    stat\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":8,"wordToComplete":"stat","offset":231}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    stati\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":9,"wordToComplete":"stati","offset":232}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":10,"wordToComplete":"static","offset":233}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static s\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":12,"wordToComplete":"s","offset":235}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static st\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":13,"wordToComplete":"st","offset":236}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":14,"wordToComplete":"std","offset":237}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::m\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":17,"wordToComplete":"m","offset":240}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mu\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":18,"wordToComplete":"mu","offset":241}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mut\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":19,"wordToComplete":"mut","offset":242}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mute\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":20,"wordToComplete":"mute","offset":243}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":9,"column":21,"wordToComplete":"mutex","offset":244}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            s\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":13,"wordToComplete":"s","offset":606}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            st\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":14,"wordToComplete":"st","offset":607}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            std\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":15,"wordToComplete":"std","offset":608}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            std\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":15,"wordToComplete":"std","offset":608}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            std::l\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":18,"wordToComplete":"l","offset":611}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            std::lo\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":19,"wordToComplete":"lo","offset":612}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            std::loc\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":20,"wordToComplete":"loc","offset":613}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            std::lock\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":21,"wordToComplete":"lock","offset":614}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> l\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":41,"wordToComplete":"l","offset":634}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lo\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":42,"wordToComplete":"lo","offset":635}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> loc\n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":43,"wordToComplete":"loc","offset":636}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        s\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":9,"wordToComplete":"s","offset":565}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        st\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":10,"wordToComplete":"st","offset":566}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        st\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":10,"wordToComplete":"st","offset":566}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        sta\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":11,"wordToComplete":"sta","offset":567}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        stat\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":12,"wordToComplete":"stat","offset":568}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        stati\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":13,"wordToComplete":"stati","offset":569}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":14,"wordToComplete":"static","offset":570}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static s\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":23,"column":16,"wordToComplete":"s","offset":572}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static s_instance;\n        r\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":9,"wordToComplete":"r","offset":592}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static s_instance;\n        re\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":10,"wordToComplete":"re","offset":593}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static s_instance;\n        ret\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":11,"wordToComplete":"ret","offset":594}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static s_instance;\n        ret\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":11,"wordToComplete":"ret","offset":594}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static Singletgon s_instance;\n        retu\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":12,"wordToComplete":"retu","offset":606}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static Singletgon s_instance;\n        retur\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":13,"wordToComplete":"retur","offset":607}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static Singletgon s_instance;\n        return\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":14,"wordToComplete":"return","offset":608}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n#include <iostream>\n#include <string>\n\nclass Singleton\n{\nprivate:\n    static Singleton* s_instance;\n    static std::mutex;\n    \nprivate:\n    Singleton() = default;\n    ~Singleton() = default;\n    \n    Singleton(const Singleton&) = delete;\n    Singleton(Singleton&&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    Singleton& operator=(Singleton&&) = delete;\n    \npublic:\n    static Singleton* get_instance()\n    {\n        static Singletgon s_instance;\n        return s\n        if (nullptr == s_instance) {\n            std::lock_guard<std::mutex> lock;\n            \n            s_instance = new Singleton();\n        }\n        return s_instance;\n    }\n\n    \n    \n};\n\nint main()\n{\n    return 0;\n}","fileType":"cpp14","line":24,"column":16,"wordToComplete":"s","offset":610}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\nclass Animal\n{\npublic:\n    virtual std::string description() const\n    {\n        std::cout << \"Animal\\n\";\n    }\n    \n    virtual void eat() = 0;\n    virtual void voice() = 0;\n    virtual ~Animal();\n};\n\nclass Birds\n{\n\n};\n\nclass M: public Animal\n{\npublic:\n    void eat() override\n    {\n        eat carrot;\n    }\n    \n    void voice() override\n    {\n        std::cout << \"mau\\n\"\n    }\n        \n};\n\nAnimal* p = new Cat();\ndelete p;","fileType":"cpp14","line":21,"column":7,"wordToComplete":"Animal","offset":352}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\nclass Animal\n{\npublic:\n    virtual std::string description() const\n    {\n        std::cout << \"Animal\\n\";\n    }\n    \n    virtual void eat() = 0;\n    virtual void voice() = 0;\n    virtual ~Animal();\n};\n\nclass Birds\n{\n\n};\n\nclass Mamm: public Animal\n{\npublic:\n    void eat() override\n    {\n        eat carrot;\n    }\n    \n    void voice() override\n    {\n        std::cout << \"mau\\n\"\n    }\n        \n};\n\nAnimal* p = new Cat();\ndelete p;","fileType":"cpp14","line":21,"column":10,"wordToComplete":"Animal","offset":355}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\nclass Animal\n{\npublic:\n    virtual std::string description() const\n    {\n        std::cout << \"Animal\\n\";\n    }\n    \n    virtual void eat() = 0;\n    virtual void voice() = 0;\n    virtual ~Animal();\n};\n\nclass Birds\n{\n\n};\n\nclass Mamma: public Animal\n{\npublic:\n    void eat() override\n    {\n        eat carrot;\n    }\n    \n    void voice() override\n    {\n        std::cout << \"mau\\n\"\n    }\n        \n};\n\nAnimal* p = new Cat();\ndelete p;","fileType":"cpp14","line":21,"column":11,"wordToComplete":"Animal","offset":356}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\nclass Animal\n{\npublic:\n    virtual std::string description() const\n    {\n        std::cout << \"Animal\\n\";\n    }\n    \n    virtual void eat() = 0;\n    virtual void voice() = 0;\n    virtual ~Animal();\n};\n\nclass Birds\n{\n\n};\n\nclass Mammal: public Animal\n{\npublic:\n    void eat() override\n    {\n        eat carrot;\n    }\n    \n    void voice() override\n    {\n        std::cout << \"mau\\n\"\n    }\n        \n};\n\nAnimal* p = new Cat();\ndelete p;","fileType":"cpp14","line":21,"column":12,"wordToComplete":"Animal","offset":357}}
{"body": {"code":"// This is the text editor interface. \n// Anything you type or change here will be seen by the other person in real time.\n\nclass Animal\n{\npublic:\n    virtual std::string description() const\n    {\n        std::cout << \"Animal\\n\";\n    }\n    \n    virtual void eat() = 0;\n    virtual void voice() = 0;\n    virtual ~Animal();\n};\n\nclass Birds\n{\n\n};\n\nclass Mammals: public Animal\n{\npublic:\n    void eat() override\n    {\n        eat carrot;\n    }\n    \n    void voice() override\n    {\n        std::cout << \"mau\\n\"\n    }\n        \n};\n\nAnimal* p = new Cat();\ndelete p;","fileType":"cpp14","line":21,"column":13,"wordToComplete":"Animal","offset":358}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nvector<string> printKLargest(string& base, int depth) {\n    v\n}","fileType":"cpp14","line":31,"column":5,"wordToComplete":"v","offset":620}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nvector<string> printKLargest(string& base, int depth) {\n    ve\n}","fileType":"cpp14","line":31,"column":6,"wordToComplete":"ve","offset":621}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nvector<string> printKLargest(string& base, int depth) {\n    ve\n}","fileType":"cpp14","line":31,"column":6,"wordToComplete":"ve","offset":621}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nvector<string> printKLargest(string& base, int depth) {\n    vec\n}","fileType":"cpp14","line":31,"column":7,"wordToComplete":"vec","offset":622}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<s\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":12,"wordToComplete":"s","offset":612}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<st\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":13,"wordToComplete":"st","offset":613}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<str\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":14,"wordToComplete":"str","offset":614}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<stri\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":15,"wordToComplete":"stri","offset":615}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<strin\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":16,"wordToComplete":"strin","offset":616}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":17,"wordToComplete":"string","offset":617}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> a\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":20,"wordToComplete":"a","offset":620}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> ac\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":21,"wordToComplete":"ac","offset":621}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> aca\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":22,"wordToComplete":"aca","offset":622}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> ac\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":21,"wordToComplete":"ac","offset":621}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> a\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":20,"wordToComplete":"a","offset":620}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> c\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":20,"wordToComplete":"c","offset":620}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> can\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":22,"wordToComplete":"can","offset":622}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> cand\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":23,"wordToComplete":"cand","offset":623}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candi\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":24,"wordToComplete":"candi","offset":624}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candid\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":25,"wordToComplete":"candid","offset":625}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candid\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":25,"wordToComplete":"candid","offset":625}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candida\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":26,"wordToComplete":"candida","offset":626}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidat\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":27,"wordToComplete":"candidat","offset":627}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":31,"column":28,"wordToComplete":"candidate","offset":628}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    v\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":5,"wordToComplete":"v","offset":635}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    ve\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":6,"wordToComplete":"ve","offset":636}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    vec\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":7,"wordToComplete":"vec","offset":637}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    vec\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":7,"wordToComplete":"vec","offset":637}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    vect\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":8,"wordToComplete":"vect","offset":638}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    vect\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":8,"wordToComplete":"vect","offset":638}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    vec\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":7,"wordToComplete":"vec","offset":637}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    ve\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":6,"wordToComplete":"ve","offset":636}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    v\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":5,"wordToComplete":"v","offset":635}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    m\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":5,"wordToComplete":"m","offset":635}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    ma\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":6,"wordToComplete":"ma","offset":636}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":7,"wordToComplete":"map","offset":637}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":7,"wordToComplete":"map","offset":637}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    m\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":5,"wordToComplete":"m","offset":635}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    s\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":5,"wordToComplete":"s","offset":635}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    se\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":6,"wordToComplete":"se","offset":636}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    set\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":7,"wordToComplete":"set","offset":637}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    set<s\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":9,"wordToComplete":"s","offset":639}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    set<s\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":9,"wordToComplete":"s","offset":639}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    m\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":5,"wordToComplete":"m","offset":635}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    ma\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":6,"wordToComplete":"ma","offset":636}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":7,"wordToComplete":"map","offset":637}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<i\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":9,"wordToComplete":"i","offset":639}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, s\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":14,"wordToComplete":"s","offset":644}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, st\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":15,"wordToComplete":"st","offset":645}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, str\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":16,"wordToComplete":"str","offset":646}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, stri\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":17,"wordToComplete":"stri","offset":647}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, strin\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":18,"wordToComplete":"strin","offset":648}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":19,"wordToComplete":"string","offset":649}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> f\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":22,"wordToComplete":"f","offset":652}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> s\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":22,"wordToComplete":"s","offset":652}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> so\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":23,"wordToComplete":"so","offset":653}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> d\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":22,"wordToComplete":"d","offset":652}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> da\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":23,"wordToComplete":"da","offset":653}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> dat\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":24,"wordToComplete":"dat","offset":654}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":32,"column":25,"wordToComplete":"data","offset":655}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data;\n    \n    c\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":5,"wordToComplete":"c","offset":667}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data;\n    \n    ca\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":6,"wordToComplete":"ca","offset":668}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data;\n    \n    ca\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":6,"wordToComplete":"ca","offset":668}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data;\n    \n    c\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":5,"wordToComplete":"c","offset":667}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data;\n    \n    w\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":5,"wordToComplete":"w","offset":667}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data;\n    \n    wh\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":6,"wordToComplete":"wh","offset":668}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data;\n    \n    whi\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":7,"wordToComplete":"whi","offset":669}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data;\n    \n    whil\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":8,"wordToComplete":"whil","offset":670}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    vector<string> candidate;\n    map<int, string> data;\n    \n    while\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":9,"wordToComplete":"while","offset":671}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    c\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":5,"wordToComplete":"c","offset":666}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    ca\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":6,"wordToComplete":"ca","offset":667}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    can\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":7,"wordToComplete":"can","offset":668}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    cand\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":8,"wordToComplete":"cand","offset":669}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    canda\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":9,"wordToComplete":"canda","offset":670}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    cand\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":8,"wordToComplete":"cand","offset":669}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candi\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":9,"wordToComplete":"candi","offset":670}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candid\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":10,"wordToComplete":"candid","offset":671}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candida\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":11,"wordToComplete":"candida","offset":672}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":14,"wordToComplete":".","offset":675}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":14,"wordToComplete":".","offset":675}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.pu\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":16,"wordToComplete":"pu","offset":677}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.pus\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":17,"wordToComplete":"pus","offset":678}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push\n    while ()\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":34,"column":18,"wordToComplete":"push","offset":679}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        s\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":9,"wordToComplete":"s","offset":729}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        st\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":10,"wordToComplete":"st","offset":730}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        str\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":11,"wordToComplete":"str","offset":731}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        stri\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":12,"wordToComplete":"stri","offset":732}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        strin\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":13,"wordToComplete":"strin","offset":733}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":14,"wordToComplete":"string","offset":734}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string c\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":16,"wordToComplete":"c","offset":736}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string ch\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":17,"wordToComplete":"ch","offset":737}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string che\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":18,"wordToComplete":"che","offset":738}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string chec\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":19,"wordToComplete":"chec","offset":739}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":20,"wordToComplete":"check","offset":740}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = c\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":24,"wordToComplete":"c","offset":744}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = ca\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":25,"wordToComplete":"ca","offset":745}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = can\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":26,"wordToComplete":"can","offset":746}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = cand\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":27,"wordToComplete":"cand","offset":747}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candi\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":28,"wordToComplete":"candi","offset":748}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candid\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":29,"wordToComplete":"candid","offset":749}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candida\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":30,"wordToComplete":"candida","offset":750}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidat\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":31,"wordToComplete":"candidat","offset":751}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":32,"wordToComplete":"candidate","offset":752}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":33,"wordToComplete":".","offset":753}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":33,"wordToComplete":".","offset":753}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":33,"wordToComplete":".","offset":753}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.f\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":34,"wordToComplete":"f","offset":754}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.fro\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":36,"wordToComplete":"fro","offset":756}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.fron\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":37,"wordToComplete":"fron","offset":757}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":36,"column":38,"wordToComplete":"front","offset":758}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        c\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":9,"wordToComplete":"c","offset":771}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        ca\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":10,"wordToComplete":"ca","offset":772}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        can\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":11,"wordToComplete":"can","offset":773}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        cand\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":12,"wordToComplete":"cand","offset":774}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candi\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":13,"wordToComplete":"candi","offset":775}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candid\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":14,"wordToComplete":"candid","offset":776}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candid\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":14,"wordToComplete":"candid","offset":776}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidat\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":16,"wordToComplete":"candidat","offset":778}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":17,"wordToComplete":"candidate","offset":779}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":18,"wordToComplete":".","offset":780}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":18,"wordToComplete":".","offset":780}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.po\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":20,"wordToComplete":"po","offset":782}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":37,"column":21,"wordToComplete":"pop","offset":783}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        i\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":38,"column":9,"wordToComplete":"i","offset":796}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":38,"column":10,"wordToComplete":"if","offset":797}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            f\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":39,"column":13,"wordToComplete":"f","offset":828}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            fo\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":39,"column":14,"wordToComplete":"fo","offset":829}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":39,"column":15,"wordToComplete":"for","offset":830}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                c\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":17,"wordToComplete":"c","offset":876}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                ca\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":18,"wordToComplete":"ca","offset":877}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                can\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":19,"wordToComplete":"can","offset":878}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                cand\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":20,"wordToComplete":"cand","offset":879}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candid\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":22,"wordToComplete":"candid","offset":881}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candida\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":23,"wordToComplete":"candida","offset":882}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidat\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":24,"wordToComplete":"candidat","offset":883}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":25,"wordToComplete":"candidate","offset":884}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":26,"wordToComplete":".","offset":885}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":26,"wordToComplete":".","offset":885}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.p\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":27,"wordToComplete":"p","offset":886}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.pu\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":28,"wordToComplete":"pu","offset":887}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.pus\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":29,"wordToComplete":"pus","offset":888}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push\n            }\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":40,"column":30,"wordToComplete":"push","offset":889}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            c\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":42,"column":13,"wordToComplete":"c","offset":921}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            co\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":42,"column":14,"wordToComplete":"co","offset":922}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            con\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":42,"column":15,"wordToComplete":"con","offset":923}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            cont\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":42,"column":16,"wordToComplete":"cont","offset":924}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            conti\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":42,"column":17,"wordToComplete":"conti","offset":925}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            contin\n        }\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":42,"column":18,"wordToComplete":"contin","offset":926}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        d\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":9,"wordToComplete":"d","offset":949}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        da\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":10,"wordToComplete":"da","offset":950}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        dat\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":11,"wordToComplete":"dat","offset":951}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":12,"wordToComplete":"data","offset":952}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":13,"wordToComplete":".","offset":953}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":13,"wordToComplete":".","offset":953}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":13,"wordToComplete":".","offset":953}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.i\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":14,"wordToComplete":"i","offset":954}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.in\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":15,"wordToComplete":"in","offset":955}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.ins\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":16,"wordToComplete":"ins","offset":956}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.inse\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":17,"wordToComplete":"inse","offset":957}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.inser\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":18,"wordToComplete":"inser","offset":958}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":19,"wordToComplete":"insert","offset":959}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.i\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":14,"wordToComplete":"i","offset":954}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.in\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":15,"wordToComplete":"in","offset":955}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.ins\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":16,"wordToComplete":"ins","offset":956}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.inse\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":17,"wordToComplete":"inse","offset":957}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.inser\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":18,"wordToComplete":"inser","offset":958}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":44,"column":19,"wordToComplete":"insert","offset":959}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    f\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":5,"wordToComplete":"f","offset":1010}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    fo\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":6,"wordToComplete":"fo","offset":1011}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    for\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":7,"wordToComplete":"for","offset":1012}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    for (int i = 0; i < depth; i++) {\n        c\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":9,"wordToComplete":"c","offset":1052}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    for (int i = 0; i < depth; i++) {\n        co\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":10,"wordToComplete":"co","offset":1053}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    for (int i = 0; i < depth; i++) {\n        cou\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":11,"wordToComplete":"cou","offset":1054}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    for (int i = 0; i < depth; i++) {\n        cout\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":12,"wordToComplete":"cout","offset":1055}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    a\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":5,"wordToComplete":"a","offset":1010}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    au\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":6,"wordToComplete":"au","offset":1011}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    aut\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":7,"wordToComplete":"aut","offset":1012}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":8,"wordToComplete":"auto","offset":1013}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto i\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":10,"wordToComplete":"i","offset":1015}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":11,"wordToComplete":"it","offset":1016}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = d\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":15,"wordToComplete":"d","offset":1020}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = da\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":16,"wordToComplete":"da","offset":1021}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = dat\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":17,"wordToComplete":"dat","offset":1022}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":18,"wordToComplete":"data","offset":1023}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":19,"wordToComplete":".","offset":1024}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":19,"wordToComplete":".","offset":1024}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":19,"wordToComplete":".","offset":1024}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rb\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":21,"wordToComplete":"rb","offset":1026}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbe\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":22,"wordToComplete":"rbe","offset":1027}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbeg\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":23,"wordToComplete":"rbeg","offset":1028}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegi\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":24,"wordToComplete":"rbegi","offset":1029}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin\n    for (int i = 0; i < depth; i++) {\n        cout << \n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":25,"wordToComplete":"rbegin","offset":1030}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << i\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":49,"column":17,"wordToComplete":"i","offset":1089}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":49,"column":18,"wordToComplete":"it","offset":1090}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->s\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":49,"column":21,"wordToComplete":"s","offset":1093}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->se\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":49,"column":22,"wordToComplete":"se","offset":1094}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->sec\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":49,"column":23,"wordToComplete":"sec","offset":1095}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << e\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":49,"column":31,"wordToComplete":"e","offset":1103}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << en\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":49,"column":32,"wordToComplete":"en","offset":1104}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << end\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":49,"column":33,"wordToComplete":"end","offset":1105}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    map<int, string> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.insert(make_pair(sizeof(check), check));\n    }\n    \n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":49,"column":34,"wordToComplete":"endl","offset":1106}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    s\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":5,"wordToComplete":"s","offset":1022}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    so\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":6,"wordToComplete":"so","offset":1023}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sor\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":7,"wordToComplete":"sor","offset":1024}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":8,"wordToComplete":"sort","offset":1025}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":8,"wordToComplete":"sort","offset":1025}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":47,"column":8,"wordToComplete":"sort","offset":1025}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        r\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":9,"wordToComplete":"r","offset":1082}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        re\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":10,"wordToComplete":"re","offset":1083}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        ret\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":11,"wordToComplete":"ret","offset":1084}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        retu\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":12,"wordToComplete":"retu","offset":1085}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        retur\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":13,"wordToComplete":"retur","offset":1086}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":16,"wordToComplete":"a","offset":1089}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":16,"wordToComplete":"a","offset":1089}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":16,"wordToComplete":"a","offset":1089}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->f\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":19,"wordToComplete":"f","offset":1092}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->fi\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":20,"wordToComplete":"fi","offset":1093}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->fir\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":21,"wordToComplete":"fir","offset":1094}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->firs\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":22,"wordToComplete":"firs","offset":1095}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":23,"wordToComplete":"first","offset":1096}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first > b\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":27,"wordToComplete":"b","offset":1100}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first > b.\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":28,"wordToComplete":".","offset":1101}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first > b.\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":28,"wordToComplete":".","offset":1101}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first > b.\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":28,"wordToComplete":".","offset":1101}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first > b.f\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":29,"wordToComplete":"f","offset":1102}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first > b.fi\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":30,"wordToComplete":"fi","offset":1103}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first > b.fir\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":31,"wordToComplete":"fir","offset":1104}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first > b.firs\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":32,"wordToComplete":"firs","offset":1105}}
{"body": {"code":"#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    printKLargest(\"A\", 3);\n    return 0;\n}\n\nprintKLargest(string& base, int depth) {\n    queue<string> candidate;\n    vector<pair<int, string>> data;\n    \n    candidate.push(base);\n    while (!candidate.empty()) {\n        string check = candidate.front();\n        candidate.pop();\n        if (isdir(check)) {\n            for(auto i: listfiles(check)) {\n                candidate.push(i);\n            }\n            continue;\n        }\n        data.push_back(make_pair(sizeof(check), check));\n    }\n    \n    sort(data.begin(), data.end(), [](auto a, auto b) {\n        return a->first > b.first\n    });\n    auto it = data.rbegin();\n    for (int i = 0; i < depth; i++) {\n        cout << it->second << endl;\n    }\n}\n\n// listfiles(\"A\") => [\"A/B\", \"A/C\", \"A/foo\"]","fileType":"cpp14","line":48,"column":33,"wordToComplete":"first","offset":1106}}
