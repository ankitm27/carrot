{"body": {"column":16,"line":6,"wordToComplete":"","code":"\ndef element_at(arr, index)\n  arr[index]\nend\n\ndef inclusive_range(arr, start_pos, end_pos)\n  arr[start_pos.end_pos (both inclusive)\nend\n\ndef non_inclusive_range(arr, start_pos, end_pos)\n    # return the elements of the Array variable `arr`, start_pos inclusive and end_pos exclusive\nend\n\ndef start_and_length(arr, start_pos, length)\n    # return `length` elements of the Array variable `arr` starting from `start_pos`\nend\n\n\n","offset":108,"fileType":"ruby","requestStartTime":1517909923777}}
{"body": {"column":17,"line":6,"wordToComplete":"","code":"\ndef element_at(arr, index)\n  arr[index]\nend\n\ndef inclusive_range(arr, start_pos, end_pos)\n  arr[start_pos..end_pos (both inclusive)\nend\n\ndef non_inclusive_range(arr, start_pos, end_pos)\n    # return the elements of the Array variable `arr`, start_pos inclusive and end_pos exclusive\nend\n\ndef start_and_length(arr, start_pos, length)\n    # return `length` elements of the Array variable `arr` starting from `start_pos`\nend\n\n\n","offset":109,"fileType":"ruby","requestStartTime":1517909923963}}
{"body": {"column":18,"line":10,"wordToComplete":"","code":"\ndef element_at(arr, index)\n  arr[index]\nend\n\ndef inclusive_range(arr, start_pos, end_pos)\n  arr[start_pos..end_pos]\nend\n\ndef non_inclusive_range(arr, start_pos, end_pos)\n  arr[start_pos...end_pos]\nend\n\ndef start_and_length(arr, start_pos, length)\n    # return `length` elements of the Array variable `arr` starting from `start_pos`\nend\n\n\n","offset":190,"fileType":"ruby","requestStartTime":1517909949646}}
{"body": {"column":9,"line":2,"wordToComplete":"","code":"\ndef iterate_colors(colors)\n  colors.\nend\n\n\n\n","offset":38,"fileType":"ruby","requestStartTime":1517910042423}}
{"body": {"column":8,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef solve(n, p)\n   n/2 >\nend\n\nn = gets.strip.to_i\np = gets.strip.to_i\nresult = solve(n, p)\nputs result;\n\n\n","offset":39,"fileType":"ruby","requestStartTime":1517911015400}}
{"body": {"column":11,"line":4,"wordToComplete":"","code":"#!/bin/ruby\n\n\ndef findNumber(arr, k) \n    if arr.\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_arr_cnt = 0\n_arr_cnt = Integer(gets)\n_arr_i=0\n_arr = Array.new(_arr_cnt)\n\nwhile (_arr_i < _arr_cnt)\n  _arr_item = Integer(gets);\n  _arr[_arr_i] = (_arr_item)\n  _arr_i+=1\nend\n\n\n_k = Integer(gets);\n\nres = findNumber(_arr, _k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":50,"fileType":"ruby","requestStartTime":1517911538806}}
{"body": {"column":9,"line":4,"wordToComplete":"","code":"#!/bin/ruby\n\n\ndef oddNumbers(l, r)\n    if l.\n    (l..r).step(2).to_a\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_l = Integer(gets);\n\n\n_r = Integer(gets);\n\nres = oddNumbers(_l, _r);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":45,"fileType":"ruby","requestStartTime":1517912061801}}
{"body": {"column":25,"line":4,"wordToComplete":"","code":"\n\ndef rot13(secret_messages)\n  # your code here\n  return secret_messages.\nend\n\n\n\n","offset":74,"fileType":"ruby","requestStartTime":1517915045489}}
{"body": {"column":7,"line":7,"wordToComplete":"e","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\n\ndef findNumber(arr, k) \n  arr.e\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_arr_cnt = 0\n_arr_cnt = Integer(gets)\n_arr_i=0\n_arr = Array.new(_arr_cnt)\n\nwhile (_arr_i < _arr_cnt)\n  _arr_item = Integer(gets);\n  _arr[_arr_i] = (_arr_item)\n  _arr_i+=1\nend\n\n\n_k = Integer(gets);\n\nres = findNumber(_arr, _k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":79,"fileType":"ruby","requestStartTime":1517916836507}}
{"body": {"column":11,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\n\ndef oddNumbers(l, r) \n  arr = [l.]\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_l = Integer(gets);\n\n\n_r = Integer(gets);\n\nres = oddNumbers(_l, _r);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":81,"fileType":"ruby","requestStartTime":1517917478309}}
{"body": {"column":12,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\n\ndef oddNumbers(l, r) \n  arr = [l..]\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_l = Integer(gets);\n\n\n_r = Integer(gets);\n\nres = oddNumbers(_l, _r);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":82,"fileType":"ruby","requestStartTime":1517917478464}}
{"body": {"column":7,"line":9,"wordToComplete":"e","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\n\ndef oddNumbers(l, r) \n  arr = (l..r)\n  data = []\n  arr.e\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_l = Integer(gets);\n\n\n_r = Integer(gets);\n\nres = oddNumbers(_l, _r);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":104,"fileType":"ruby","requestStartTime":1517917518669}}
{"body": {"column":7,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef simpleArraySum(n, ar)\n    ar.\n    # Complete this function\nend\n\nn = gets.strip.to_i\nar = gets.strip\nar = ar.split(' ').map(&:to_i)\nresult = simpleArraySum(n, ar)\nputs result;\n\n\n","offset":48,"fileType":"ruby","requestStartTime":1517917675415}}
{"body": {"column":15,"line":12,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\n\ndef oddNumbers(l, r) \n  arr = (l..r)\n  data = []\n  arr.each do |number|\n    data << if number % 2 == 0\n  end\n  [l, data, r].\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_l = Integer(gets);\n\n\n_r = Integer(gets);\n\nres = oddNumbers(_l, _r);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":172,"fileType":"ruby","requestStartTime":1517917687521}}
{"body": {"column":33,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef solve(a0, a1, a2, b0, b1, b2)\n    # Complete this function\n    [[a0, b0], [a1,b1],[a2, b2]].\nend\n\na0, a1, a2 = gets.strip.split(' ')\na0 = a0.to_i\na1 = a1.to_i\na2 = a2.to_i\nb0, b1, b2 = gets.strip.split(' ')\nb0 = b0.to_i\nb1 = b1.to_i\nb2 = b2.to_i\nresult = solve(a0, a1, a2, b0, b1, b2)\nprint result.join(\" \")\n\n\n\n\n","offset":111,"fileType":"ruby","requestStartTime":1517917920028}}
{"body": {"column":6,"line":8,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\n\ndef findNumber(arr, k) \n  puts arr\n  arr.\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_arr_cnt = 0\n_arr_cnt = Integer(gets)\n_arr_i=0\n_arr = Array.new(_arr_cnt)\n\nwhile (_arr_i < _arr_cnt)\n  _arr_item = Integer(gets);\n  _arr[_arr_i] = (_arr_item)\n  _arr_i+=1\nend\n\n\n_k = Integer(gets);\n\nres = findNumber(_arr, _k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":89,"fileType":"ruby","requestStartTime":1517918159084}}
{"body": {"column":33,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef solve(a0, a1, a2, b0, b1, b2)\n    # Complete this function\n    points = {true => 1, false =>}\n    a = a0 < b0\nend\n\na0, a1, a2 = gets.strip.split(' ')\na0 = a0.to_i\na1 = a1.to_i\na2 = a2.to_i\nb0, b1, b2 = gets.strip.split(' ')\nb0 = b0.to_i\nb1 = b1.to_i\nb2 = b2.to_i\nresult = solve(a0, a1, a2, b0, b1, b2)\nprint result.join(\" \")\n\n\n\n\n","offset":111,"fileType":"ruby","requestStartTime":1517918408800}}
{"body": {"column":6,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef aVeryBigSum(n, ar)\n    # Complete this function\n    n.\nend\n\nn = gets.strip.to_i\nar = gets.strip\nar = ar.split(' ').map(&:to_i)\nresult = aVeryBigSum(n, ar)\nputs result;\n\n\n","offset":73,"fileType":"ruby","requestStartTime":1517918573296}}
{"body": {"column":23,"line":1,"wordToComplete":"Mr.)__________'","code":"\nRegex_Pattern = '(?:Mr.)__________'\n\n\n\nprint !!(gets =~ /#{Regex_Pattern}/)\n","offset":25,"fileType":"ruby","requestStartTime":1517920413230}}
{"body": {"column":28,"line":1,"wordToComplete":"Mr.|Mrs.)__________'","code":"\nRegex_Pattern = '(?:Mr.|Mrs.)__________'\n\n\n\nprint !!(gets =~ /#{Regex_Pattern}/)\n","offset":30,"fileType":"ruby","requestStartTime":1517920415459}}
{"body": {"column":32,"line":1,"wordToComplete":"Mr.|Mrs.|Dr.)__________'","code":"\nRegex_Pattern = '(?:Mr.|Mrs.|Dr.)__________'\n\n\n\nprint !!(gets =~ /#{Regex_Pattern}/)\n","offset":34,"fileType":"ruby","requestStartTime":1517920417116}}
{"body": {"column":36,"line":1,"wordToComplete":"Mr.|Mrs.|Dr.|Er.)__________'","code":"\nRegex_Pattern = '(?:Mr.|Mrs.|Dr.|Er.)__________'\n\n\n\nprint !!(gets =~ /#{Regex_Pattern}/)\n","offset":38,"fileType":"ruby","requestStartTime":1517920420444}}
{"body": {"column":21,"line":3,"wordToComplete":"","code":"\n# Your code here\ndef convert_temp(temperature, input_scale, output_scale = 'celsius')\n    case input_scale.\n    when 'celsius'\n        if output_scale == 'fahrenheit'\n            return temperature * 1.8 + 32\n        elsif output_scale == 'kelvin'\n            return temperature + 273.15\n        end\n    when 'fahrenheit'\n        if output_scale == 'celsius'\n            return (temperature - 32) / 1.8\n        elsif output_scale == 'kelvin'\n            return (temperature - 32) / 1.8 + 273.15\n        end\n    when 'kelvin'\n        if output_scale == 'celsius'\n            return temperature - 273.15\n        elsif output_scale == 'fahrenheit'\n            return (temperature - 273.15) * 1.8 - 32\n        end\n    end \nend\n\n","offset":109,"fileType":"ruby","requestStartTime":1517920963723}}
{"body": {"column":15,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = (a.)\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":53,"fileType":"ruby","requestStartTime":1517923187640}}
{"body": {"column":16,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = (a..)\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":54,"fileType":"ruby","requestStartTime":1517923187760}}
{"body": {"column":17,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'.)\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":55,"fileType":"ruby","requestStartTime":1517923190291}}
{"body": {"column":18,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..)\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":56,"fileType":"ruby","requestStartTime":1517923190399}}
{"body": {"column":23,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":61,"fileType":"ruby","requestStartTime":1517923192662}}
{"body": {"column":17,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'.)\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":83,"fileType":"ruby","requestStartTime":1517923198970}}
{"body": {"column":18,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..)\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":84,"fileType":"ruby","requestStartTime":1517923199090}}
{"body": {"column":23,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":89,"fileType":"ruby","requestStartTime":1517923201625}}
{"body": {"column":6,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":105,"fileType":"ruby","requestStartTime":1517923275182}}
{"body": {"column":11,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.size.\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":110,"fileType":"ruby","requestStartTime":1517923275667}}
{"body": {"column":16,"line":8,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.size.times do |i|\n        if ('a'.)\n    end\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":139,"fileType":"ruby","requestStartTime":1517923321201}}
{"body": {"column":17,"line":8,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.size.times do |i|\n        if ('a'..)\n    end\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":140,"fileType":"ruby","requestStartTime":1517923321306}}
{"body": {"column":22,"line":8,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.size.times do |i|\n        if ('a'..'z').\n    end\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":145,"fileType":"ruby","requestStartTime":1517923323888}}
{"body": {"column":25,"line":9,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.size.times do |i|\n        if ('a'..'z').include? s[i]\n            s[i] = lower.\n        else\n        end\n    end\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":184,"fileType":"ruby","requestStartTime":1517923341415}}
{"body": {"column":57,"line":9,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.size.times do |i|\n        if ('a'..'z').include? s[i]\n            s[i] = lower[(lower.index(s[i]) + k) % lower.\n        else\n        end\n    end\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":216,"fileType":"ruby","requestStartTime":1517923365333}}
{"body": {"column":19,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.size.times do |i|\n        if ('a'..'z').include? s[i]\n            s[i] = lower[(lower.index(s[i]) + k) % lower.size]\n        elsif ('A'.)\n        end\n    end\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":241,"fileType":"ruby","requestStartTime":1517923381305}}
{"body": {"column":20,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.size.times do |i|\n        if ('a'..'z').include? s[i]\n            s[i] = lower[(lower.index(s[i]) + k) % lower.size]\n        elsif ('A'..)\n        end\n    end\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":242,"fileType":"ruby","requestStartTime":1517923381401}}
{"body": {"column":25,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef caesarCipher(s, k)\n    lower = ('a'..'z').to_a\n    upper = ('A'..'Z').to_a\n    \n    s.size.times do |i|\n        if ('a'..'z').include? s[i]\n            s[i] = lower[(lower.index(s[i]) + k) % lower.size]\n        elsif ('A'..'Z').\n        end\n    end\nend\n\nn = gets.strip.to_i\ns = gets.strip\nk = gets.strip.to_i\nresult = caesarCipher(s, k)\nputs result\n\n\n","offset":247,"fileType":"ruby","requestStartTime":1517923384069}}
{"body": {"column":7,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0.)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":49,"fileType":"ruby","requestStartTime":1517923498168}}
{"body": {"column":8,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0..)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":50,"fileType":"ruby","requestStartTime":1517923498298}}
{"body": {"column":12,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0..arr.)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":54,"fileType":"ruby","requestStartTime":1517923499466}}
{"body": {"column":9,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0...arr.size-1)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":51,"fileType":"ruby","requestStartTime":1517923502953}}
{"body": {"column":7,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0.)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":49,"fileType":"ruby","requestStartTime":1517923509809}}
{"body": {"column":8,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0..)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":50,"fileType":"ruby","requestStartTime":1517923509950}}
{"body": {"column":9,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0...)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":51,"fileType":"ruby","requestStartTime":1517923510742}}
{"body": {"column":13,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0...arr.)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":55,"fileType":"ruby","requestStartTime":1517923511366}}
{"body": {"column":21,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0...arr.size-1).\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":63,"fileType":"ruby","requestStartTime":1517923512693}}
{"body": {"column":11,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0...arr.size-1).each do |i|\n        (i.)\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":86,"fileType":"ruby","requestStartTime":1517923519998}}
{"body": {"column":12,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0...arr.size-1).each do |i|\n        (i..)\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":87,"fileType":"ruby","requestStartTime":1517923520118}}
{"body": {"column":16,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0...arr.size-1).each do |i|\n        (i..arr.)\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":91,"fileType":"ruby","requestStartTime":1517923521397}}
{"body": {"column":13,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0...arr.size-1).each do |i|\n        (i...arr.size)\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":88,"fileType":"ruby","requestStartTime":1517923526263}}
{"body": {"column":23,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef icecreamParlor(m, arr)\n    (0...arr.size-1).each do |i|\n        (i...arr.size).\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    m = gets.strip.to_i\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = icecreamParlor(m, arr)\n    print result.join(\" \")\n\n\nend\n\n\n","offset":98,"fileType":"ruby","requestStartTime":1517923529498}}
{"body": {"column":6,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\nrequire 'prime'\n\ndef primeXor(a)\n    a.\nend\n\nq = gets.strip.to_i\nfor a0 in (0..q-1)\n    n = gets.strip.to_i\n    a = gets.strip\n    a = a.split(' ').map(&:to_i)\n    result = primeXor(a)\n    puts result\nend\n\n\n","offset":53,"fileType":"ruby","requestStartTime":1517924447187}}
{"body": {"column":29,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\nrequire 'prime'\n\ndef primeXor(a)\n    result = 0\n    a.each do |p|\n        result += 1 if Prime.\n    end\nend\n\nq = gets.strip.to_i\nfor a0 in (0..q-1)\n    n = gets.strip.to_i\n    a = gets.strip\n    a = a.split(' ').map(&:to_i)\n    result = primeXor(a)\n    puts result\nend\n\n\n","offset":109,"fileType":"ruby","requestStartTime":1517924461720}}
{"body": {"column":7,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\nrequire 'prime'\n\ndef primeXor(a)\n    result = 0\n    a.each do |p|\n        result += 1 if Prime.prime? p\n    end\n    \n    (2.)\nend\n\nq = gets.strip.to_i\nfor a0 in (0..q-1)\n    n = gets.strip.to_i\n    a = gets.strip\n    a = a.split(' ').map(&:to_i)\n    result = primeXor(a)\n    puts result\nend\n\n\n","offset":138,"fileType":"ruby","requestStartTime":1517924552124}}
{"body": {"column":8,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\nrequire 'prime'\n\ndef primeXor(a)\n    result = 0\n    a.each do |p|\n        result += 1 if Prime.prime? p\n    end\n    \n    (2..)\nend\n\nq = gets.strip.to_i\nfor a0 in (0..q-1)\n    n = gets.strip.to_i\n    a = gets.strip\n    a = a.split(' ').map(&:to_i)\n    result = primeXor(a)\n    puts result\nend\n\n\n","offset":139,"fileType":"ruby","requestStartTime":1517924552246}}
{"body": {"column":10,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\nrequire 'prime'\n\ndef primeXor(a)\n    result = 0\n    a.each do |p|\n        result += 1 if Prime.prime? p\n    end\n    \n    (2..a.)\nend\n\nq = gets.strip.to_i\nfor a0 in (0..q-1)\n    n = gets.strip.to_i\n    a = gets.strip\n    a = a.split(' ').map(&:to_i)\n    result = primeXor(a)\n    puts result\nend\n\n\n","offset":141,"fileType":"ruby","requestStartTime":1517924554345}}
{"body": {"column":16,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\nrequire 'prime'\n\ndef primeXor(a)\n    result = 0\n    a.each do |p|\n        result += 1 if Prime.prime? p\n    end\n    \n    (2..a.size).\nend\n\nq = gets.strip.to_i\nfor a0 in (0..q-1)\n    n = gets.strip.to_i\n    a = gets.strip\n    a = a.split(' ').map(&:to_i)\n    result = primeXor(a)\n    puts result\nend\n\n\n","offset":147,"fileType":"ruby","requestStartTime":1517924555899}}
{"body": {"column":6,"line":6,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    a.\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":77,"fileType":"ruby","requestStartTime":1517927515751}}
{"body": {"column":23,"line":6,"wordToComplete":"m","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    a.each_with_index.m\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":94,"fileType":"ruby","requestStartTime":1517927524128}}
{"body": {"column":10,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    a.each_with_index.select do |el, i|\n        a.\n    end\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":121,"fileType":"ruby","requestStartTime":1517927632866}}
{"body": {"column":12,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    a.each_with_index.select do |el, i|\n        a[i..include?(k - el)\n    end\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":123,"fileType":"ruby","requestStartTime":1517927645282}}
{"body": {"column":13,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    a.each_with_index.select do |el, i|\n        a[i...include?(k - el)\n    end\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":124,"fileType":"ruby","requestStartTime":1517927645464}}
{"body": {"column":8,"line":8,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    a.each_with_index.select do |el, i|\n        (a[0..(i - 1)] + a[(i + 1)..-1]).include?(k - el)\n    end.\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":177,"fileType":"ruby","requestStartTime":1517927731238}}
{"body": {"column":8,"line":8,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    a.each_with_index.select do |el, i|\n        (a[0..(i - 1)] + a[(i + 1)..-1]).include?(k - el)\n    end..count\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":177,"fileType":"ruby","requestStartTime":1517927803374}}
{"body": {"column":6,"line":11,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    p = []\n    a.each_with_index do |el, i|\n        p << el if (a[0..(i - 1)] + a[(i + 1)..-1]).include?(k - el)\n    end\n    \n    p.\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":203,"fileType":"ruby","requestStartTime":1517927911954}}
{"body": {"column":30,"line":10,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    p = []\n    \n    a.each_with_index do |el, i|\n        if (a[0..(i - 1)] + a[(i + 1)..-1]).include?(k - el)\n            p << [el, k - el].\n        end\n    end\n    \n    p.count\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":211,"fileType":"ruby","requestStartTime":1517927964244}}
{"body": {"column":11,"line":14,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef numberOfPairs(a, k)\n    p = []\n    \n    a.each_with_index do |el, i|\n        if (a[0..(i - 1)] + a[(i + 1)..-1]).include?(k - el)\n            p << [el, k - el].sort\n        end\n    end\n    \n    p.uniq.\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\na_cnt = 0\na_cnt = Integer(gets)\na_i = 0\na = Array.new(a_cnt)\n\nwhile (a_i < a_cnt)\n    a_item = Integer(gets);\n    a[a_i] = (a_item)\n    a_i+=1\nend\n\nk = Integer(gets);\n\n\nres = numberOfPairs(a, k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":252,"fileType":"ruby","requestStartTime":1517927969058}}
{"body": {"column":48,"line":1,"wordToComplete":"D[^aeiou][^bcDF]\\S[^AEIOU][^.]$'","code":"\nRegex_Pattern = '^\\D[^aeiou][^bcDF]\\S[^AEIOU][^.]$'\n\n\n\nprint !!(gets =~ /#{Regex_Pattern}/)\n","offset":50,"fileType":"ruby","requestStartTime":1517934343579}}
{"body": {"column":49,"line":1,"wordToComplete":"D[^aeiou][^bcDF]\\S[^AEIOU][^\\.]$'","code":"\nRegex_Pattern = '^\\D[^aeiou][^bcDF]\\S[^AEIOU][^\\.]$'\n\n\n\nprint !!(gets =~ /#{Regex_Pattern}/)\n","offset":51,"fileType":"ruby","requestStartTime":1517934346642}}
{"body": {"column":15,"line":14,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\ndef romanize str\n    h =  {\n      1000 => \"M\",\n      500 => \"D\",\n      100 => \"C\",\n      50 => \"L\",\n      10 => \"X\",\n      5 => \"V\",\n      1 => \"I\"\n    }\n    \n    return str.\nend \n\ntimes = gets.strip.to_i\nfor a0 in (0..times-1)\n    s = gets.strip\n    result = romanize(s)\n    puts result;\nend\n\n","offset":247,"fileType":"ruby","requestStartTime":1517935362128}}
{"body": {"column":11,"line":20,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\ndef romanize str\n    h =  {\n      1000 => \"M\",\n      500 => \"D\",\n      100 => \"C\",\n      50 => \"L\",\n      10 => \"X\",\n      5 => \"V\",\n      1 => \"I\"\n    }\n    \n    str = str.upcase\n    result = 0\n    h.values.each do |roman|\n      while str[0] == roman\n        str = str.slice(1, str.length)\n        result += h.key roman\n      endh.\n    end\n    result\nend \n\ntimes = gets.strip.to_i\nfor a0 in (0..times-1)\n    s = gets.strip\n    result = romanize(s)\n    puts result;\nend\n\n","offset":405,"fileType":"ruby","requestStartTime":1517935730333}}
{"body": {"column":5,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef simpleArraySum(n, ar)\n    # Complete this function\n  ar.\nend\n\nn = gets.strip.to_i\nar = gets.strip\nar = ar.split(' ').map(&:to_i)\nresult = simpleArraySum(n, ar)\nputs result;\n\n\n","offset":75,"fileType":"ruby","requestStartTime":1517935910884}}
{"body": {"column":2,"line":9,"wordToComplete":"","code":"\n#!/bin/ruby\n\narr = Array.new(6)\nfor arr_i in (0..6-1)\n    arr_t = gets.strip\n    arr[arr_i] = arr_t.split(' ').map(&:to_i)\nend\n\n0.\n\n","offset":132,"fileType":"ruby","requestStartTime":1517937074696}}
{"body": {"column":6,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\narr = Array.new(6)\nfor arr_i in (0..6-1)\n    arr_t = gets.strip\n    arr[arr_i] = arr_t.split(' ').map(&:to_i)\nend\n\n0.upto(4) do |i|\n    0.\nend\n\n","offset":153,"fileType":"ruby","requestStartTime":1517937117527}}
{"body": {"column":7,"line":15,"wordToComplete":"","code":"\n#!/bin/ruby\n\narr = Array.new(6)\nfor arr_i in (0..6-1)\n    arr_t = gets.strip\n    arr[arr_i] = arr_t.split(' ').map(&:to_i)\nend\n\nh = []\n0.upto(4) do |i|\n    0.upto(4) do |j|\n        h << arr[i][j] + arr[i][j+1] + arr[i][j+2] + arr[i+1][j+1] + arr[i+2][j] + arr[i+2][j+1] + arr[i+2][j+2]\n    end\nend\nputs h.\n\n","offset":307,"fileType":"ruby","requestStartTime":1517937220344}}
{"body": {"column":7,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef aVeryBigSum(n, ar)\n    ar.\nend\n\nn = gets.strip.to_f\nar = gets.strip\nar = ar.split(' ').map(&:to_i)\nresult = aVeryBigSum(n, ar)\nputs result;\n\n\n","offset":45,"fileType":"ruby","requestStartTime":1517937587524}}
{"body": {"column":9,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    if a.\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":71,"fileType":"ruby","requestStartTime":1517937960908}}
{"body": {"column":25,"line":6,"wordToComplete":"e","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef countPalindromes(s)\n    s.split.permutation.e\nend\n\ndef is_pal(s)\n  s == s.reverse\nend\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ns = gets.to_s.strip;\n\n\nres = countPalindromes(s);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":96,"fileType":"ruby","requestStartTime":1517937961557}}
{"body": {"column":9,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef countPalindromes(s)\n    s.split.permutation.each {|x| puts x}\n    s(0..)\nend\n\ndef is_pal(s)\n  s == s.reverse\nend\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ns = gets.to_s.strip;\n\n\nres = countPalindromes(s);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":122,"fileType":"ruby","requestStartTime":1517938036821}}
{"body": {"column":13,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    if a.index(\"ic\") != nil\n        if(a.)\n    else\n        return \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":103,"fileType":"ruby","requestStartTime":1517938066482}}
{"body": {"column":13,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef countPalindromes(s)\n    #s.split.permutation.each {|x| puts x}\n    1.upto(s.)\nputs     s[0..(s.length)]\nputs     s[0..(s.length)]\nend\n\ndef is_pal(s)\n  s == s.reverse\nend\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ns = gets.to_s.strip;\n\n\nres = countPalindromes(s);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":127,"fileType":"ruby","requestStartTime":1517938126601}}
{"body": {"column":37,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    if a.index(\"ic\") != nil\n        return \"non-metal acid\" if a.\n    else\n        return \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":127,"fileType":"ruby","requestStartTime":1517938158794}}
{"body": {"column":19,"line":8,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef countPalindromes(s)\n    #s.split.permutation.each {|x| puts x}\n    1.upto(s.length) do |i|\n        puts s[0...i]\n    end\nend\n\ndef is_pal(s)\n  s == s.reverse\nend\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ns = gets.to_s.strip;\n\n\nres = countPalindromes(s);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":161,"fileType":"ruby","requestStartTime":1517938186029}}
{"body": {"column":10,"line":8,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef countPalindromes(s)\n    #s.split.permutation.each {|x| puts x}\n    1.upto(s.length) do |i|\n        i.\n        puts s[0...i]\n    end\nend\n\ndef is_pal(s)\n  s == s.reverse\nend\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ns = gets.to_s.strip;\n\n\nres = countPalindromes(s);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":152,"fileType":"ruby","requestStartTime":1517938207630}}
{"body": {"column":17,"line":8,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef countPalindromes(s)\n    #s.split.permutation.each {|x| puts x}\n    1.upto(s.length) do |i|\n        i.upto(s.)\n        puts s[0...i]\n    end\nend\n\ndef is_pal(s)\n  s == s.reverse\nend\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ns = gets.to_s.strip;\n\n\nres = countPalindromes(s);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":159,"fileType":"ruby","requestStartTime":1517938214349}}
{"body": {"column":26,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    if a.index(\"ic\") == a.\n        return \"non-metal acid\" if a.index(\"hydro\") != nil\n        return \"polyatomic acid\"\n    else\n        return \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":88,"fileType":"ruby","requestStartTime":1517938366352}}
{"body": {"column":14,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef countPalindromes(s)\n    #s.split.permutation.each {|x| puts x}\n    split(s).,\nend\n\ndef is_pal(s)\n  s == s.reverse\nend\n\ndef split s\n  (0..s.length).inject([]){|ai,i|\n    (1..s.length - i).inject(ai){|aj,j|\n      aj << s[i,j]\n    }\n  }\nend\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ns = gets.to_s.strip;\n\n\nres = countPalindromes(s);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":128,"fileType":"ruby","requestStartTime":1517938413489}}
{"body": {"column":20,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef countPalindromes(s)\n    #s.split.permutation.each {|x| puts x}\n    split(s).map {s.}\nend\n\ndef is_pal(s)\n  s == s.reverse\nend\n\ndef split s\n  (0..s.length).inject([]){|ai,i|\n    (1..s.length - i).inject(ai){|aj,j|\n      aj << s[i,j]\n    }\n  }\nend\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ns = gets.to_s.strip;\n\n\nres = countPalindromes(s);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":134,"fileType":"ruby","requestStartTime":1517938429577}}
{"body": {"column":11,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    puts a.\n    if a.index(\"ic\") == a.length - 2\n        return \"non-metal acid\" if a.index(\"hydro\") != nil\n        return \"polyatomic acid\"\n    else\n        return \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":73,"fileType":"ruby","requestStartTime":1517938481591}}
{"body": {"column":23,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    puts a.index(\"ic\").\n    if a.index(\"ic\") == a.length - 2\n        return \"non-metal acid\" if a.index(\"hydro\") != nil\n        return \"polyatomic acid\"\n    else\n        return \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":85,"fileType":"ruby","requestStartTime":1517938580111}}
{"body": {"column":21,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    puts \"#{a}\"\n    return \"\"\n    if a.index(\"ic\"). == a.length - 2\n        return \"non-metal acid\" if a.index(\"hydro\") != nil\n        return \"polyatomic acid\"\n    else\n        return \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":113,"fileType":"ruby","requestStartTime":1517938685561}}
{"body": {"column":14,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    puts \"#{a.}\"\n    return \"\"\n    if a.index(\"ic\").to_i == a.length - 2\n        return \"non-metal acid\" if a.index(\"hydro\") != nil\n        return \"polyatomic acid\"\n    else\n        return \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":76,"fileType":"ruby","requestStartTime":1517938721094}}
{"body": {"column":52,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    if a.index(\"ic\").to_i == a.length - 2\n        return \"non-metal acid\" if a.index(\"hydro\"). == 0\n        return \"polyatomic acid\"\n    else\n        return \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":156,"fileType":"ruby","requestStartTime":1517938901284}}
{"body": {"column":14,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(a)\n    # Complete this function\n    puts \"#{a.}\"\n    if a.index(\"ic\") == a.length - 2\n        return \"non-metal acid\" if a.index(\"hydro\").to_i == 0\n        return \"polyatomic acid\"\n    else\n        return \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":76,"fileType":"ruby","requestStartTime":1517939014203}}
{"body": {"column":11,"line":5,"wordToComplete":"","code":"\ndef iterate_colors(colors)\n  # Your code here\n    \n    arr = []\n    colors.\n    return arr\nend\n\n\n\n\n","offset":77,"fileType":"ruby","requestStartTime":1517939226908}}
{"body": {"column":25,"line":5,"wordToComplete":"","code":"\ndef iterate_colors(colors)\n  # Your code here\n    \n    arr = []\n    colors.each {|x| arr.}\n    return arr\nend\n\n\n\n\n","offset":91,"fileType":"ruby","requestStartTime":1517939236545}}
{"body": {"column":9,"line":3,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\nn = gets.\n\n","offset":82,"fileType":"ruby","requestStartTime":1517940021410}}
{"body": {"column":12,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef miniMaxSum(arr)\n    arr = a. \nend\n\narr = gets.strip\narr = arr.split(' ').map(&:to_i)\nminiMaxSum(arr)\n\n\n","offset":47,"fileType":"ruby","requestStartTime":1517940821629}}
{"body": {"column":28,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef miniMaxSum(arr)\n    arr = a.sort{|x, y| y<=>}\n    \nend\n\narr = gets.strip\narr = arr.split(' ').map(&:to_i)\nminiMaxSum(arr)\n\n\n","offset":63,"fileType":"ruby","requestStartTime":1517940911954}}
{"body": {"column":15,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef miniMaxSum(arr)\n    arr = arr.sort{|x, y| y<=>x}\n    arr = arr[0, 4]\n    return arr.\n    \nend\n\narr = gets.strip\narr = arr.split(' ').map(&:to_i)\nminiMaxSum(arr)\n\n\n","offset":103,"fileType":"ruby","requestStartTime":1517941122132}}
{"body": {"column":16,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef miniMaxSum(arr)\n    min = arr.sort\n    min_s = min.\n    arr = arr.sort{|x, y| y<=>x}\n    arr = arr[0, 4]\n    k = arr.reduce(0, :+)\n    print k\n    return k \nend\n\narr = gets.strip\narr = arr.split(' ').map(&:to_i)\nminiMaxSum(arr)\n\n\n","offset":70,"fileType":"ruby","requestStartTime":1517941199463}}
{"body": {"column":24,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef revisedRussianRoulette(doors)\n    # Complete this function\n    for (i in (0..doors.))\nend\n\nn = gets.strip.to_i\ndoors = gets.strip\ndoors = doors.split(' ').map(&:to_i)\nresult = revisedRussianRoulette(doors)\nprint result.join(\" \")\n\n\n\n\n","offset":102,"fileType":"ruby","requestStartTime":1517941505054}}
{"body": {"column":8,"line":18,"wordToComplete":"","code":"\ndef neg_pos(arr, index)\n    # return the element of the array at the position `index` from the end of the list\n    arr[-index]\nend\n\ndef first_element(arr)\n    # return the first element of the array\n    arr.first\nend\n\ndef last_element(arr)\n    # return the last element of the array\n    arr.last\nend\n\ndef first_n(arr, n)\n    # return the first n elements of the array\n    arr.\nend\n\ndef drop_n(arr, n)\n    # drop the first n elements of the array and return the rest\nend\n\n\n","offset":378,"fileType":"ruby","requestStartTime":1517942606672}}
{"body": {"column":8,"line":23,"wordToComplete":"","code":"\ndef neg_pos(arr, index)\n    # return the element of the array at the position `index` from the end of the list\n    arr[-index]\nend\n\ndef first_element(arr)\n    # return the first element of the array\n    arr.first\nend\n\ndef last_element(arr)\n    # return the last element of the array\n    arr.last\nend\n\ndef first_n(arr, n)\n    # return the first n elements of the array\n    arr.take(n)\nend\n\ndef drop_n(arr, n)\n    # drop the first n elements of the array and return the rest\n    arr.\nend\n\n\n","offset":483,"fileType":"ruby","requestStartTime":1517942615920}}
{"body": {"column":8,"line":23,"wordToComplete":"","code":"\ndef neg_pos(arr, index)\n    # return the element of the array at the position `index` from the end of the list\n    arr[-index]\nend\n\ndef first_element(arr)\n    # return the first element of the array\n    arr.first\nend\n\ndef last_element(arr)\n    # return the last element of the array\n    arr.last\nend\n\ndef first_n(arr, n)\n    # return the first n elements of the array\n    arr.take(n)\nend\n\ndef drop_n(arr, n)\n    # drop the first n elements of the array and return the rest\n    arr.\nend\n\n\n","offset":483,"fileType":"ruby","requestStartTime":1517942618311}}
{"body": {"column":6,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef diagonalDifference(a)\n    # Complete this function\n    a.\nend\n\nn = gets.strip.to_i\na = Array.new(n)\nfor a_i in (0..n-1)\n    a_t = gets.strip\n    a[a_i] = a_t.split(' ').map(&:to_i)\nend\nresult = diagonalDifference(a)\nputs result\n\n\n","offset":76,"fileType":"ruby","requestStartTime":1517946201058}}
{"body": {"column":14,"line":2,"wordToComplete":"","code":"\n    # add your code here\nreturn number.\n\n","offset":41,"fileType":"ruby","requestStartTime":1517946649738}}
{"body": {"column":9,"line":2,"wordToComplete":"","code":"\n    # write your code here\nreturn a.\n\n","offset":38,"fileType":"ruby","requestStartTime":1517948181842}}
{"body": {"column":7,"line":1,"wordToComplete":"","code":"\nnumber.\n\n","offset":9,"fileType":"ruby","requestStartTime":1517950771708}}
{"body": {"column":28,"line":1,"wordToComplete":"write your code herea.","code":"\n    # write your code herea.\n\n\n","offset":30,"fileType":"ruby","requestStartTime":1517950854553}}
{"body": {"column":2,"line":1,"wordToComplete":"","code":"\na.\n\n","offset":4,"fileType":"ruby","requestStartTime":1517950856752}}
{"body": {"column":6,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef simpleArraySum(n, ar)\n    n.\nend\n\nn = gets.strip.to_i\nar = gets.strip\nar = ar.split(' ').map(&:to_i)\nresult = simpleArraySum(n, ar)\nputs result;\n\n\n","offset":47,"fileType":"ruby","requestStartTime":1517951605862}}
{"body": {"column":18,"line":8,"wordToComplete":"","code":"\n# Read a full line of input from stdin and save it to our dynamically typed variable, input_string.\ninput_string = gets\n\n# Print a string literal saying \"Hello, World.\" to stdout.\nputs 'Hello, World.'\n\n# TODO: Write a line of code here that prints the contents of input_string to stdout.\nputs input_string.\n\n","offset":308,"fileType":"ruby","requestStartTime":1517953723583}}
{"body": {"column":19,"line":14,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\n\ndef findNumber(arr, k) \n\n\nend\n\ndef bsearch(arr, k)\n    return nil if arr.empty?\n    mid = arr.length / 2\n    left = arr[0...]\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_arr_cnt = 0\n_arr_cnt = Integer(gets)\n_arr_i=0\n_arr = Array.new(_arr_cnt)\n\nwhile (_arr_i < _arr_cnt)\n  _arr_item = Integer(gets);\n  _arr[_arr_i] = (_arr_item)\n  _arr_i+=1\nend\n\n\n_k = Integer(gets);\n\nres = findNumber(_arr, _k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":172,"fileType":"ruby","requestStartTime":1517953739148}}
{"body": {"column":23,"line":15,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\n\ndef findNumber(arr, k) \n\n\nend\n\ndef bsearch(arr, k)\n    return nil if arr.empty?\n    mid = arr.length / 2\n    left = arr[0...mid]\n    right = arr[mid+1..]\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_arr_cnt = 0\n_arr_cnt = Integer(gets)\n_arr_i=0\n_arr = Array.new(_arr_cnt)\n\nwhile (_arr_i < _arr_cnt)\n  _arr_item = Integer(gets);\n  _arr[_arr_i] = (_arr_item)\n  _arr_i+=1\nend\n\n\n_k = Integer(gets);\n\nres = findNumber(_arr, _k);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":200,"fileType":"ruby","requestStartTime":1517953747732}}
{"body": {"column":9,"line":4,"wordToComplete":"","code":"\n# Your code here\ndef count_multibyte_char(text) do\n    counter = 0\n    text.\nend\n\n","offset":78,"fileType":"ruby","requestStartTime":1517957243593}}
{"body": {"column":13,"line":5,"wordToComplete":"","code":"\n# Your code here\ndef count_multibyte_char(text) do\n    counter = 0\n    text.each_byte do |b| \n        if(b>)\n    end\nend\n\n","offset":109,"fileType":"ruby","requestStartTime":1517957281298}}
{"body": {"column":13,"line":5,"wordToComplete":"","code":"\n# Your code here\ndef count_multibyte_char(text)\n    counter = 0\n    text.each_byte do |b| \n        if b>count++ if b>1\n    end\n    \n    return count\nend\n\n","offset":106,"fileType":"ruby","requestStartTime":1517957488256}}
{"body": {"column":26,"line":5,"wordToComplete":"","code":"\n# Your code here\ndef count_multibyte_char(text)\n    counter = 0\n    text.each_char  do |b| \n        counter += 1 if b.\n        end\n    end\n    \n    return count\nend\n\n","offset":120,"fileType":"ruby","requestStartTime":1517957885583}}
{"body": {"column":35,"line":5,"wordToComplete":"","code":"\n# Your code here\ndef count_multibyte_char(text)\n    counter = 0\n    text.each_char  do |b| \n        counter += 1 if b.bytesize>\n        end\n    end\n    \n    return count\nend\n\n","offset":129,"fileType":"ruby","requestStartTime":1517957893205}}
{"body": {"column":10,"line":3,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\ndef process_text(texts)\n    texts.\nend\n\n\n","offset":106,"fileType":"ruby","requestStartTime":1517958227425}}
{"body": {"column":18,"line":3,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\ndef process_text(texts)\n    texts.each {||}\nend\n\n\n","offset":114,"fileType":"ruby","requestStartTime":1517958244059}}
{"body": {"column":29,"line":3,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\ndef process_text(texts)\n    texts.each { |text| text.}\nend\n\n\n","offset":125,"fileType":"ruby","requestStartTime":1517958262291}}
{"body": {"column":38,"line":3,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\ndef process_text(texts)\n    texts.each { |text| text.strip! }.\nend\n\n\n","offset":134,"fileType":"ruby","requestStartTime":1517958272085}}
{"body": {"column":16,"line":55,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\nclass TreeNode\n    attr_accessor :value, :left, :right\n\n    def initialize val,left,right\n        @value = val\n        @left = left\n        @right = right\n    end\nend\n\nclass BinarySearchTree\n\n    def initialize val\n        @root = TreeNode.new(val,nil,nil)   \n    end\n\n    def create_binary_search_tree(root, tree_values)\n        new_tree = BinarySearchTree.new(root)\n        @@counter = 0\n        cnt_array = [0]\n        tree_values.each do |num|\n            new_tree.insert(num)\n            cnt_array << @@counter\n        end\n        return cnt_array\n    end\n\n    def insert(value)\n        current_node = @root\n        while nil != current_node\n            @@counter = @@counter + 1\n            if (value < current_node.value) && (current_node.left == nil)\n                current_node.left = TreeNode.new(value,nil,nil)\n                return\n            elsif  (value > current_node.value) && (current_node.right == nil)\n                current_node.right = TreeNode.new(value,nil,nil)\n                return\n            elsif (value < current_node.value)\n                current_node = current_node.left\n            elsif (value > current_node.value)\n                current_node = current_node.right\n            else\n                return\n            end\n        end\n    end\nend\n    \ndef createBST(keys)\n    bst = BinarySearchTree.new(keys[1])\n    array = bst.create_binary_search_tree(keys[1],keys[2..-1])\n    print array.\nend\n\nkeys_cnt = 0\nkeys_cnt = Integer(gets)\nkeys_i = 0\nkeys = Array.new(keys_cnt)\n\nwhile (keys_i < keys_cnt)\n    keys_item = Integer(gets);\n    keys[keys_i] = (keys_item)\n    keys_i+=1\nend\n\n\nres = createBST(keys);\n\n\n","offset":1476,"fileType":"ruby","requestStartTime":1517959761266}}
{"body": {"column":32,"line":6,"wordToComplete":"","code":"\npower_function = -> (x, z) {\n    (x) ** z\n}\n\nbase = gets.to_i\nraise_to_power = power_function.\n\npower = gets.to_i\nputs raise_to_power.(power)\n\n\n","offset":96,"fileType":"ruby","requestStartTime":1517960845534}}
{"body": {"column":38,"line":6,"wordToComplete":"","code":"\npower_function = -> (x, z) {\n    (x) ** z\n}\n\nbase = gets.to_i\nraise_to_power = power_function.curry.\n\npower = gets.to_i\nputs raise_to_power.(power)\n\n\n","offset":102,"fileType":"ruby","requestStartTime":1517960849787}}
{"body": {"column":12,"line":9,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\n\ndef getMovieTitles(substr) \n  url = URI.\n\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":122,"fileType":"ruby","requestStartTime":1517960972246}}
{"body": {"column":23,"line":10,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\n\ndef getMovieTitles(substr) \n  url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n  response = Net::HTTP.\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":221,"fileType":"ruby","requestStartTime":1517961028659}}
{"body": {"column":11,"line":9,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.\ndef getMovieTitles(substr) \n  url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n  response = Net::HTTP.get_response url\n    \nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":134,"fileType":"ruby","requestStartTime":1517961060395}}
{"body": {"column":18,"line":14,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n  url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n  response = JSON.Net::HTTP.get_print url\n  puts! response, 'response'    \nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":281,"fileType":"ruby","requestStartTime":1517961192150}}
{"body": {"column":17,"line":15,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n  url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n  response = Net::HTTP.get_response url\n  puts! response., 'response'    \n    \n    return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":320,"fileType":"ruby","requestStartTime":1517961309859}}
{"body": {"column":18,"line":15,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n  url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n  response = Net::HTTP.get_response url\n  response = JSON.\n  puts! response.body, 'response'    \n    \n    return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":321,"fileType":"ruby","requestStartTime":1517961327252}}
{"body": {"column":33,"line":15,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n  url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n  response = Net::HTTP.get_response url\n  response = JSON.parse response.\n  puts! response.body, 'response'    \n    \n    return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":336,"fileType":"ruby","requestStartTime":1517961331641}}
{"body": {"column":4,"line":17,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n  url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n  response = Net::HTTP.get_response url\n  response = JSON.parse response.body\n  puts! response, 'response'    \n  (.)\n  return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":378,"fileType":"ruby","requestStartTime":1517961350823}}
{"body": {"column":5,"line":17,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n  url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n  response = Net::HTTP.get_response url\n  response = JSON.parse response.body\n  puts! response, 'response'    \n  (0.)\n  return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":379,"fileType":"ruby","requestStartTime":1517961351835}}
{"body": {"column":6,"line":17,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n  url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n  response = Net::HTTP.get_response url\n  response = JSON.parse response.body\n  puts! response, 'response'    \n  (0..)\n  return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":380,"fileType":"ruby","requestStartTime":1517961351960}}
{"body": {"column":16,"line":17,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    response = Net::HTTP.get_response url\n    response = JSON.parse response.body\n    puts! response, 'response'\n    if response.\n    (0..)\n    return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":394,"fileType":"ruby","requestStartTime":1517961387771}}
{"body": {"column":35,"line":18,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    response = Net::HTTP.get_response url\n    response = JSON.parse response.body\n    puts! response, 'response'\n    if response['total_pages'] > 1\n      (2..response['total_pages']).\n        \n    end\n    return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":448,"fileType":"ruby","requestStartTime":1517961424610}}
{"body": {"column":23,"line":19,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n    titles = []\n    \n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    response = Net::HTTP.get_response url\n    response = JSON.parse response.body\n    # puts! response, 'response'\n    titles += response.\n    if response['total_pages'] > 1\n      (2..response['total_pages']).each do |page|\n          url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}&page=#{page}\")\n          \n      end\n    end\n    return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":424,"fileType":"ruby","requestStartTime":1517961521549}}
{"body": {"column":31,"line":19,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n    titles = []\n    \n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    response = Net::HTTP.get_response url\n    response = JSON.parse response.body\n    # puts! response, 'response'\n    titles += response['data'].\n    if response['total_pages'] > 1\n      (2..response['total_pages']).each do |page|\n          url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}&page=#{page}\")\n          \n      end\n    end\n    return []\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":432,"fileType":"ruby","requestStartTime":1517961523626}}
{"body": {"column":20,"line":16,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n    titles = []\n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    response = Net::HTTP.get_response url\n    response = JSON.\n    titles += response['data'].map { |d| d['Title'] }\n    if response['total_pages'] > 1\n      (2..response['total_pages']).each do |page|\n          url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}&page=#{page}\")\n          response = Net::HTTP.get_response url\n          response = JSON.parse response.body\n          titles += response['data'].map { |d| d['Title'] }\n      end\n    end\n    return titles\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":343,"fileType":"ruby","requestStartTime":1517961571474}}
{"body": {"column":20,"line":15,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n    titles = []\n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    response = JSON.Net::HTTP.get_response url\n    response = JSON.parse res\n    titles += response['data'].map { |d| d['Title'] }\n    if response['total_pages'] > 1\n      (2..response['total_pages']).each do |page|\n          url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}&page=#{page}\")\n          response = Net::HTTP.get_response url\n          response = JSON.parse response.body\n          titles += response['data'].map { |d| d['Title'] }\n      end\n    end\n    return titles\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":301,"fileType":"ruby","requestStartTime":1517961579625}}
{"body": {"column":57,"line":15,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n    titles = []\n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    response = JSON.parse( Net::HTTP.get_response( url ).\n    response = JSON.parse res\n    titles += response['data'].map { |d| d['Title'] }\n    if response['total_pages'] > 1\n      (2..response['total_pages']).each do |page|\n          url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}&page=#{page}\")\n          response = Net::HTTP.get_response url\n          response = JSON.parse response.body\n          titles += response['data'].map { |d| d['Title'] }\n      end\n    end\n    return titles\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":338,"fileType":"ruby","requestStartTime":1517961585344}}
{"body": {"column":18,"line":24,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef getMovieTitles(substr) \n    titles = []\n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    response = JSON.parse( Net::HTTP.get_response( url ).body )\n    titles += response['data'].map { |d| d['Title'] }\n    if response['total_pages'] > 1\n      (2..response['total_pages']).each do |page|\n          url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}&page=#{page}\")\n          response = JSON.parse( Net::HTTP.get_response( url ).body )\n          titles += response['data'].map { |d| d['Title'] }\n      end\n    end\n    return titles.\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":759,"fileType":"ruby","requestStartTime":1517961603875}}
{"body": {"column":9,"line":12,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ne = Proc. |x, page|\n    page ||= 1\n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{x}&page=#{page}\")\n    response = JSON.parse( Net::HTTP.get_response( url ).body )\nend\n\ndef getMovieTitles(substr)\n    titles = []\n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    response = JSON.parse( Net::HTTP.get_response( url ).body )\n    titles += response['data'].map { |d| d['Title'] }\n    if response['total_pages'] > 1\n      (2..response['total_pages']).each do |page|\n          url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}&page=#{page}\")\n          response = JSON.parse( Net::HTTP.get_response( url ).body )\n          titles += response['data'].map { |d| d['Title'] }\n      end\n    end\n    return titles.sort\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":156,"fileType":"ruby","requestStartTime":1517961733790}}
{"body": {"column":16,"line":23,"wordToComplete":"","code":"#!/bin/ruby\n\nrequire 'net/http'\nrequire 'json'\n\n# Complete the function below.\n\ndef puts! a, b=''\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ne = Proc.new do |x, page|\n    page ||= 1\n    url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{x}&page=#{page}\")\n    return JSON.parse( Net::HTTP.get_response( url ).body )\nend\n\ndef getMovieTitles(substr)\n    titles = []\n    # url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}\")\n    # response = JSON.parse( Net::HTTP.get_response( url ).body )\n    # titles += response['data'].map { |d| d['Title'] }\n    titles += e.\n    if response['total_pages'] > 1\n      (2..response['total_pages']).each do |page|\n          url = URI.parse(\"https://jsonmock.hackerrank.com/api/movies/search/?Title=#{substr}&page=#{page}\")\n          response = JSON.parse( Net::HTTP.get_response( url ).body )\n          titles += response['data'].map { |d| d['Title'] }\n      end\n    end\n    return titles.sort\nend\n\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n    \n\n_substr = gets.to_s.strip;\n\nres = getMovieTitles(_substr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":624,"fileType":"ruby","requestStartTime":1517961759856}}
{"body": {"column":11,"line":7,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef puts! a, b=\"\"\n    puts \"+++ +++ #{b}\"\n    puts a.\ndef waitingTime(tickets, p)\n\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ntickets_cnt = 0\ntickets_cnt = Integer(gets)\ntickets_i = 0\ntickets = Array.new(tickets_cnt)\n\nwhile (tickets_i < tickets_cnt)\n    tickets_item = Integer(gets);\n    tickets[tickets_i] = (tickets_item)\n    tickets_i+=1\nend\n\np = Integer(gets);\n\n\nres = waitingTime(tickets, p);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":100,"fileType":"ruby","requestStartTime":1517962040842}}
{"body": {"column":28,"line":14,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef puts! a, b=\"\"\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef waitingTime(tickets, p)\n    count = 0\n    idx = 0\n    while tickets[p] > 0\n        if idx+1 == tickets.\n        if tickets[idx] == 0\n            \n            idx += 1\n        else\n            t\n    end\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ntickets_cnt = 0\ntickets_cnt = Integer(gets)\ntickets_i = 0\ntickets = Array.new(tickets_cnt)\n\nwhile (tickets_i < tickets_cnt)\n    tickets_item = Integer(gets);\n    tickets[tickets_i] = (tickets_item)\n    tickets_i+=1\nend\n\np = Integer(gets);\n\n\nres = waitingTime(tickets, p);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":220,"fileType":"ruby","requestStartTime":1517962123956}}
{"body": {"column":7,"line":2,"wordToComplete":"","code":"\n    # add your code here\nnumber.\n\n","offset":34,"fileType":"ruby","requestStartTime":1517962460984}}
{"body": {"column":39,"line":3,"wordToComplete":"","code":"\n# Your code here\ndef serial_average(num)\n    parts = /(?<a>[0-9]{3})-(?<b>[0-9\\.])\n\n","offset":82,"fileType":"ruby","requestStartTime":1517962462164}}
{"body": {"column":46,"line":3,"wordToComplete":"","code":"\n# Your code here\ndef serial_average(num)\n    parts = /(?<a>[0-9]{3})-(?<b>[0-9\\.]{4})\\.\n\n","offset":89,"fileType":"ruby","requestStartTime":1517962473976}}
{"body": {"column":57,"line":3,"wordToComplete":"","code":"\n# Your code here\ndef serial_average(num)\n    parts = /(?<a>[0-9]{3})-(?<b>[0-9\\.]{4})\\.(?<c>[0-9\\.])\n\n","offset":100,"fileType":"ruby","requestStartTime":1517962481488}}
{"body": {"column":20,"line":4,"wordToComplete":"","code":"\n# Your code here\ndef serial_average(num)\n    parts = /(?<a>[0-9]{3})-(?<b>[0-9]{2}.[0-9]{2})-(?<c>[0-9]{2}.[0-9]{2})/\n    avg = parts[:b].\n    \"#{parts[:a]}-\"\n\n","offset":140,"fileType":"ruby","requestStartTime":1517962829167}}
{"body": {"column":37,"line":4,"wordToComplete":"","code":"\n# Your code here\ndef serial_average(num)\n    parts = /(?<a>[0-9]{3})-(?<b>[0-9]{2}.[0-9]{2})-(?<c>[0-9]{2}.[0-9]{2})/\n    avg = parts[:b].to_f + parts[:c].\n    \"#{parts[:a]}-\"\n\n","offset":157,"fileType":"ruby","requestStartTime":1517962837105}}
{"body": {"column":48,"line":4,"wordToComplete":"","code":"\n# Your code here\ndef serial_average(num)\n    parts = /(?<a>[0-9]{3})-(?<b>[0-9]{2}.[0-9]{2})-(?<c>[0-9]{2}.[0-9]{2})/\n    avg = (parts[:b].to_f + parts[:c].to_f) * 0.\n    \"#{parts[:a]}-\"\n\n","offset":168,"fileType":"ruby","requestStartTime":1517962846843}}
{"body": {"column":24,"line":5,"wordToComplete":"","code":"\n# Your code here\ndef serial_average(num)\n    parts = /(?<a>[0-9]{3})-(?<b>[0-9]{2}.[0-9]{2})-(?<c>[0-9]{2}.[0-9]{2})/\n    avg = (parts[:b].to_f + parts[:c].to_f) * 0.5\n    \"#{parts[:a]}-#{avg.}\"\n\n","offset":194,"fileType":"ruby","requestStartTime":1517962853255}}
{"body": {"column":77,"line":3,"wordToComplete":"","code":"\n# Your code here\ndef serial_average(num)\n    parts = /(?<a>[0-9]{3})-(?<b>[0-9]{2}.[0-9]{2})-(?<c>[0-9]{2}.[0-9]{2})/.\n    avg = (parts[:b].to_f + parts[:c].to_f) * 0.5\n    \"#{parts[:a]}-#{avg.round(2)}\"\nend\n\n","offset":120,"fileType":"ruby","requestStartTime":1517962952499}}
{"body": {"column":12,"line":26,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef puts! a, b=\"\"\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef w1 tickets, p\n    count = 0\n    idx = 0\n    while tickets[p] > 0\n        if tickets[idx] <= 0\n            ;\n        else\n            count += 1\n            tickets[idx] = tickets[idx] - 1\n        end\n        idx = idx+1 == tickets.length ? 0 : idx+1\n    end\n    return count\nend\n\ndef w2 tickets, p\n    tickets.\nend\n\ndef waitingTime(tickets, p)\n    w2( tickets, p )\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ntickets_cnt = 0\ntickets_cnt = Integer(gets)\ntickets_i = 0\ntickets = Array.new(tickets_cnt)\n\nwhile (tickets_i < tickets_cnt)\n    tickets_item = Integer(gets);\n    tickets[tickets_i] = (tickets_item)\n    tickets_i+=1\nend\n\np = Integer(gets);\n\n\nres = waitingTime(tickets, p);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":427,"fileType":"ruby","requestStartTime":1517963002405}}
{"body": {"column":19,"line":33,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef puts! a, b=\"\"\n    puts \"+++ +++ #{b}\"\n    puts a.inspect\nend\n\ndef w1 tickets, p\n    count = 0\n    idx = 0\n    while tickets[p] > 0\n        if tickets[idx] <= 0\n            ;\n        else\n            count += 1\n            tickets[idx] = tickets[idx] - 1\n        end\n        idx = idx+1 == tickets.length ? 0 : idx+1\n    end\n    return count\nend\n\ndef w2 tickets, p\n    tickets.each_with_index do |t, idx|\n        if idx < p\n            tickets[idx] = t > p ? p : t\n        elsif idx > p\n            tickets[idx] = t > p-1 ? p-1 : t\n        end\n    end\n    return tickers.\nend\n\ndef waitingTime(tickets, p)\n    w2( tickets, p )\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ntickets_cnt = 0\ntickets_cnt = Integer(gets)\ntickets_i = 0\ntickets = Array.new(tickets_cnt)\n\nwhile (tickets_i < tickets_cnt)\n    tickets_item = Integer(gets);\n    tickets[tickets_i] = (tickets_item)\n    tickets_i+=1\nend\n\np = Integer(gets);\n\n\nres = waitingTime(tickets, p);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":621,"fileType":"ruby","requestStartTime":1517963106046}}
{"body": {"column":18,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(acid_name)\n    result = \"not an acid\"\n    if (acid_name.)\n    # Complete this function\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":86,"fileType":"ruby","requestStartTime":1517963800050}}
{"body": {"column":17,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(acid_name)\n    result = \"not an acid\"\n    if acid_name.\n    # Complete this function\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":85,"fileType":"ruby","requestStartTime":1517963826062}}
{"body": {"column":21,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(acid_name)\n    result = \"not an acid\"\n    if acid_name.end_with?(\"ic\")\n        result = \"polyatomic acid\"\n        if acid_name.\n    # Complete this function\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":157,"fileType":"ruby","requestStartTime":1517963851077}}
{"body": {"column":18,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(acid_name)\n    result = \"not an acid\"\n    if acid_name.end_with?(\"ic\")\n        acid_name.\n        result = \"polyatomic acid\"\n        if acid_name.begin_with?(\"hydro\")\n            result = \"non-metal acid\"\n        end\n    else\n        result = \"not an acid\"\n    end\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":119,"fileType":"ruby","requestStartTime":1517963907093}}
{"body": {"column":30,"line":7,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\nm = nil\nintegers = nil\nARGF.each_within_index do |arg, i|\n    m = arg.to_i if i == 0\n    integers = arg.split(\" \").\nend\n\nputs \"#{args[0]}: #{args[0].class}\"\nputs \"#{args[1]}: #{args[1].class}\"\n\n\n\n","offset":188,"fileType":"ruby","requestStartTime":1517964645496}}
{"body": {"column":11,"line":8,"wordToComplete":"e","code":"\n#!/bin/ruby\n\ndef revisedRussianRoulette(doors)\n    min = 0\n    max = 0\n    incremented_min_last_iteration = false\n    \n    doors.e\n    # Complete this function\nend\n\nn = gets.strip.to_i\ndoors = gets.strip\ndoors = doors.split(' ').map(&:to_i)\nresult = revisedRussianRoulette(doors)\nprint result.join(\" \")\n\n\n\n\n","offset":132,"fileType":"ruby","requestStartTime":1517964835873}}
{"body": {"column":10,"line":25,"wordToComplete":"e","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\nm = nil\nintegers = nil\nARGF.each_within_index do |arg, i|\n    m = arg.to_i if i == 0\n    integers = arg.split(\" \").map{ |string| string.to_i } if i == 1\nend\n\nclass node\n    def initialize(value, next_node)\n        @value = value\n        @next_node = next_node\n    end\n    \n    def next\n        @next_node\n    end\n    \n    def value\n        @value\n    end\nend\n\nintegers.e\n\n\n\n","offset":443,"fileType":"ruby","requestStartTime":1517964870731}}
{"body": {"column":21,"line":26,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\nm = nil\nintegers = nil\nARGF.each_within_index do |arg, i|\n    m = arg.to_i if i == 0\n    integers = arg.split(\" \").map{ |string| string.to_i } if i == 1\nend\n\nclass node\n    def initialize(value, next_node)\n        @value = value\n        @next_node = next_node\n    end\n    \n    def next\n        @next_node\n    end\n    \n    def value\n        @value\n    end\nend\n\nintegers.each_with_index do |int, i|\n    if i == integers.\n    if i == 0\n    \nend\n\n\n\n","offset":491,"fileType":"ruby","requestStartTime":1517964960186}}
{"body": {"column":38,"line":33,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\nm = nil\nintegers = nil\nARGF.each_within_index do |arg, i|\n    m = arg.to_i if i == 0\n    integers = arg.split(\" \").map{ |string| string.to_i } if i == 1\nend\n\nclass Node\n    def initialize(value, next_node)\n        @value = value\n        @next_node = next_node\n    end\n    \n    def next\n        @next_node\n    end\n    \n    def next=(next_node)\n        @next_node = next_node\n    end\n    \n    def value\n        @value\n    end\n    \n    def value=(value)\n        @value = value\n    end\nend\n\nlast_node_created = Node.new(integers.)\n\n\n\n\n","offset":598,"fileType":"ruby","requestStartTime":1517965303371}}
{"body": {"column":3,"line":35,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\nm = nil\nintegers = nil\nARGF.each_within_index do |arg, i|\n    m = arg.to_i if i == 0\n    integers = arg.split(\" \").map{ |string| string.to_i } if i == 1\nend\n\nclass Node\n    def initialize(value, next_node)\n        @value = value\n        @next_node = next_node\n    end\n    \n    def next\n        @next_node\n    end\n    \n    def next=(next_node)\n        @next_node = next_node\n    end\n    \n    def value\n        @value\n    end\n    \n    def value=(value)\n        @value = value\n    end\nend\n\nlast_node_created = Node.new(integers.first)\n\n(1.)\n\n\n\n\n","offset":609,"fileType":"ruby","requestStartTime":1517965324778}}
{"body": {"column":21,"line":36,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\nm = nil\nintegers = nil\nARGF.each_within_index do |arg, i|\n    m = arg.to_i if i == 0\n    integers = arg.split(\" \").map{ |string| string.to_i } if i == 1\nend\n\nclass Node\n    def initialize(value, next_node)\n        @value = value\n        @next_node = next_node\n    end\n    \n    def next\n        @next_node\n    end\n    \n    def next=(next_node)\n        @next_node = next_node\n    end\n    \n    def value\n        @value\n    end\n    \n    def value=(value)\n        @value = value\n    end\nend\n\nlast_node_created = Node.new(integers.first)\n\n(1..(integers.length - 1)).each do |i|\n    next_node = Node.\n    last_node_created.next = \nend\n\n\n\n\n","offset":666,"fileType":"ruby","requestStartTime":1517965364450}}
{"body": {"column":40,"line":64,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\n\n# Collect input arguments\nm = nil\nintegers = nil\nARGF.each_with_index do |arg, i|\n    m = arg.to_i if i == 0\n    integers = arg.split(\" \").map{ |string| string.to_i } if i == 1\nend\n\n# Create Node class\nclass Node\n    def initialize(value=nil, prev_node=nil, next_node=nil)\n        @value = value\n        @prev_node = prev_node\n        @next_node = next_node\n    end\n    \n    def next\n        @next_node\n    end\n    \n    def next=(next_node)\n        @next_node = next_node\n    end\n    \n    def previous\n        @prev_node\n    end\n    \n    def previous=(prev_node)\n        @prev_node = prev_node\n    end\n    \n    def value\n        @value\n    end\n    \n    def value=(value)\n        @value = value\n    end\nend\n\n# Create the root node\nroot_node = last_node_created = Node.new(integers.first)\n\n# Create all the rest of the nodes (i.e. create the linked list)\n(1..(integers.length - 1)).each do |i|\n    value = integers[i]\n    next_node = Node.new(value, last_node_created)\n    last_node_created.next = next_node\n    last_node_created = next_node\nend\n\n# Find the last node\nlast_node = root_node\nuntil last_node.next.nil?\n    last_node = last_node.next\nend\n\n# Now find the answer\nmth_to_last_node = last_node\n(m - 1).times do\n    return puts nil if mth_to_last_node.\n    mth_to_last_node = mth_to_last_node.previous\nend\n\n# Print final answer\nputs mth_to_last_node.value\n    \n\n\n\n\n","offset":1331,"fileType":"ruby","requestStartTime":1517966881132}}
{"body": {"column":19,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef acidNaming(acid_name)\n    # Complete this function\n    if acid_name[0.4]==\"hydro\" and acid_name[-2]\nend\n\nn = gets.strip.to_i\nfor a0 in (0..n-1)\n    acid_name = gets.strip\n    result = acidNaming(acid_name)\n    puts result\nend\n\n\n","offset":89,"fileType":"ruby","requestStartTime":1517974766497}}
{"body": {"column":7,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef aVeryBigSum(n, ar)\n    # Complete this function\n    ar.\nend\n\nn = gets.strip.to_i\nar = gets.strip\nar = ar.split(' ').map(&:to_i)\nresult = aVeryBigSum(n, ar)\nputs result;\n\n\n","offset":74,"fileType":"ruby","requestStartTime":1517974824574}}
{"body": {"column":36,"line":38,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    #return 1 or 0 depending on whether the element is present in the tree or not\n    if root.value == val\n        return 1\n    elsif root.left == null && root.\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\n_b = Integer(gets)\n_result = isPresent(_a, _b)\nprint _result\n","offset":998,"fileType":"ruby","requestStartTime":1517975247482}}
{"body": {"column":36,"line":38,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    #return 1 or 0 depending on whether the element is present in the tree or not\n    if root.value == val\n        return 1\n    elsif root.left == null && root.\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\n_b = Integer(gets)\n_result = isPresent(_a, _b)\nprint _result\n","offset":998,"fileType":"ruby","requestStartTime":1517975247482}}
{"body": {"column":15,"line":40,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    #return 1 or 0 depending on whether the element is present in the tree or not\n    if root.value == val\n        return 1\n    elsif root.value == null\n        return 0\n    elsif root.\n        isPresent(root.left, )\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\n_b = Integer(gets)\n_result = isPresent(_a, _b)\nprint _result\n","offset":1023,"fileType":"ruby","requestStartTime":1517975451001}}
{"body": {"column":7,"line":1,"wordToComplete":"","code":"\nnumber.\n\n","offset":9,"fileType":"ruby","requestStartTime":1517975860959}}
{"body": {"column":2,"line":1,"wordToComplete":"","code":"\na.\n\n","offset":4,"fileType":"ruby","requestStartTime":1517975940446}}
{"body": {"column":17,"line":6,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    print 5 ** 0.\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":93,"fileType":"ruby","requestStartTime":1517975961904}}
{"body": {"column":13,"line":2,"wordToComplete":"","code":"\nloop do \n    if coder.\n\n","offset":24,"fileType":"ruby","requestStartTime":1517976005103}}
{"body": {"column":10,"line":6,"wordToComplete":"","code":"\nloop do \n    if coder.oh_one?\n        break\n    end\n    \n    coder.\n\n","offset":69,"fileType":"ruby","requestStartTime":1517976014672}}
{"body": {"column":6,"line":1,"wordToComplete":"","code":"\ncoder.\n\n","offset":8,"fileType":"ruby","requestStartTime":1517976069519}}
{"body": {"column":17,"line":6,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    print 5 ** 0.\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":93,"fileType":"ruby","requestStartTime":1517975961904}}
{"body": {"column":27,"line":1,"wordToComplete":"","code":"\ncoder.practice until coder.\n\n","offset":29,"fileType":"ruby","requestStartTime":1517976085727}}
{"body": {"column":16,"line":10,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    print (4 ** 0.5).floor == (4 ** 0.5)\nend\n\ndef getNumSquares(str)\n    split = str.\nend\n\ndef isSquare?(n)\n    (n ** 0.5) == (n ** 0.5).floor\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":161,"fileType":"ruby","requestStartTime":1517976151094}}
{"body": {"column":26,"line":10,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    print 5 ** 0.5\nend\n\ndef isSquare?(n)\n    (n ** 0.5) == (n ** 0.)\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":143,"fileType":"ruby","requestStartTime":1517976043079}}
{"body": {"column":21,"line":6,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    print (5 ** 0.5).\nend\n\ndef isSquare?(n)\n    (n ** 0.5) == (n ** 0.5).floor\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":97,"fileType":"ruby","requestStartTime":1517976057359}}
{"body": {"column":16,"line":11,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    print (4 ** 0.5).floor == (4 ** 0.5)\nend\n\ndef getNumSquares(str)\n    split = str.split\n    min = split.\nend\n\ndef isSquare?(n)\n    (n ** 0.5) == (n ** 0.5).floor\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":183,"fileType":"ruby","requestStartTime":1517976215911}}
{"body": {"column":10,"line":13,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    print (4 ** 0.5).floor == (4 ** 0.5)\nend\n\ndef getNumSquares(str)\n    split = str.split\n    min = split.first\n    max = split.last\n    (min..)\nend\n\ndef isSquare?(n)\n    (n ** 0.5) == (n ** 0.5).floor\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":220,"fileType":"ruby","requestStartTime":1517976223678}}
{"body": {"column":9,"line":2,"wordToComplete":"","code":"\ndef iter_hash(hash)\n    hash.\nend\n\n\n","offset":31,"fileType":"ruby","requestStartTime":1517976294768}}
{"body": {"column":22,"line":10,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    arr.map { |str| getNumSquares(str) }\nend\n\ndef getNumSquares(str)\n    split = str.split.\n    min = split.first.to_\n    max = split.last\n    count = 0\n    (min..max).each do |chr|\n        count += 1 if isSquare?(int.)\n    end\n    \n    count\nend\n\ndef isSquare?(n)\n    (n ** 0.5) == (n ** 0.5).floor\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":167,"fileType":"ruby","requestStartTime":1517976326741}}
{"body": {"column":16,"line":10,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    print (4 ** 0.5).floor == (4 ** 0.5)\nend\n\ndef getNumSquares(str)\n    split = str.\nend\n\ndef isSquare?(n)\n    (n ** 0.5) == (n ** 0.5).floor\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":161,"fileType":"ruby","requestStartTime":1517976151094}}
{"body": {"column":16,"line":11,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    print (4 ** 0.5).floor == (4 ** 0.5)\nend\n\ndef getNumSquares(str)\n    split = str.split\n    min = split.\nend\n\ndef isSquare?(n)\n    (n ** 0.5) == (n ** 0.5).floor\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":183,"fileType":"ruby","requestStartTime":1517976215911}}
{"body": {"column":30,"line":2,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\nprint $stdin.read.split('\\n').\n\n","offset":102,"fileType":"ruby","requestStartTime":1517976985919}}
{"body": {"column":41,"line":2,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\np $stdin.read.split(\"\\n\").drop(1).select.\n\nALPHABET = (\"a\"..\"z\").to_a\n\ndef convert_input()\n    \nend\n\ndef convert_output(input_arr)\n\ndef convertStr(str)\n    counts = Hash.new(0)\n    shifted_str = \"\"\n    str.each_char do |chr|\n        shifted_str += shift(chr, counts[chr])\n        counts[chr] += 1\n    end\n    \n    shifted_str\nend\n\ndef shift(chr, n)\n    \nend\n\n","offset":113,"fileType":"ruby","requestStartTime":1517977516300}}
{"body": {"column":14,"line":9,"wordToComplete":"","code":"\n# Enter your code here. Read input from STDIN. Print output to STDOUT\nALPHABET = (\"a\"..\"z\").to_a\n\ndef read_input\n    $stdin.read.split(\"\\n\").drop(1).select.with_index { |el, idx| idx.odd? }\nend\n\ndef convert_to_output(input_arr)\n    input_arr.\nend\n\ndef convertStr(str)\n    counts = Hash.new(0)\n    shifted_str = \"\"\n    str.each_char do |chr|\n        shifted_str += shift(chr, counts[chr])\n        counts[chr] += 1\n    end\n    \n    shifted_str\nend\n\ndef shift(chr, n)\n    \nend\n\n","offset":244,"fileType":"ruby","requestStartTime":1517977652319}}
{"body": {"column":8,"line":10,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef doesCircleExist(commands)\n    commands.map { |command| singleCommand(command) }\nend\n\ndef singleCommand(command)\n    (0..)\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ncommands_cnt = 0\ncommands_cnt = Integer(gets)\ncommands_i = 0\ncommands = Array.new(commands_cnt)\n\nwhile (commands_i < commands_cnt)\n    commands_item = gets.to_s.strip;\n    commands[commands_i] = (commands_item)\n    commands_i+=1\nend\n\n\nres = doesCircleExist(commands);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":171,"fileType":"ruby","requestStartTime":1517978437417}}
{"body": {"column":12,"line":10,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef doesCircleExist(commands)\n    commands.map { |command| singleCommand(command) }\nend\n\ndef singleCommand(command)\n    command.    \nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ncommands_cnt = 0\ncommands_cnt = Integer(gets)\ncommands_i = 0\ncommands = Array.new(commands_cnt)\n\nwhile (commands_i < commands_cnt)\n    commands_item = gets.to_s.strip;\n    commands[commands_i] = (commands_item)\n    commands_i+=1\nend\n\n\nres = doesCircleExist(commands);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":175,"fileType":"ruby","requestStartTime":1517978666340}}
{"body": {"column":10,"line":11,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef doesCircleExist(commands)\n    commands.map { |command| singleCommand(command) }\nend\n\ndef singleCommand(command)\n    count = command.chars.reject { |c| c == \"G\" }.length \n    count.\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\ncommands_cnt = 0\ncommands_cnt = Integer(gets)\ncommands_i = 0\ncommands = Array.new(commands_cnt)\n\nwhile (commands_i < commands_cnt)\n    commands_item = gets.to_s.strip;\n    commands[commands_i] = (commands_item)\n    commands_i+=1\nend\n\n\nres = doesCircleExist(commands);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":231,"fileType":"ruby","requestStartTime":1517978750078}}
{"body": {"column":14,"line":21,"wordToComplete":"","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef getMinimumUniqueSum(arr)\n    arr.map { |str| getNumSquares(str) }\nend\n\ndef getNumSquares(str)\n    split = str.split.map(&:to_i)\n    count = 0\n    (split.first..split.last).each do |int|\n        count += 1 if isSquare?(int)\n    end\n    \n    count\nend\n\ndef getSquaresInRange(str)\n    split = str.split.map(&:to_i)\n    a = split.\nend\n\ndef isSquare?(n)\n    (n ** 0.5) == (n ** 0.5).floor\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\narr_cnt = 0\narr_cnt = Integer(gets)\narr_i = 0\narr = Array.new(arr_cnt)\n\nwhile (arr_i < arr_cnt)\n    arr_item = gets.to_s.strip;\n    arr[arr_i] = (arr_item)\n    arr_i+=1\nend\n\n\nres = getMinimumUniqueSum(arr);\nfor res_i in res do\n  fp.write res_i\n  fp.write \"\\n\"\nend\n\nfp.close()\n\n","offset":377,"fileType":"ruby","requestStartTime":1517979162033}}
{"body": {"column":73,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef minimumAbsoluteDifference(n, arr)\n    # Complete this function\n    sorted_arr = arr.sort\n    combin = []\n    (n-1).times{ |counter| sorted_arr[counter] - sorted_arr[counter+1] }.\n    combin.map{ |a, b| (b - a).abs }.min\nend\n\nn = gets.strip.to_i\narr = gets.strip\narr = arr.split(' ').map(&:to_i)\nresult = minimumAbsoluteDifference(n, arr)\nputs result\n\n\n","offset":197,"fileType":"ruby","requestStartTime":1517980219134}}
{"body": {"column":7,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef minimumAbsoluteDifference(n, arr)\n    # Complete this function\n    sorted_arr = arr.sort\n    combin = []\n    (0.n-1).map{ |counter| sorted_arr[counter] - sorted_arr[counter+1] }.min\nend\n\nn = gets.strip.to_i\narr = gets.strip\narr = arr.split(' ').map(&:to_i)\nresult = minimumAbsoluteDifference(n, arr)\nputs result\n\n\n","offset":131,"fileType":"ruby","requestStartTime":1517980243389}}
{"body": {"column":8,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef minimumAbsoluteDifference(n, arr)\n    # Complete this function\n    sorted_arr = arr.sort\n    combin = []\n    (0..n-1).map{ |counter| sorted_arr[counter] - sorted_arr[counter+1] }.min\nend\n\nn = gets.strip.to_i\narr = gets.strip\narr = arr.split(' ').map(&:to_i)\nresult = minimumAbsoluteDifference(n, arr)\nputs result\n\n\n","offset":132,"fileType":"ruby","requestStartTime":1517980243547}}
{"body": {"column":9,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef minimumAbsoluteDifference(n, arr)\n    # Complete this function\n    sorted_arr = arr.sort\n    (0...n-2).map do |c|\n       sorted_arr[c+1] - sorted_arr[c]\n    end.min\nend\n\nn = gets.strip.to_i\narr = gets.strip\narr = arr.split(' ').map(&:to_i)\nresult = minimumAbsoluteDifference(n, arr)\nputs result\n\n\n","offset":117,"fileType":"ruby","requestStartTime":1517980380849}}
{"body": {"column":6,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    n.\nend\n\n\n","offset":84,"fileType":"ruby","requestStartTime":1517985106436}}
{"body": {"column":18,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    n.step(0, -1).\nend\n\n\n","offset":96,"fileType":"ruby","requestStartTime":1517985112402}}
{"body": {"column":9,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    (n-1.).each do |num|\n        \n    end\nend\n\n\n","offset":87,"fileType":"ruby","requestStartTime":1517985202238}}
{"body": {"column":10,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    (n-1..).each do |num|\n        \n    end\nend\n\n\n","offset":88,"fileType":"ruby","requestStartTime":1517985202392}}
{"body": {"column":15,"line":8,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    target = (n-1..1).find do |num| \n        p num\n        n%num >\n    end\n    p target\n    target ? target : n\nend\n\n\n","offset":144,"fileType":"ruby","requestStartTime":1517985298166}}
{"body": {"column":27,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    target = (n-1..1).to_a.find do |num| \n        p num\n        p n%num\n        n%num > 1\n    end\n    p target\n    target ? target : n\nend\n\n\n","offset":105,"fileType":"ruby","requestStartTime":1517985410958}}
{"body": {"column":15,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    p (n-1..1).\n    target = (n-1..1).to_a.find do |num| \n        p num\n        p n%num\n        n%num > 1\n    end\n    p target\n    target ? target : n\nend\n\n\n","offset":93,"fileType":"ruby","requestStartTime":1517985471264}}
{"body": {"column":20,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    p (n-1..1).to_a.\n    target = (n-1..1).to_a.find do |num| \n        p num\n        p n%num\n        n%num > 1\n    end\n    p target\n    target ? target : n\nend\n\n\n","offset":98,"fileType":"ruby","requestStartTime":1517985473065}}
{"body": {"column":9,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    p (1.n-1..).to_a.reverse\n    target = (n-1..1).to_a.find do |num| \n        p num\n        p n%num\n        n%num > 1\n    end\n    p target\n    target ? target : n\nend\n\n\n","offset":87,"fileType":"ruby","requestStartTime":1517985486285}}
{"body": {"column":10,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    p (1..n-1..).to_a.reverse\n    target = (n-1..1).to_a.find do |num| \n        p num\n        p n%num\n        n%num > 1\n    end\n    p target\n    target ? target : n\nend\n\n\n","offset":88,"fileType":"ruby","requestStartTime":1517985486429}}
{"body": {"column":27,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    target = Prime.each(n). do |num|\n        n%num == 0\n    end\n    p target ? target : n\nend\n\n\n\n","offset":105,"fileType":"ruby","requestStartTime":1517985771971}}
{"body": {"column":5,"line":3,"wordToComplete":"","code":"\n#!/bin/ruby\n\ngets.\nfor a0 in (0..t-1)\n    n,k = gets.strip.split(' ')\n    n = n.to_i\n    k = k.to_i\n    num = gets.strip\nend\n\n\n","offset":20,"fileType":"ruby","requestStartTime":1517987405402}}
{"body": {"column":10,"line":3,"wordToComplete":"","code":"\n#!/bin/ruby\n\ngets.to_i.\nfor a0 in (0..t-1)\n    n,k = gets.strip.split(' ')\n    n = n.to_i\n    k = k.to_i\n    num = gets.strip\nend\n\n\n","offset":25,"fileType":"ruby","requestStartTime":1517987409337}}
{"body": {"column":26,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ngets.to_i.times do\n  n, k = gets.strip.split.\n  n = n.to_i\n  k = k.to_i\n  num = gets.strip\nend\n\n\n","offset":60,"fileType":"ruby","requestStartTime":1517987432768}}
{"body": {"column":19,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ngets.to_i.times do\n  n, k = gets.strip.split.map(&:to_i)\n  num = gets.strip.\nend\n\n\n","offset":91,"fileType":"ruby","requestStartTime":1517987445873}}
{"body": {"column":36,"line":13,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    p_pos, k_pos = nil, nil\n    (0..7).each do |i| \n        p_pos = i if board[1][i]=='P' and board[0][i]=='#'\n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n        end\n    end\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].\n        return 2 if board[0][p_pos,k_pos]\n    or k_pos[0]==p_pos or (k_pos[0]-p_pos).abs==k_pos[1]) ? 2 : 0\nend\n\ngets.strip.to_i.times do\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":409,"fileType":"ruby","requestStartTime":1517989513446}}
{"body": {"column":13,"line":16,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    p_pos, k_pos = nil, nil\n    (0..7).each do |i| \n        p_pos = i if board[1][i]=='P' and board[0][i]=='#'\n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n        end\n    end\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].sort\n        return 2 if board[0][min+1...max] == ['#']*(max-min-1) end\n    if k_pos[1]==p_pos\n        (1...)\n        return 2 if \n        or (k_pos[0]-p_pos).abs==k_pos[1]) ? 2 : 0\nend\n\ngets.strip.to_i.times do\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":517,"fileType":"ruby","requestStartTime":1517989734821}}
{"body": {"column":23,"line":16,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    p_pos, k_pos = nil, nil\n    (0..7).each do |i| \n        p_pos = i if board[1][i]=='P' and board[0][i]=='#'\n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n        end\n    end\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].sort\n        return 2 if board[0][min+1...max] == ['#']*(max-min-1) end\n    if k_pos[1]==p_pos\n        (1...k_pos[0]).\n        return 2 if \n        or (k_pos[0]-p_pos).abs==k_pos[1]) ? 2 : 0\nend\n\ngets.strip.to_i.times do\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":527,"fileType":"ruby","requestStartTime":1517989756051}}
{"body": {"column":7,"line":3,"wordToComplete":"","code":"\ndef sum_terms(n)\n  # your code here\n    (0.)\nend\n\n\n\n","offset":45,"fileType":"ruby","requestStartTime":1517993965497}}
{"body": {"column":8,"line":3,"wordToComplete":"","code":"\ndef sum_terms(n)\n  # your code here\n    (0..)\nend\n\n\n\n","offset":46,"fileType":"ruby","requestStartTime":1517993965752}}
{"body": {"column":11,"line":3,"wordToComplete":"","code":"\ndef sum_terms(n)\n  # your code here\n    (0..n).\nend\n\n\n\n","offset":49,"fileType":"ruby","requestStartTime":1517993980671}}
{"body": {"column":40,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\ndef pin? board, king, pawn\n    if king[0]==1\n        pos = pawn < king[1]\n        return pos ? board[1][0...pawn]. : board[1][pawn+1..-1] != ['#']*(7-pawn)\n        return true end\n    if (king[0]-1).abs == (king[1]-pawn).abs\n        x,y = king[1] < pawn ? 1 : -1, king[0] < 1 ? 1 : -1\n        (1..7).each do |i|\n            return true if board[1+i*y] and board[1+i*y][pawn+x*i] and board[1+i*y][pawn+x*i] != '#' end\n        \n    end\n    \n    \ndef waysToGiveACheck(board)\n    p_pos, k_pos, king = nil, nil, nil\n    (0..7).each do |i| \n        p_pos = i if (board[1][i]=='P' and board[0][i]=='#')\n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n            king = [i,j] if board[i][j] == 'K'\n        end\n    end\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].sort\n        return 2 if board[0][min+1...max] == ['#']*(max-min-1) end\n    if k_pos[1]==p_pos\n        (2...k_pos[0]).each{|x| return 0 if board[x][p_pos] != '#'}\n        return 2 end\n    if (k_pos[1]-p_pos).abs==k_pos[0]\n        pos = k_pos[1]>p_pos ? 1 : -1\n        (1...k_pos[0]).each do |x|\n            return 0 if board[x][p_pos+x*pos] != '#' end\n        return 2 end\n    0\nend\n\ngets.strip.to_i.times do\n    board = (1..8).map{|x| gets.strip.split('')}\n    puts waysToGiveACheck(board)\nend\n\n\n","offset":128,"fileType":"ruby","requestStartTime":1517994053509}}
{"body": {"column":53,"line":9,"wordToComplete":"","code":"\n#!/bin/ruby\ndef pin? board, king, pawn\n    if king[0]==1\n        pos = pawn < king[1]\n        return pos ? board[1][0...pawn]&['r','q'].any? : board[1][pawn+1..-1]&['r','q'].any? end\n    if (king[0]-1).abs == (king[1]-pawn).abs\n        x,y = king[1] < pawn ? 1 : -1, king[0] < 1 ? 1 : -1\n        (1..7).each do |i|\n            return false if [1+i*y, pawn+x*i]&(0..7).\n            return ['q','b'].include? board[1+i*y][pawn+x*i] end\n        \n    end\n    \n    \ndef waysToGiveACheck(board)\n    p_pos, k_pos, king = nil, nil, nil\n    (0..7).each do |i| \n        p_pos = i if (board[1][i]=='P' and board[0][i]=='#')\n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n            king = [i,j] if board[i][j] == 'K'\n        end\n    end\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].sort\n        return 2 if board[0][min+1...max] == ['#']*(max-min-1) end\n    if k_pos[1]==p_pos\n        (2...k_pos[0]).each{|x| return 0 if board[x][p_pos] != '#'}\n        return 2 end\n    if (k_pos[1]-p_pos).abs==k_pos[0]\n        pos = k_pos[1]>p_pos ? 1 : -1\n        (1...k_pos[0]).each do |x|\n            return 0 if board[x][p_pos+x*pos] != '#' end\n        return 2 end\n    0\nend\n\ngets.strip.to_i.times do\n    board = (1..8).map{|x| gets.strip.split('')}\n    puts waysToGiveACheck(board)\nend\n\n\n","offset":370,"fileType":"ruby","requestStartTime":1517994461865}}
{"body": {"column":35,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ngets.to_i.times do\n  n, k = gets.split.map(&:to_i)\n  num = gets.to_i\n  \n  (0...(n - 5)).max_by { |i| num[i.] }\nend\n\n\n","offset":122,"fileType":"ruby","requestStartTime":1517995336617}}
{"body": {"column":48,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ngets.to_i.times do\n  n, k = gets.split.map(&:to_i)\n  num = gets.to_i\n  \n  (0...(n - 5)).max_by { |i| num[i..(i+5)].to_s.chars.map() }\nend\n\n\n","offset":135,"fileType":"ruby","requestStartTime":1517995353417}}
{"body": {"column":10,"line":24,"wordToComplete":"e","code":"\ndef func_any(hash)\n    # Check and return true if any key object within the hash is of the type Integer\n    # If not found, return false.\n    \n    hash.any? {|key, value| key.is_a? Integer} \nend\n\ndef func_all(hash)\n    # Check and return true if all the values within the hash are Integers and are < 10\n    # If not all values satisfy this, return false.\n    hash.all? {|key, value| value.is_a? Integer and value < 10} \nend\n\ndef func_none(hash)\n    # Check and return true if none of the values within the hash are nil\n    # If any value contains nil, return false.\n    hash.none? {|key, value| value.nil?} \nend\n\ndef func_find(hash)\n    # Check and return the first object that satisfies either of the following properties:\n    #   1. There is a [key, value] pair where the key and value are both Integers and the value is < 20 \n    #   2. There is a [key, value] pair where the key and value are both Strings and the value starts with `a`.\n    hash.e\nend\n\n\n","offset":953,"fileType":"ruby","requestStartTime":1517995617012}}
{"body": {"column":104,"line":9,"wordToComplete":"","code":"\n#!/bin/ruby\ndef pin? board, king, pawn\n    if king[0]==1\n        pos = pawn < king[1]\n        return pos ? (board[1][0...pawn]&['r','q']).any? : (board[1][pawn+1..-1]&['r','q']).any? end\n    if (king[0]-1).abs == (king[1]-pawn).abs\n        x,y = king[1] < pawn ? 1 : -1, king[0] < 1 ? 1 : -1\n        (1..7).each do |i|\n            return false if ([1+i*y, pawn+x*i]&((0..7).to_a)).size < 2 or ['k','r',\"R\",'Q','B','K','P'].\n            return true if ['q','b'].include? board[1+i*y][pawn+x*i] \n        end\n    end\nend\n\ndef check? board, k_pos\n    \n    \ndef waysToGiveACheck(board)\n    p_pos, k_pos, king = nil, nil, nil\n    (0..7).each do |i| \n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n            king = [i,j] if board[i][j] == 'K' end end\n    (0..7).each do |i| \n        p_pos = i if (board[1][i]=='P' and board[0][i]=='#' and !pin?(board, king, i))\n    end\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].sort\n        return 2 if board[0][min+1...max] == ['#']*(max-min-1) end\n    if k_pos[1]==p_pos\n        (2...k_pos[0]).each{|x| return 0 if board[x][p_pos] != '#'}\n        return 2 end\n    if (k_pos[1]-p_pos).abs==k_pos[0]\n        pos = k_pos[1]>p_pos ? 1 : -1\n        (1...k_pos[0]).each do |x|\n            return 0 if board[x][p_pos+x*pos] != '#' end\n        return 2 end\n    0\nend\n\ngets.strip.to_i.times do\n    board = (1..8).map{|x| gets.strip.split('')}\n    puts waysToGiveACheck(board)\nend\n\n\n","offset":425,"fileType":"ruby","requestStartTime":1517995809355}}
{"body": {"column":21,"line":9,"wordToComplete":"","code":"\n#!/bin/ruby\n\ngets.to_i.times do\n  n, k = gets.split.map(&:to_i)\n  num = gets.to_i\n  \n  puts((0...(n - k)).to_a.map do |i|\n    p [i, i+k]\n    r = num.to_s[i...(i+k)].to_s.chars.map(&:to_i).inject(&:*)\n    p r\n    r\n  end.max)\nend\n\n\n","offset":160,"fileType":"ruby","requestStartTime":1517995917027}}
{"body": {"column":32,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\ndef pin? board, king, pawn\n    if king[0]==1\n        pos = pawn < king[1]\n        return pos ? (['r','q'].(board[1][0...pawn]-['#'])[-1]).any? : (board[1][pawn+1..-1]&['r','q']).any? end\n    if (king[0]-1).abs == (king[1]-pawn).abs\n        x,y = king[1] < pawn ? 1 : -1, king[0] < 1 ? 1 : -1\n        (1..7).each do |i|\n            return false if (([1+i*y, pawn+x*i]&((0..7).to_a)).size < 2 or ['k','r',\"R\",'Q','B','K','P'].include? board[1+i*y][pawn+x*i] )\n            return true if ['q','b'].include? board[1+i*y][pawn+x*i] \n        end\n    end\nend\n\ndef check? board, k_pos\n    \n    \ndef waysToGiveACheck(board)\n    p_pos, k_pos, king = nil, nil, nil\n    (0..7).each do |i| \n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n            king = [i,j] if board[i][j] == 'K' end end\n    (0..7).each do |i| \n        p_pos = i if (board[1][i]=='P' and board[0][i]=='#' and !pin?(board, king, i))\n    end\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].sort\n        return 2 if board[0][min+1...max] == ['#']*(max-min-1) end\n    if k_pos[1]==p_pos\n        (2...k_pos[0]).each{|x| return 0 if board[x][p_pos] != '#'}\n        return 2 end\n    if (k_pos[1]-p_pos).abs==k_pos[0]\n        pos = k_pos[1]>p_pos ? 1 : -1\n        (1...k_pos[0]).each do |x|\n            return 0 if board[x][p_pos+x*pos] != '#' end\n        return 2 end\n    0\nend\n\ngets.strip.to_i.times do\n    board = (1..8).map{|x| gets.strip.split('')}\n    puts waysToGiveACheck(board)\nend\n\n\n","offset":120,"fileType":"ruby","requestStartTime":1517996089532}}
{"body": {"column":8,"line":17,"wordToComplete":"","code":"\n#!/bin/ruby\ndef pin? board, king, pawn\n    if king[0]==1\n        pos = pawn < king[1]\n        return pos ? ['r','q'].include?((board[1][0...pawn]-['#'])[-1]) : ['r','q'].include?((board[1][pawn+1..-1] - ['#'])[0]) end\n    if (king[0]-1).abs == (king[1]-pawn).abs\n        x,y = king[1] < pawn ? 1 : -1, king[0] < 1 ? 1 : -1\n        (1..7).each do |i|\n            return false if (([1+i*y, pawn+x*i]&((0..7).to_a)).size < 2 or ['k','r',\"R\",'Q','B','K','P'].include? board[1+i*y][pawn+x*i] )\n            return true if ['q','b'].include? board[1+i*y][pawn+x*i] \n        end\n    end\nend\n\ndef check? board, k_pos\n    x,y = k_pos\n    (1..)\nend\n    \n    \ndef waysToGiveACheck(board)\n    p_pos, k_pos, king = nil, nil, nil\n    (0..7).each do |i| \n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n            king = [i,j] if board[i][j] == 'K' end end\n    (0..7).each do |i| \n        p_pos = i if (board[1][i]=='P' and board[0][i]=='#' and !pin?(board, king, i))\n    end\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].sort\n        return 2 if board[0][min+1...max] == ['#']*(max-min-1) end\n    if k_pos[1]==p_pos\n        (2...k_pos[0]).each{|x| return 0 if board[x][p_pos] != '#'}\n        return 2 end\n    if (k_pos[1]-p_pos).abs==k_pos[0]\n        pos = k_pos[1]>p_pos ? 1 : -1\n        (1...k_pos[0]).each do |x|\n            return 0 if board[x][p_pos+x*pos] != '#' end\n        return 2 end\n    0\nend\n\ngets.strip.to_i.times do\n    board = (1..8).map{|x| gets.strip.split('')}\n    puts waysToGiveACheck(board)\nend\n\n\n","offset":634,"fileType":"ruby","requestStartTime":1517996602395}}
{"body": {"column":132,"line":5,"wordToComplete":"","code":"\ndef group_by_marks(marks, pass_marks)\n  # your code here\n    output = {}\n    output[\"Failed\"] = marks.group_by {|key,value| value>=pass_marks}[false]\n    output[\"Passed\"] = marks.group_by {|key,value| value>=pass_marks}[true] if marks.group_by {|key,value| value>=pass_marks}[true].\n    \n  return output\nend\n\n\n","offset":284,"fileType":"ruby","requestStartTime":1517997041115}}
{"body": {"column":138,"line":4,"wordToComplete":"","code":"\ndef group_by_marks(marks, pass_marks)\n  # your code here\n    output = {}\n    output[\"Failed\"] = marks.group_by {|key,value| value>=pass_marks}[false] unless marks.group_by {|key,value| value>=pass_marks}[false].\n    output[\"Passed\"] = marks.group_by {|key,value| value>=pass_marks}[true] unless marks.group_by {|key,value| value>=pass_marks}[true].nil?\n    \n  return output\nend\n\n\n","offset":213,"fileType":"ruby","requestStartTime":1517997072058}}
{"body": {"column":17,"line":18,"wordToComplete":"","code":"\n#!/bin/ruby\ndef pin? board, king, pawn\n    if king[0]==1\n        pos = pawn < king[1]\n        return pos ? ['r','q'].include?((board[1][0...pawn]-['#'])[-1]) : ['r','q'].include?((board[1][pawn+1..-1] - ['#'])[0]) end\n    if (king[0]-1).abs == (king[1]-pawn).abs\n        x,y = king[1] < pawn ? 1 : -1, king[0] < 1 ? 1 : -1\n        (1..7).each do |i|\n            return false if (([1+i*y, pawn+x*i]&((0..7).to_a)).size < 2 or ['k','r','n','p',\"R\",'Q','B','K','P','N'].include? board[1+i*y][pawn+x*i] )\n            return true if ['q','b'].include? board[1+i*y][pawn+x*i] \n        end\n    end\nend\n\ndef check? board, k_pos\n    x,y = k_pos\n    [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,-1],[-1,1]].each do |dir|\n        puts dir.\n        (1..7).each do |i|\n            break if ([x+i*dir[0], y+i*dir[1]]&((0..7).to_a)).size < 2\n            square = board[x+i*dir[0]][y+i*dir[1]]\n            if dir.include? 0\n                return true if ['Q','R'].include? square\n            else\n                return true if ['Q','B'].include? square\n            end\n            break if square != '#'\n        end\n    end\n    false\nend\n    \n    \ndef waysToGiveACheck(board)\n    p_pos, k_pos, king = nil, nil, nil\n    (0..7).each do |i| \n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n            king = [i,j] if board[i][j] == 'K' end end\n    (0..7).each do |i| \n        p_pos = i if (board[1][i]=='P' and board[0][i]=='#' and !pin?(board, king, i))\n    end\n    new_board = Marshal.load(Marshal.dump(board))\n    new_board[1][p_pos] = '#'\n    return 4 if check? new_board, k_pos\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].sort\n        return 2 if board[0][min+1...max] == ['#']*(max-min-1) end\n    if k_pos[1]==p_pos\n        (2...k_pos[0]).each{|x| return 0 if board[x][p_pos] != '#'}\n        return 2 end\n    if (k_pos[1]-p_pos).abs==k_pos[0]\n        pos = k_pos[1]>p_pos ? 1 : -1\n        (1...k_pos[0]).each do |x|\n            return 0 if board[x][p_pos+x*pos] != '#' end\n        return 2 end\n    0\nend\n\ngets.strip.to_i.times do\n    board = (1..8).map{|x| gets.strip.split('')}\n    puts waysToGiveACheck(board)\nend\n\n\n","offset":729,"fileType":"ruby","requestStartTime":1517998588402}}
{"body": {"column":15,"line":17,"wordToComplete":"","code":"\n#!/bin/ruby\ndef pin? board, king, pawn\n    if king[0]==1\n        pos = pawn < king[1]\n        return pos ? ['r','q'].include?((board[1][0...pawn]-['#'])[-1]) : ['r','q'].include?((board[1][pawn+1..-1] - ['#'])[0]) end\n    if (king[0]-1).abs == (king[1]-pawn).abs\n        x,y = king[1] < pawn ? 1 : -1, king[0] < 1 ? 1 : -1\n        (1..7).each do |i|\n            return false if (([1+i*y, pawn+x*i]&((0..7).to_a)).size < 2 or ['k','r','n','p',\"R\",'Q','B','K','P','N'].include? board[1+i*y][pawn+x*i] )\n            return true if ['q','b'].include? board[1+i*y][pawn+x*i] \n        end\n    end\nend\n\ndef check? b, k_pos\n    x,y = k_pos\n    puts k_pos.\n    [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,-1],[-1,1]].each do |dir|\n        puts dir.join ' '\n        (1..7).each do |i|\n            break if ([x+i*dir[0], y+i*dir[1]]&((0..7).to_a)).size < 2\n            square = b[x+i*dir[0]][y+i*dir[1]]\nputs [x+i*dir[0],y+i*dir[1]].join ' ' if dir == [1,-1]\n            if dir.include? 0\n                return true if ['Q','R'].include? square\n            else\n                return true if ['Q','B'].include? square\n            end\n            break if square != '#'\n        end\n    end\n    false\nend\n    \n    \ndef waysToGiveACheck(board)\n    p_pos, k_pos, king = nil, nil, nil\n    (0..7).each do |i| \n        (0..7).each do |j|\n            k_pos = [i,j] if board[i][j] == 'k'\n            king = [i,j] if board[i][j] == 'K' end end\n    (0..7).each do |i| \n        p_pos = i if (board[1][i]=='P' and board[0][i]=='#' and !pin?(board, king, i))\n    end\n    new_board = Marshal.load(Marshal.dump(board))\n    new_board[1][p_pos] = '#'\n    puts new_board[1].join ' '\n    return 4 if check? new_board, k_pos\n    return 1 if (((k_pos[1]-p_pos).abs==1 and k_pos[0]==2) or ((k_pos[1]-p_pos).abs==2 and k_pos[0]==1))\n    if k_pos[0]==0\n        min, max = [p_pos,k_pos[1]].sort\n        return 2 if board[0][min+1...max] == ['#']*(max-min-1) end\n    if k_pos[1]==p_pos\n        (2...k_pos[0]).each{|x| return 0 if board[x][p_pos] != '#'}\n        return 2 end\n    if (k_pos[1]-p_pos).abs==k_pos[0]\n        pos = k_pos[1]>p_pos ? 1 : -1\n        (1...k_pos[0]).each do |x|\n            return 0 if board[x][p_pos+x*pos] != '#' end\n        return 2 end\n    0\nend\n\ngets.strip.to_i.times do\n    board = (1..8).map{|x| gets.strip.split('')}\n    puts waysToGiveACheck(board)\nend\n\n\n","offset":649,"fileType":"ruby","requestStartTime":1517999479592}}
{"body": {"column":18,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":77,"fileType":"ruby","requestStartTime":1518003963370}}
{"body": {"column":14,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":95,"fileType":"ruby","requestStartTime":1518003979913}}
{"body": {"column":36,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.count(max_val) == arr.)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":117,"fileType":"ruby","requestStartTime":1518003991365}}
{"body": {"column":22,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.count(max_val) != arr.size) do\n        min_val = arr.\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":148,"fileType":"ruby","requestStartTime":1518004015294}}
{"body": {"column":25,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.count(max_val) != arr.size) do\n        sorted_arr = arr.\n        min_val = arr.min\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":151,"fileType":"ruby","requestStartTime":1518004049734}}
{"body": {"column":30,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.count(max_val) != arr.size) do\n        sorted_arr = arr.uniq.sort\n        min_1 = sorted_arr[0]\n        min_2 = sorted_arr[1]\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":156,"fileType":"ruby","requestStartTime":1518004087178}}
{"body": {"column":26,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.count(max_val) != arr.size) do\n        sorted_arr = arr.uniq.sort\n        min_1 = sorted_arr[0]\n        min_2 = sorted_arr[1]\n        if min_2 - min_1 >\n        elsif\n        else\n        end\n        max_val = arr.max\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":247,"fileType":"ruby","requestStartTime":1518004154330}}
{"body": {"column":18,"line":17,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.count(max_val) != arr.size) do\n        sorted_arr = arr.uniq.sort\n        min_1 = sorted_arr[0]\n        min_2 = sorted_arr[1]\n        add = if min_2 - min_1 >= 5\n            5\n        elsif min_2 - min_1 >= 2\n            2\n        else\n            1\n        end\n        arr = arr.\n        max_val = arr.max\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":375,"fileType":"ruby","requestStartTime":1518004206731}}
{"body": {"column":8,"line":17,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.count(max_val) != arr.size) do\n        sorted_arr = arr.uniq.sort\n        min_1 = sorted_arr[0]\n        min_2 = sorted_arr[1]\n        add = if min_2 - min_1 >= 5\n            5\n        elsif min_2 - min_1 >= 2\n            2\n        else\n            1\n        end\n    arr.each_with_index\n        arr = arr.map{ |num| num + add}\n        max_val = arr.max\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":365,"fileType":"ruby","requestStartTime":1518004288278}}
{"body": {"column":24,"line":17,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.count(max_val) != arr.size) do\n        sorted_arr = arr.uniq.sort\n        min_1 = sorted_arr[0]\n        min_2 = sorted_arr[1]\n        add = if min_2 - min_1 >= 5\n            5\n        elsif min_2 - min_1 >= 2\n            2\n        else\n            1\n        end\n    arr.each_with_index.\n        arr = arr.map{ |num| num + add}\n        max_val = arr.max\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":381,"fileType":"ruby","requestStartTime":1518004289663}}
{"body": {"column":25,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    # Complete this function\n    max_val = arr.max\n    while(arr.count(max_val) != arr.size) do\n        sorted_arr = arr.uniq.sort\n        min_1 = sorted_arr[0]\n        min_2 = sorted_arr[1]\n        skip_index = arr.\n        add = if min_2 - min_1 >= 5\n            5\n        elsif min_2 - min_1 >= 2\n            2\n        else\n            1\n        end\n    arr.each_with_index do |num, index|\n        if index != \n    end\n        arr = arr.map{ |num| num + add}\n        max_val = arr.max\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":246,"fileType":"ruby","requestStartTime":1518004319950}}
{"body": {"column":7,"line":13,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef fibonacciModified(t1, t2, n)\n    # Complete this function\n    if n == 1\n       t1\n    elsif n == 2\n       t2\n    else\n        fibonacciModified(t1, t2, n-2) + fibonacciModified(t1, t2, n-1) * fibonacciModified(t1, t2, n-1)\n    end\n    \n    (1.)\nend\n\nt1, t2, n = gets.strip.split(' ')\nt1 = t1.to_i\nt2 = t2.to_i\nn = n.to_i\nresult = fibonacciModified(t1, t2, n)\nputs result\n\n\n","offset":262,"fileType":"ruby","requestStartTime":1518005234208}}
{"body": {"column":8,"line":13,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef fibonacciModified(t1, t2, n)\n    # Complete this function\n    if n == 1\n       t1\n    elsif n == 2\n       t2\n    else\n        fibonacciModified(t1, t2, n-2) + fibonacciModified(t1, t2, n-1) * fibonacciModified(t1, t2, n-1)\n    end\n    \n    (1..)\nend\n\nt1, t2, n = gets.strip.split(' ')\nt1 = t1.to_i\nt2 = t2.to_i\nn = n.to_i\nresult = fibonacciModified(t1, t2, n)\nputs result\n\n\n","offset":263,"fileType":"ruby","requestStartTime":1518005234365}}
{"body": {"column":11,"line":13,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef fibonacciModified(t1, t2, n)\n    # Complete this function\n    if n == 1\n       t1\n    elsif n == 2\n       t2\n    else\n        fibonacciModified(t1, t2, n-2) + fibonacciModified(t1, t2, n-1) * fibonacciModified(t1, t2, n-1)\n    end\n    \n    (1..n).\nend\n\nt1, t2, n = gets.strip.split(' ')\nt1 = t1.to_i\nt2 = t2.to_i\nn = n.to_i\nresult = fibonacciModified(t1, t2, n)\nputs result\n\n\n","offset":266,"fileType":"ruby","requestStartTime":1518005236327}}
{"body": {"column":6,"line":13,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef fibonacciModified(t1, t2, n)\n    # Complete this function\n   #  if n == 1\n    #    t1\n#     elsif n == 2\n   #     t2\n   #  else\n   #      fibonacciModified(t1, t2, n-2) + fibonacciModified(t1, t2, n-1) * fibonacciModified(t1, t2, n-1)\n  #   end\n    \n    0..each do |num|\n        n_t2 = t1 + t2*t2\n        t2 = n_t2\n        t1 = t2\n    end\n    t2\nend\n\nt1, t2, n = gets.strip.split(' ')\nt1 = t1.to_i\nt2 = t2.to_i\nn = n.to_i\nresult = fibonacciModified(t1, t2, n)\nputs result\n\n\n","offset":275,"fileType":"ruby","requestStartTime":1518005442130}}
{"body": {"column":12,"line":13,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef fibonacciModified(t1, t2, n)\n    # Complete this function\n     if n == 1\n        t1\n     elsif n == 2\n        t2\n     else\n         fibonacciModified(t1, t2, n-2) + fibonacciModified(t1, t2, n-1) * fibonacciModified(t1, t2, n-1)\n     end\n    if n > 2\n        n-2.\n    elsif n == 2\n        t2\n    else\n        t1\n    end\nend\n\nt1, t2, n = gets.strip.split(' ')\nt1 = t1.to_i\nt2 = t2.to_i\nn = n.to_i\nresult = fibonacciModified(t1, t2, n)\nputs result\n\n\n","offset":282,"fileType":"ruby","requestStartTime":1518005893558}}
{"body": {"column":47,"line":1,"wordToComplete":"123][120][xs0][30aA][xsu][.,]'","code":"\nRegex_Pattern = '^[123][120][xs0][30aA][xsu][.,]'\n\n\n\nprint !!(gets =~ /#{Regex_Pattern}/)\n","offset":49,"fileType":"ruby","requestStartTime":1518006352143}}
{"body": {"column":14,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    while arr.\n       arr.max \n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":44,"fileType":"ruby","requestStartTime":1518009175691}}
{"body": {"column":19,"line":4,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    while arr.uniq.\n       arr.max \n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":49,"fileType":"ruby","requestStartTime":1518009177386}}
{"body": {"column":15,"line":8,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    i = 0\n    while arr.uniq.size != 1\n        i++\n        max = arr.each_with_index.max\n        if max.\n        arr[max[1]]\n    end\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":134,"fileType":"ruby","requestStartTime":1518009461999}}
{"body": {"column":18,"line":8,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    i = 0\n    while arr.uniq.size != 1\n        i+=1\n        max = arr.each_with_index.max\n        min = arr.\n        if max[1] >=5\n            max[0]-=5\n        elsif max[1] >=2\n            max[0]-=2\n        else\n            max[0]-=1\n        end\n        arr[max[1]]=max[0]\n    end\n    i\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":138,"fileType":"ruby","requestStartTime":1518009623355}}
{"body": {"column":34,"line":8,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    i = 0\n    while arr.uniq.size != 1\n        i+=1\n        max = arr.each_with_index.max\n        min = arr.each_with_index.\n        if max[1] >=5\n            max[0]-=5\n        elsif max[1] >=2\n            max[0]-=2\n        else\n            max[0]-=1\n        end\n        arr[max[1]]=max[0]\n    end\n    i\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":154,"fileType":"ruby","requestStartTime":1518009630467}}
{"body": {"column":20,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    i = 0\n    while arr.uniq.size != 1\n\n        max = arr.each_with_index.max\n        min = arr.each_with_index.min\n        diff = max[1]-min[1]\n        if (diff/5).\n\n        if diff > 5\n        if max[1] >=5\n            max[0]-=5\n        elsif max[1] >=2\n            max[0]-=2\n        else\n            max[0]-=1\n        end\n        arr[max[1]]=max[0]\n    end\n    i\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":195,"fileType":"ruby","requestStartTime":1518009740977}}
{"body": {"column":12,"line":35,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    if root.\n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":850,"fileType":"ruby","requestStartTime":1518009793641}}
{"body": {"column":32,"line":35,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    if root.value >= 1 and root.\n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":870,"fileType":"ruby","requestStartTime":1518009810179}}
{"body": {"column":30,"line":15,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    i = 0\n    while arr.uniq.size != 1\n\n        max = arr.each_with_index.max\n        min = arr.each_with_index.min\n        diff = max[1]-min[1]\n        rounds = (diff/5).to_i\n        if rounds > 0\n            i+=rounds\n            max[0] -= rounds*diff\n        else\n            rounds = (diff/2).\n            \n        if diff > 5\n        if max[1] >=5\n            max[0]-=5\n        elsif max[1] >=2\n            max[0]-=2\n        else\n            max[0]-=1\n        end\n        arr[max[1]]=max[0]\n    end\n    i\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":327,"fileType":"ruby","requestStartTime":1518010001131}}
{"body": {"column":12,"line":39,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    if root.value == val\n        puts 1\n    end\n    \n    if root.\n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":903,"fileType":"ruby","requestStartTime":1518010019086}}
{"body": {"column":12,"line":43,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    if root.value == val\n        puts 1\n    end\n    \n    if root.left == val\n        puts 1\n    end\n    \n    if root.\n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":955,"fileType":"ruby","requestStartTime":1518010076350}}
{"body": {"column":17,"line":39,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    if root.value == val\n        puts 1\n    end\n    \n    if root.left. == val\n        puts 1\n    end\n    \n    if root.right == val\n        puts 1\n    end\n    \n    \n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":908,"fileType":"ruby","requestStartTime":1518010233426}}
{"body": {"column":17,"line":25,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    i = 0\n    while arr.uniq.size != 1\n\n        max = arr.each_with_index.max\n        min = arr.each_with_index.min\n        diff = max[1]-min[1]\n        rounds = (diff/5).to_i\n        if rounds > 0\n            i+=rounds\n            max[0] -= rounds*diff\n        else\n            rounds = (diff/2).to_i\n            if rounds > 0\n                i+=rounds\n                max[0] -= rounds*diff\n            else\n                i+=1\n                max[0] -=1\n            end\n        end\n        arr[max[1]]=max[0]\n        puts arr.\n    end\n    \n    i\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":559,"fileType":"ruby","requestStartTime":1518010348805}}
{"body": {"column":12,"line":46,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    case val\n    when root.value\n        puts 1\n    when root.left.value\n        puts 1\n    when root.right.value\n        puts 1\n    else\n        puts 0\n    end\n    \n    if root.\n    \n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":1016,"fileType":"ruby","requestStartTime":1518010639135}}
{"body": {"column":23,"line":47,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    case val\n    when root.value\n        puts 1\n    when root.left.value\n        puts 1\n    when root.right.value\n        puts 1\n    else\n        puts 0\n    end\n    \n    if root.next\n        isPresent(root.)\n    \n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":1044,"fileType":"ruby","requestStartTime":1518010655143}}
{"body": {"column":10,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board.\n\ndef knight_moves(position)\nend\n\ndef rook_moves(position)\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":133,"fileType":"ruby","requestStartTime":1518010760176}}
{"body": {"column":13,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\nend\n\ndef rook_moves(position)\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":136,"fileType":"ruby","requestStartTime":1518010765416}}
{"body": {"column":17,"line":46,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    case val\n    when root.value\n        puts 1\n    when root.left.value\n        puts 1\n    when root.right.value\n        puts 1\n    else\n        puts 0\n    end\n    \n    if root.left.next\n        isPresent(root.next, val)\n    end\n    \n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":1021,"fileType":"ruby","requestStartTime":1518010777378}}
{"body": {"column":28,"line":47,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    case val\n    when root.value\n        puts 1\n    when root.left.value\n        puts 1\n    when root.right.value\n        puts 1\n    else\n        puts 0\n    end\n    \n    if root.left.next\n        isPresent(root.left.next, val)\n    end\n    \n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":1054,"fileType":"ruby","requestStartTime":1518010783779}}
{"body": {"column":39,"line":47,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    case val\n    when root.value\n        puts 1\n    when root.left.value\n        puts 1\n    when root.right.value\n        puts 1\n    else\n        puts 0\n    end\n    \n    if root.left.next\n        isPresent(root.left.next, root.)\n    end\n    \n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":1065,"fileType":"ruby","requestStartTime":1518010793994}}
{"body": {"column":44,"line":47,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    case val\n    when root.value\n        puts 1\n    when root.left.value\n        puts 1\n    when root.right.value\n        puts 1\n    else\n        puts 0\n    end\n    \n    if root.left.next\n        isPresent(root.left.next, root.left.)\n    end\n    \n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":1070,"fileType":"ruby","requestStartTime":1518010795109}}
{"body": {"column":12,"line":50,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    case val\n    when root.value\n        puts 1\n    when root.left.value\n        puts 1\n    when root.right.value\n        puts 1\n    else\n        puts 0\n    end\n    \n    if root.left.next\n        isPresent(root.left.next, root.left.value)\n    end\n    \n    if root.\n    \n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":1102,"fileType":"ruby","requestStartTime":1518010805605}}
{"body": {"column":18,"line":50,"wordToComplete":"","code":"#!/usr/bin/env ruby\nclass BSTreeNode\n    attr_accessor :right, :left, :value\n    def initialize(node_value)\n        @value = node_value;\n        @left = @right = nil;\n    end\nend\n\ndef _insert_node_into_binarysearchtree(node, data)\n    if node == nil\n        node = BSTreeNode.new(data)\n    else\n        if data <= node.value\n            node.left = _insert_node_into_binarysearchtree(node.left, data);\n        else\n            node.right = _insert_node_into_binarysearchtree(node.right, data);\n        end\n    end\n    return node;\nend\n#   For your reference.\n#  class BSTreeNode {\n#      int value;\n#      BSTreeNode previous;\n#      BSTreeNode next;\n#      public BSTreeNode(int v){\n#          this.value = v;\n#          this.left = null;\n#          this.right = null;\n#      }\n#  }\n\ndef isPresent(root , val)\n    #write your code here\n    case val\n    when root.value\n        puts 1\n    when root.left.value\n        puts 1\n    when root.right.value\n        puts 1\n    else\n        puts 0\n    end\n    \n    if root.left.next\n        isPresent(root.left.next, root.left.value)\n    end\n    \n    if root.right.\n    \n    #return 1 or 0 depending on whether the element is present in the tree or not\nend\n_a = nil\n_a_size = Integer(gets)\n_a_i = 0\nwhile _a_i < _a_size\n    _a_item = Integer(gets)\n    _a = _insert_node_into_binarysearchtree(_a, _a_item)\n    _a_i += 1\nend\n\nq = Integer(gets)\ni = 0\n\nwhile i < q\n    _b = Integer(gets)\n    _result = isPresent(_a, _b)\n    print _result.to_s + \"\\n\"\n    i += 1\nend\n","offset":1108,"fileType":"ruby","requestStartTime":1518010806865}}
{"body": {"column":14,"line":6,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    i = 0\n    \n    min = arr.\n    \n    i\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":59,"fileType":"ruby","requestStartTime":1518010993721}}
{"body": {"column":8,"line":8,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    i = 0\n    \n    min = arr.min\n    \n    arr.\n    \n    i\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":76,"fileType":"ruby","requestStartTime":1518011001065}}
{"body": {"column":8,"line":9,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef equal(arr)\n    min = arr.min\n    \n    arr.map do |e|\n       diff = e - min\n       (diff/5)+diff%5/2+diff%5%2\n    end.\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    n = gets.strip.to_i\n    arr = gets.strip\n    arr = arr.split(' ').map(&:to_i)\n    result = equal(arr)\n    puts result\nend\n\n\n","offset":136,"fileType":"ruby","requestStartTime":1518011063369}}
{"body": {"column":13,"line":7,"wordToComplete":"z","code":"#!/bin/ruby\n\n\n# Complete the function below.\n\ndef minNum(A, K, P)\n    diff = A - K\n    if diff.z\nend\n\nfp = File.open(ENV['OUTPUT_PATH'], 'w')\n\nA = Integer(gets);\n\nK = Integer(gets);\n\nP = Integer(gets);\n\n\nres = minNum(A, K, P);\nfp.write res;\nfp.write \"\\n\"\n\nfp.close()\n\n","offset":97,"fileType":"ruby","requestStartTime":1518011654498}}
{"body": {"column":10,"line":14,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [], []]\n    moves.\nend\n\ndef rook_moves(position)\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":234,"fileType":"ruby","requestStartTime":1518011708684}}
{"body": {"column":24,"line":14,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [], []]\n    moves.reject {|m| m.}\nend\n\ndef rook_moves(position)\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":248,"fileType":"ruby","requestStartTime":1518011736347}}
{"body": {"column":24,"line":14,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [], []]\n    moves.reject {|m| m.}\nend\n\ndef rook_moves(position)\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":248,"fileType":"ruby","requestStartTime":1518011749011}}
{"body": {"column":24,"line":14,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [], []]\n    moves.reject {|m| m.}\nend\n\ndef rook_moves(position)\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":248,"fileType":"ruby","requestStartTime":1518011788194}}
{"body": {"column":61,"line":13,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [position.], []]\n    moves.reject {|m| m[0] < 0 || m[0] > 7}\nend\n\ndef rook_moves(position)\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":226,"fileType":"ruby","requestStartTime":1518011932423}}
{"body": {"column":7,"line":18,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [position - 1, 2], [position + 1, 2]]\n    moves.reject {|m| m[0] < 0 || m[0] > 7}\nend\n\ndef rook_moves(position)\n    (0.)\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":335,"fileType":"ruby","requestStartTime":1518012102049}}
{"body": {"column":8,"line":18,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [position - 1, 2], [position + 1, 2]]\n    moves.reject {|m| m[0] < 0 || m[0] > 7}\nend\n\ndef rook_moves(position)\n    (0..)\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":336,"fileType":"ruby","requestStartTime":1518012102209}}
{"body": {"column":11,"line":18,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [position - 1, 2], [position + 1, 2]]\n    moves.reject {|m| m[0] < 0 || m[0] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":339,"fileType":"ruby","requestStartTime":1518012113681}}
{"body": {"column":11,"line":18,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [position - 1, 2], [position + 1, 2]]\n    moves.reject {|m| m[0] < 0 || m[0] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":339,"fileType":"ruby","requestStartTime":1518012131129}}
{"body": {"column":16,"line":18,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [position - 1, 2], [position + 1, 2]]\n    moves.reject {|m| m[0] < 0 || m[0] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":344,"fileType":"ruby","requestStartTime":1518012133969}}
{"body": {"column":17,"line":18,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [position - 1, 2], [position + 1, 2]]\n    moves.reject {|m| m[0] < 0 || m[0] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a..map {|p| }\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":345,"fileType":"ruby","requestStartTime":1518012151641}}
{"body": {"column":26,"line":18,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].\n\ndef knight_moves(position)\n    moves = [[position - 2, 1], [position + 2, 1], [position - 1, 2], [position + 1, 2]]\n    moves.reject {|m| m[0] < 0 || m[0] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {}.map {|p| }\nend\n\ndef bishop_moves(position)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":354,"fileType":"ruby","requestStartTime":1518012162145}}
{"body": {"column":24,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    \nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":147,"fileType":"ruby","requestStartTime":1518012458121}}
{"body": {"column":24,"line":10,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    \nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":147,"fileType":"ruby","requestStartTime":1518012573745}}
{"body": {"column":7,"line":23,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0.)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":473,"fileType":"ruby","requestStartTime":1518012727177}}
{"body": {"column":8,"line":23,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0..)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":474,"fileType":"ruby","requestStartTime":1518012727473}}
{"body": {"column":18,"line":23,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0..position).\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":484,"fileType":"ruby","requestStartTime":1518012832948}}
{"body": {"column":9,"line":23,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0...position).\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":475,"fileType":"ruby","requestStartTime":1518012843136}}
{"body": {"column":65,"line":23,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1).\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":531,"fileType":"ruby","requestStartTime":1518013010474}}
{"body": {"column":66,"line":23,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":532,"fileType":"ruby","requestStartTime":1518013010651}}
{"body": {"column":67,"line":23,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)...)\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":533,"fileType":"ruby","requestStartTime":1518013015067}}
{"body": {"column":69,"line":23,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    p board\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":535,"fileType":"ruby","requestStartTime":1518013040479}}
{"body": {"column":19,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions.p knight_moves()\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":91,"fileType":"ruby","requestStartTime":1518013285751}}
{"body": {"column":19,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions.p knight_moves()\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":91,"fileType":"ruby","requestStartTime":1518013288175}}
{"body": {"column":26,"line":5,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).p knight_moves()\n    nil\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0..7).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":98,"fileType":"ruby","requestStartTime":1518013291551}}
{"body": {"column":9,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0...).to_a.reject {|p| p == position}.map {|p| [0, p]}\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":587,"fileType":"ruby","requestStartTime":1518013936174}}
{"body": {"column":68,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0...position).to_a.reject {|p| p == position}.map {|p| [0, p]}.\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":646,"fileType":"ruby","requestStartTime":1518013942766}}
{"body": {"column":66,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0...7).to_a.reject {|p| p == position}.map {|p| [0, p]} + (1.)\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":644,"fileType":"ruby","requestStartTime":1518014089066}}
{"body": {"column":67,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0...7).to_a.reject {|p| p == position}.map {|p| [0, p]} + (1..)\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":645,"fileType":"ruby","requestStartTime":1518014089322}}
{"body": {"column":68,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0...7).to_a.reject {|p| p == position}.map {|p| [0, p]} + (1...)\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":646,"fileType":"ruby","requestStartTime":1518014089650}}
{"body": {"column":70,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0...7).to_a.reject {|p| p == position}.map {|p| [0, p]} + (1..7).\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":648,"fileType":"ruby","requestStartTime":1518014093618}}
{"body": {"column":82,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    (0...7).to_a.reject {|p| p == position}.map {|p| [0, p]} + (1..7).map {|p| [p.]}\nend\n\ndef bishop_moves(position)\n    (0...position).map {|p| [position - p, p]} + ((position + 1)..7).map {|p| [p - position, p]}\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":660,"fileType":"ruby","requestStartTime":1518014110146}}
{"body": {"column":37,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}., (0...position).map {|p| [0, p]} + (1..7).map {|p| [p, position]}\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":615,"fileType":"ruby","requestStartTime":1518014303378}}
{"body": {"column":60,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":638,"fileType":"ruby","requestStartTime":1518014333504}}
{"body": {"column":61,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)...map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":639,"fileType":"ruby","requestStartTime":1518014333688}}
{"body": {"column":62,"line":28,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)....map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":640,"fileType":"ruby","requestStartTime":1518014333857}}
{"body": {"column":48,"line":32,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, point)\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}., ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":772,"fileType":"ruby","requestStartTime":1518014355012}}
{"body": {"column":9,"line":15,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n    end\n    nil\nend\n\ndef check_move(board, move)\n    move.\n    board[point[0]][point[1]] == 'k'\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}.reverse, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":266,"fileType":"ruby","requestStartTime":1518014380433}}
{"body": {"column":21,"line":11,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    count = 0\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n        knight_moves.\n    end\n    nil\nend\n\ndef is_check?(board, move)\n    move.each do |(row, col)|\n        unless board[row][point] == '#'\n            return board[row][point] == 'k'\n        end\n    end\n    return false\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}.reverse, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":243,"fileType":"ruby","requestStartTime":1518014816479}}
{"body": {"column":26,"line":11,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    count = 0\n    pawn_positions(board).each do |pos|\n        p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n        knight_moves(pos).\n    end\n    nil\nend\n\ndef is_check?(board, move)\n    move.each do |(row, col)|\n        unless board[row][point] == '#'\n            return board[row][point] == 'k'\n        end\n    end\n    return false\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}.reverse, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":248,"fileType":"ruby","requestStartTime":1518014819399}}
{"body": {"column":16,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    count = 0\n    pawn_positions(board).each do |pos|\n        STD_ERR.p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n        count += knight_moves(pos).count {|m| is_check?(board, m)}\n        count += rook_moves(pos).count {|m| is_check?(board, m)} * 2\n        count += bishop_moves(pos).count {|m| is_check?(board, m)} * 2\n    end\n    count\nend\n\ndef is_check?(board, move)\n    move.each do |(row, col)|\n        unless board[row][point] == '#'\n            return board[row][point] == 'k'\n        end\n    end\n    return false\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}.reverse, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":142,"fileType":"ruby","requestStartTime":1518014948630}}
{"body": {"column":15,"line":7,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    count = 0\n    pawn_positions(board).each do |pos|\n        STDERR.p pos\n        p knight_moves(pos)\n        p rook_moves(pos)\n        p bishop_moves(pos)\n        count += knight_moves(pos).count {|m| is_check?(board, m)}\n        count += rook_moves(pos).count {|m| is_check?(board, m)} * 2\n        count += bishop_moves(pos).count {|m| is_check?(board, m)} * 2\n    end\n    count\nend\n\ndef is_check?(board, move)\n    move.each do |(row, col)|\n        unless board[row][point] == '#'\n            return board[row][point] == 'k'\n        end\n    end\n    return false\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}.reverse, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":141,"fileType":"ruby","requestStartTime":1518015004046}}
{"body": {"column":15,"line":16,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    count = 0\n    pawn_positions(board).each do |pos|\n        count += knight_moves(pos).count {|m| is_check?(board, m)}\n        count += rook_moves(pos).count {|m| is_check?(board, m)} * 2\n        count += bishop_moves(pos).count {|m| is_check?(board, m)} * 2\n    end\n    count\nend\n\ndef is_check?(board, move)\n    move.each do |(row, col)|\n        STDERR.\n        unless board[row][col] == '#'\n            return board[row][col] == 'k'\n        end\n    end\n    return false\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[1, position - 2], [1, position + 2], [2, position - 1], [2, position + 1]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}.reverse, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":428,"fileType":"ruby","requestStartTime":1518015084877}}
{"body": {"column":34,"line":20,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    count = 0\n    pawn_positions(board).each do |pos|\n        p pos\n        p rook_moves(pos)\n        p knight_moves(pos)\n        p bishop_moves(pos)\n        count += knight_moves(pos).count {|m| is_check?(board, m)}\n        count += rook_moves(pos).count {|m| is_check?(board, m)} * 2\n        count += bishop_moves(pos).count {|m| is_check?(board, m)} * 2\n    end\n    count\nend\n\ndef is_check?(board, move)\n    move.each do |(row, col)|\n        STDERR.puts \"move: #{move.}; board[#{row}][#{col}]==#{board[row][col]}\"\n        unless board[row][col] == '#'\n            return board[row][col] == 'k'\n        end\n    end\n    return false\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[[1, position - 2]], [[1, position + 2]], [[2, position - 1]], [[2, position + 1]]]\n    #moves.reject {|m| m[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}.reverse, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":543,"fileType":"ruby","requestStartTime":1518015477119}}
{"body": {"column":24,"line":35,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    count = 0\n    pawn_positions(board).each do |pos|\n        #p pos\n        #p rook_moves(pos)\n        #p knight_moves(pos)\n        #p bishop_moves(pos)\n        count += knight_moves(pos).count {|m| is_check?(board, m)}\n        count += rook_moves(pos).count {|m| is_check?(board, m)} * 2\n        count += bishop_moves(pos).count {|m| is_check?(board, m)} * 2\n    end\n    count\nend\n\ndef is_check?(board, move)\n    move.each do |(row, col)|\n        STDERR.puts \"move: #{move.inspect}; board[#{row}][#{col}]==#{board[row][col]}\"\n        unless board[row][col] == '#'\n            STDERR.puts \"check\" if board[row][col] == 'k'\n            return board[row][col] == 'k'\n        end\n    end\n    return false\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[[1, position - 2]], [[1, position + 2]], [[2, position - 1]], [[2, position + 1]]]\n    moves.reject {|m| m.[1] < 0 || m[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}.reverse, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":1015,"fileType":"ruby","requestStartTime":1518015638766}}
{"body": {"column":42,"line":35,"wordToComplete":"","code":"\n#!/bin/ruby\n\ndef waysToGiveACheck(board)\n    # Complete this function\n    count = 0\n    pawn_positions(board).each do |pos|\n        #p pos\n        #p rook_moves(pos)\n        #p knight_moves(pos)\n        #p bishop_moves(pos)\n        count += knight_moves(pos).count {|m| is_check?(board, m)}\n        count += rook_moves(pos).count {|m| is_check?(board, m)} * 2\n        count += bishop_moves(pos).count {|m| is_check?(board, m)} * 2\n    end\n    count\nend\n\ndef is_check?(board, move)\n    move.each do |(row, col)|\n        STDERR.puts \"move: #{move.inspect}; board[#{row}][#{col}]==#{board[row][col]}\"\n        unless board[row][col] == '#'\n            STDERR.puts \"check\" if board[row][col] == 'k'\n            return board[row][col] == 'k'\n        end\n    end\n    return false\nend\n\ndef pawn_positions(board)\n    board[1].each_index.select {|i| board[1][i] == 'P'}\nend\n\ndef knight_moves(position)\n    moves = [[[1, position - 2]], [[1, position + 2]], [[2, position - 1]], [[2, position + 1]]]\n    moves.reject {|m| m.first[1] < 0 || m.[1] > 7}\nend\n\ndef rook_moves(position)\n    [(0...position).map {|p| [0, p]}.reverse, ((position+1)..7).map {|p| [0, p]}, (1..7).map {|p| [p, position]}]\nend\n\ndef bishop_moves(position)\n    [(0...position).map {|p| [position - p, p]}.reverse, ((position + 1)..7).map {|p| [p - position, p]}]\nend\n\ndef queen_moves(position)\n    rook_moves(position) + bishop_moves(position)\nend\n\nt = gets.strip.to_i\nfor a0 in (0..t-1)\n    board = Array.new(8)\n    for board_i in (0..8-1)\n        board_t = gets.strip\n        board[board_i] = board_t.split('')\n    end\n    result = waysToGiveACheck(board)\n    puts result\nend\n\n\n","offset":1033,"fileType":"ruby","requestStartTime":1518015642382}}
